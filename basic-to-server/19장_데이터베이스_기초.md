# 19장. 데이터베이스 기초

> **목표**: SQL의 기본 문법을 익히고, PostgreSQL 환경을 설정한다.

> 웹서버는 데이터를 저장해야 합니다. 데이터베이스가 그 역할을 합니다!

---

## 1. 데이터베이스란?

데이터를 **체계적으로 저장하고 관리**하는 시스템입니다.

엑셀 시트를 생각해보세요. 행(row)과 열(column)로 데이터를 정리하죠? 데이터베이스는 그 **강화판**입니다:

| 엑셀 | 데이터베이스 |
|------|------------|
| 파일 하나에 저장 | 서버에서 관리 |
| 한 명이 편집 | 동시에 여러 명 접근 가능 |
| 데이터 검증 없음 | 제약 조건으로 데이터 보호 |
| 느림 (대용량) | 빠름 (인덱스, 최적화) |

### 관계형 데이터베이스 (RDBMS)

데이터를 **테이블(표)** 형태로 저장합니다. 테이블 간에 **관계(relation)**를 맺을 수 있어서 "관계형"이라고 합니다.

```
users 테이블:
+----+--------+------------------+-----+
| id | name   | email            | age |
+----+--------+------------------+-----+
|  1 | 홍길동 | hong@mail.com    |  20 |
|  2 | 김철수 | kim@mail.com     |  25 |
|  3 | 이영희 | lee@mail.com     |  22 |
+----+--------+------------------+-----+
```

### 왜 PostgreSQL인가?

| 특징 | 설명 |
|------|------|
| 무료 | 오픈소스, 상업적 사용도 무료 |
| 강력함 | JSON, 배열, 전문 검색 등 기능이 풍부 |
| 인기 | 웹 개발에서 가장 많이 선택되는 DB 중 하나 |
| Rust 호환 | SQLx가 PostgreSQL을 잘 지원 |

> MySQL, SQLite 등 다른 DB도 있지만, 이 학습지에서는 PostgreSQL을 사용합니다. SQL 기본 문법은 거의 동일하니 걱정 마세요.

---

## 2. PostgreSQL 설치

### 방법 1: Windows 직접 설치

1. [postgresql.org/download/windows](https://www.postgresql.org/download/windows/) 에서 설치 파일 다운로드
2. 설치 마법사를 따라 진행:
   - 비밀번호 설정 (기억해두세요!)
   - 포트: 기본값 `5432` 그대로
   - pgAdmin 4 포함 설치 체크
3. 설치 완료 후 pgAdmin 4 실행

### pgAdmin 소개

pgAdmin은 PostgreSQL을 **GUI로 관리**하는 도구입니다. SQL을 직접 입력하고 결과를 볼 수 있습니다.

```
pgAdmin 사용법:
1. pgAdmin 실행 → 비밀번호 입력
2. 왼쪽 트리에서 Servers → PostgreSQL 클릭
3. Databases → postgres 우클릭 → Query Tool
4. SQL 입력 → F5 (또는 ▶ 버튼)으로 실행
```

### 방법 2: Docker로 설치 (추천)

Docker가 설치되어 있다면 한 줄로 PostgreSQL을 띄울 수 있습니다:

```bash
docker run --name my-postgres -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgres
```

| 옵션 | 의미 |
|------|------|
| `--name my-postgres` | 컨테이너 이름 |
| `-e POSTGRES_PASSWORD=password` | DB 비밀번호 설정 |
| `-p 5432:5432` | 포트 연결 (호스트:컨테이너) |
| `-d postgres` | 백그라운드 실행 |

Docker 컨테이너 안에서 SQL을 실행하려면:

```bash
docker exec -it my-postgres psql -U postgres
```

### 연결 확인

어떤 방법이든 설치 후, 아래 SQL을 실행해서 동작을 확인하세요:

```sql
SELECT version();
```

PostgreSQL 버전 정보가 출력되면 성공입니다.

<details>
<summary><b>Docker란? (원리)</b></summary>

Docker는 **격리된 환경(컨테이너)**에서 소프트웨어를 실행하는 도구입니다.

PostgreSQL을 직접 설치하면 운영체제에 깊이 설치되어 나중에 제거하기 어렵습니다. Docker를 사용하면:

- **설치/제거가 간단**: `docker run`으로 시작, `docker rm`으로 삭제
- **환경 오염 없음**: 호스트 시스템에 영향을 주지 않음
- **버전 관리 쉬움**: `postgres:15`, `postgres:16` 등 원하는 버전 지정
- **팀 환경 통일**: 모든 팀원이 동일한 환경에서 개발

실무에서도 개발 환경의 DB는 대부분 Docker로 실행합니다.

</details>

---

## 3. SQL 기초 - 테이블 만들기 (CREATE)

SQL(Structured Query Language)은 **데이터베이스와 대화하는 언어**입니다.

### 테이블 생성

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    age INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);
```

한 줄씩 살펴봅시다:

| 컬럼 | 타입 | 제약 조건 | 설명 |
|------|------|----------|------|
| `id` | `SERIAL` | `PRIMARY KEY` | 자동 증가하는 고유 번호 |
| `name` | `VARCHAR(100)` | `NOT NULL` | 최대 100자 문자열, 비어있으면 안 됨 |
| `email` | `VARCHAR(255)` | `UNIQUE NOT NULL` | 최대 255자, 중복 불가, 비어있으면 안 됨 |
| `age` | `INTEGER` | (없음) | 정수, NULL 허용 |
| `created_at` | `TIMESTAMP` | `DEFAULT NOW()` | 날짜+시간, 기본값은 현재 시각 |

### 주요 데이터 타입

| 타입 | 설명 | 예시 |
|------|------|------|
| `INTEGER` | 정수 | 1, 42, -100 |
| `BIGINT` | 큰 정수 | 매우 큰 숫자 |
| `SERIAL` | 자동 증가 정수 | 1, 2, 3, ... |
| `VARCHAR(n)` | 최대 n자 문자열 | 'hello' |
| `TEXT` | 길이 제한 없는 문자열 | 긴 글, 본문 |
| `BOOLEAN` | 참/거짓 | TRUE, FALSE |
| `TIMESTAMP` | 날짜와 시간 | 2026-02-16 14:30:00 |
| `DECIMAL(p,s)` | 소수점 숫자 | 99.99 |

### 주요 제약 조건

| 제약 조건 | 의미 | 용도 |
|----------|------|------|
| `PRIMARY KEY` | 고유 식별자 (중복 불가 + NULL 불가) | 각 행을 구분하는 ID |
| `NOT NULL` | NULL 값 불가 | 반드시 입력해야 하는 필드 |
| `UNIQUE` | 중복 값 불가 | 이메일, 사용자명 등 |
| `DEFAULT 값` | 입력하지 않으면 기본값 사용 | 생성일시, 기본 상태 |
| `CHECK(조건)` | 조건을 만족해야 함 | 나이 >= 0 등 |

### 테이블 삭제

```sql
DROP TABLE users;
```

> 주의: `DROP TABLE`은 테이블과 데이터를 **모두 삭제**합니다. 되돌릴 수 없습니다!

<details>
<summary><b>PRIMARY KEY와 SERIAL의 동작 원리 (원리)</b></summary>

### SERIAL의 정체

`SERIAL`은 사실 PostgreSQL이 제공하는 편의 문법입니다. 내부적으로는 이렇게 동작합니다:

```sql
-- SERIAL은 이것의 축약형:
CREATE SEQUENCE users_id_seq;

CREATE TABLE users (
    id INTEGER NOT NULL DEFAULT nextval('users_id_seq'),
    ...
);
```

PostgreSQL이 **시퀀스(sequence)**라는 자동 증가 숫자 생성기를 만들고, 새 행이 삽입될 때마다 `nextval()`로 다음 숫자를 가져옵니다.

### PRIMARY KEY의 역할

PRIMARY KEY는 두 가지를 동시에 보장합니다:

1. **유일성(UNIQUE)**: 같은 값이 두 번 들어올 수 없음
2. **NULL 불가(NOT NULL)**: 반드시 값이 있어야 함

또한 PRIMARY KEY로 지정된 컬럼에는 **인덱스(index)**가 자동으로 생성되어, 해당 컬럼으로 검색할 때 속도가 빠릅니다.

### 실무에서의 ID 전략

최근에는 `SERIAL` 대신 `UUID`를 사용하는 경우도 많습니다:

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ...
);
```

UUID는 전 세계적으로 유일한 값을 생성하므로, 분산 시스템에서 유용합니다. 하지만 학습 단계에서는 `SERIAL`이 이해하기 쉽습니다.

</details>

---

## 4. SQL 기초 - 데이터 조작 (CRUD)

데이터베이스의 기본 동작 4가지를 **CRUD**라고 합니다:

| CRUD | SQL | 의미 |
|------|-----|------|
| **C**reate | `INSERT` | 데이터 추가 |
| **R**ead | `SELECT` | 데이터 조회 |
| **U**pdate | `UPDATE` | 데이터 수정 |
| **D**elete | `DELETE` | 데이터 삭제 |

### INSERT - 데이터 추가

```sql
-- 한 건 추가
INSERT INTO users (name, email, age) VALUES ('홍길동', 'hong@mail.com', 20);

-- 여러 건 추가
INSERT INTO users (name, email, age) VALUES
    ('김철수', 'kim@mail.com', 25),
    ('이영희', 'lee@mail.com', 22),
    ('박민수', 'park@mail.com', 30);
```

> `id`와 `created_at`은 넣지 않아도 됩니다. `SERIAL`은 자동 증가하고, `DEFAULT NOW()`는 현재 시각을 넣어줍니다.

### SELECT - 데이터 조회

```sql
-- 모든 데이터 조회
SELECT * FROM users;

-- 특정 컬럼만 조회
SELECT name, email FROM users;

-- 조건으로 필터링
SELECT * FROM users WHERE age > 18;

-- 정렬
SELECT * FROM users ORDER BY created_at DESC;

-- 개수 제한
SELECT * FROM users ORDER BY created_at DESC LIMIT 10;

-- 조합: 20세 이상 사용자를 이름순으로 5명만
SELECT name, age FROM users
WHERE age >= 20
ORDER BY name ASC
LIMIT 5;
```

| 키워드 | 의미 | 예시 |
|--------|------|------|
| `*` | 모든 컬럼 | `SELECT * FROM users` |
| `WHERE` | 조건 | `WHERE age > 18` |
| `ORDER BY` | 정렬 | `ORDER BY name ASC` (오름차순) |
| `DESC` | 내림차순 | `ORDER BY created_at DESC` |
| `ASC` | 오름차순 (기본값) | `ORDER BY name ASC` |
| `LIMIT` | 최대 개수 | `LIMIT 10` |

### UPDATE - 데이터 수정

```sql
-- id가 1인 사용자의 나이를 21로 변경
UPDATE users SET age = 21 WHERE id = 1;

-- 여러 컬럼 동시 수정
UPDATE users SET name = '홍길동2', age = 22 WHERE id = 1;
```

> **주의**: `WHERE` 없이 `UPDATE`를 실행하면 **모든 행**이 수정됩니다! 항상 `WHERE`를 확인하세요.

### DELETE - 데이터 삭제

```sql
-- id가 1인 사용자 삭제
DELETE FROM users WHERE id = 1;

-- 조건에 맞는 여러 행 삭제
DELETE FROM users WHERE age < 18;
```

> **주의**: `WHERE` 없이 `DELETE`를 실행하면 **모든 행**이 삭제됩니다! `UPDATE`와 마찬가지로 항상 `WHERE`를 확인하세요.

### 건수 확인 (COUNT)

```sql
-- 전체 사용자 수
SELECT COUNT(*) FROM users;

-- 조건에 맞는 사용자 수
SELECT COUNT(*) FROM users WHERE age >= 20;
```

---

## 5. WHERE 조건 심화

`WHERE`절은 데이터를 필터링하는 핵심입니다. 다양한 조건을 조합할 수 있습니다.

### 비교 연산자

```sql
SELECT * FROM users WHERE age = 20;      -- 같음
SELECT * FROM users WHERE age != 20;     -- 같지 않음
SELECT * FROM users WHERE age < 20;      -- 미만
SELECT * FROM users WHERE age > 20;      -- 초과
SELECT * FROM users WHERE age <= 20;     -- 이하
SELECT * FROM users WHERE age >= 20;     -- 이상
```

### 논리 연산자

```sql
-- AND: 두 조건 모두 만족
SELECT * FROM users WHERE age >= 20 AND age <= 30;

-- OR: 하나라도 만족
SELECT * FROM users WHERE name = '홍길동' OR name = '김철수';

-- NOT: 조건 부정
SELECT * FROM users WHERE NOT age = 20;
```

### 패턴 매칭 (LIKE)

```sql
-- '김'으로 시작하는 이름
SELECT * FROM users WHERE name LIKE '김%';

-- 'mail.com'으로 끝나는 이메일
SELECT * FROM users WHERE email LIKE '%mail.com';

-- '길'이 포함된 이름
SELECT * FROM users WHERE name LIKE '%길%';
```

| 패턴 | 의미 |
|------|------|
| `%` | 0개 이상의 아무 문자 |
| `_` | 정확히 1개의 아무 문자 |

### 범위와 목록

```sql
-- BETWEEN: 범위 (양쪽 포함)
SELECT * FROM users WHERE age BETWEEN 20 AND 30;

-- IN: 목록 중 하나
SELECT * FROM users WHERE name IN ('홍길동', '김철수', '이영희');
```

### NULL 처리

```sql
-- NULL인 행 찾기
SELECT * FROM users WHERE age IS NULL;

-- NULL이 아닌 행 찾기
SELECT * FROM users WHERE age IS NOT NULL;
```

> `age = NULL`은 동작하지 않습니다! NULL 비교는 반드시 `IS NULL` 또는 `IS NOT NULL`을 사용해야 합니다.

<details>
<summary><b>NULL이 특별한 이유 (원리)</b></summary>

### NULL은 "값이 없음"

NULL은 0도 아니고, 빈 문자열도 아닙니다. **"값 자체가 존재하지 않음"**을 의미합니다.

```sql
-- 이 세 가지는 모두 다릅니다:
age = 0       -- 나이가 0세
age = ''      -- (문법 에러, INTEGER에는 문자열을 넣을 수 없음)
age IS NULL   -- 나이를 아직 입력하지 않음
```

### NULL의 연산 특성

NULL과의 모든 연산 결과는 NULL입니다:

```sql
SELECT NULL = NULL;     -- NULL (TRUE가 아님!)
SELECT NULL != NULL;    -- NULL (TRUE가 아님!)
SELECT NULL + 1;        -- NULL
SELECT NULL > 0;        -- NULL
```

그래서 `WHERE age = NULL`은 항상 결과가 0건입니다. `= NULL`의 결과가 NULL(= 거짓도 참도 아님)이기 때문입니다.

이것이 `IS NULL`이라는 별도 문법이 필요한 이유입니다.

### Rust와의 비교

SQL의 NULL은 Rust의 `Option<T>`과 비슷합니다:

```
SQL NULL    ↔ Rust None
SQL 값 있음  ↔ Rust Some(값)
```

나중에 SQLx를 사용할 때, NULL 가능한 컬럼은 Rust에서 `Option<T>`으로 매핑됩니다.

</details>

---

## 6. SQLx 소개 (다음 장 미리보기)

지금까지 SQL을 직접 실행했습니다. 다음 장에서는 **Rust 코드 안에서** SQL을 실행하는 방법을 배웁니다.

### SQLx란?

SQLx는 Rust에서 데이터베이스에 접속하는 라이브러리입니다.

```toml
# Cargo.toml
[dependencies]
sqlx = { version = "0.8", features = ["runtime-tokio", "postgres"] }
tokio = { version = "1", features = ["full"] }
```

### 맛보기 코드

```rust
use sqlx::postgres::PgPoolOptions;

#[tokio::main]
async fn main() -> Result<(), sqlx::Error> {
    // DB 연결
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect("postgres://postgres:password@localhost/mydb")
        .await?;

    // 쿼리 실행
    let users = sqlx::query!("SELECT id, name, email FROM users")
        .fetch_all(&pool)
        .await?;

    for user in users {
        println!("{}: {} ({})", user.id, user.name, user.email);
    }

    Ok(())
}
```

### SQLx의 특징

| 특징 | 설명 |
|------|------|
| **컴파일 타임 쿼리 검증** | SQL 문법 오류를 컴파일할 때 잡아줌 |
| **비동기 지원** | Tokio와 완벽 호환 |
| **타입 안전** | 쿼리 결과를 Rust 타입으로 자동 매핑 |
| **마이그레이션** | 테이블 생성/변경을 코드로 관리 |

> 컴파일 타임에 SQL을 검증한다는 것은, 잘못된 SQL을 작성하면 **코드를 실행하기도 전에** 에러를 알려준다는 뜻입니다. Rust답죠!

<details>
<summary><b>ORM vs 쿼리 빌더 vs 직접 SQL (원리)</b></summary>

### 세 가지 접근 방식

데이터베이스를 코드에서 사용하는 방법은 크게 3가지입니다:

**1. ORM (Object-Relational Mapping)**

코드의 구조체와 DB 테이블을 자동으로 매핑합니다. SQL을 직접 작성하지 않습니다.

```rust
// Diesel (Rust ORM) 예시
let users = users::table
    .filter(users::age.gt(18))
    .load::<User>(&conn)?;
```

장점: SQL을 몰라도 됨, 타입 안전
단점: 복잡한 쿼리가 어려움, 학습 곡선이 큼

**2. 쿼리 빌더**

SQL을 프로그래밍 방식으로 조립합니다.

```rust
// 쿼리 빌더 예시 (가상 코드)
let query = Query::select()
    .from("users")
    .where_("age", ">", 18)
    .build();
```

장점: SQL 지식 활용 가능, 동적 쿼리 편리
단점: SQL과 코드 사이의 중간 단계

**3. 직접 SQL (SQLx 방식)**

SQL을 직접 작성하고, 결과를 Rust 타입으로 매핑합니다.

```rust
// SQLx 예시
let users = sqlx::query_as!(User, "SELECT * FROM users WHERE age > $1", 18)
    .fetch_all(&pool)
    .await?;
```

장점: SQL을 그대로 사용, 컴파일 타임 검증, 유연함
단점: SQL을 알아야 함

### SQLx를 선택한 이유

이 학습지에서 SQLx를 선택한 이유:

1. **SQL을 배워두면 어디서든 쓸 수 있음** - 언어, 프레임워크가 바뀌어도 SQL은 동일
2. **컴파일 타임 검증** - ORM 수준의 안전성 + SQL의 유연성
3. **비동기 네이티브** - Axum + Tokio 조합에 적합
4. **학습 곡선이 낮음** - SQL만 알면 바로 사용 가능

</details>

---

## 7. 실습

### 실습 1: pgAdmin 또는 psql에서 테이블 만들기

PostgreSQL에 접속해서 아래 SQL을 실행하세요.

```sql
-- 1. 데이터베이스 생성 (psql에서만 필요, pgAdmin에서는 GUI로 생성 가능)
CREATE DATABASE practice;

-- 2. users 테이블 생성
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    age INTEGER CHECK(age >= 0),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 3. 테이블 구조 확인 (psql에서)
\d users
```

pgAdmin을 사용한다면:
1. Databases 우클릭 > Create > Database > 이름: `practice`
2. practice DB의 Query Tool 열기
3. `CREATE TABLE` SQL 실행
4. 왼쪽 트리에서 Tables > users 확인

<details>
<summary><b>실행 결과 확인</b></summary>

`\d users` 실행 시 출력:

```
                                      Table "public.users"
   Column   |            Type             | Collation | Nullable |              Default
------------+-----------------------------+-----------+----------+-----------------------------------
 id         | integer                     |           | not null | nextval('users_id_seq'::regclass)
 name       | character varying(100)      |           | not null |
 email      | character varying(255)      |           | not null |
 age        | integer                     |           |          |
 created_at | timestamp without time zone |           |          | now()
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
Check constraints:
    "users_age_check" CHECK (age >= 0)
```

**포인트**: `SERIAL`이 내부적으로 `nextval()` 시퀀스로 변환된 것, `UNIQUE`와 `PRIMARY KEY`가 인덱스로 생성된 것을 확인할 수 있습니다.

</details>

### 실습 2: CRUD SQL문 직접 실행해보기

실습 1에서 만든 `users` 테이블에 CRUD를 실행하세요.

```sql
-- 1. CREATE: 데이터 추가
INSERT INTO users (name, email, age) VALUES ('홍길동', 'hong@mail.com', 20);
INSERT INTO users (name, email, age) VALUES ('김철수', 'kim@mail.com', 25);
INSERT INTO users (name, email, age) VALUES ('이영희', 'lee@mail.com', 22);
INSERT INTO users (name, email, age) VALUES ('박민수', 'park@mail.com', 30);
INSERT INTO users (name, email, age) VALUES ('정수진', 'jung@mail.com', 19);

-- 2. READ: 다양한 조건으로 조회
SELECT * FROM users;                                -- 전체 조회
SELECT name, email FROM users WHERE age >= 20;      -- 20세 이상
SELECT * FROM users ORDER BY age DESC;              -- 나이 내림차순
SELECT * FROM users WHERE name LIKE '김%';          -- '김'으로 시작
SELECT COUNT(*) FROM users WHERE age >= 20;         -- 20세 이상 몇 명?

-- 3. UPDATE: 데이터 수정
UPDATE users SET age = 21 WHERE name = '홍길동';
SELECT * FROM users WHERE name = '홍길동';          -- 변경 확인

-- 4. DELETE: 데이터 삭제
DELETE FROM users WHERE name = '박민수';
SELECT * FROM users;                                -- 삭제 확인
```

<details>
<summary><b>실행 결과 확인</b></summary>

전체 조회 결과 (DELETE 후):

```
 id |  name  |     email      | age |         created_at
----+--------+----------------+-----+----------------------------
  1 | 홍길동 | hong@mail.com  |  21 | 2026-02-16 14:30:00.000000
  2 | 김철수 | kim@mail.com   |  25 | 2026-02-16 14:30:00.000000
  3 | 이영희 | lee@mail.com   |  22 | 2026-02-16 14:30:00.000000
  5 | 정수진 | jung@mail.com  |  19 | 2026-02-16 14:30:00.000000
```

**포인트**:
- `id = 4` (박민수)가 삭제된 후, 다음 INSERT의 id는 6이 됩니다 (4를 재사용하지 않음)
- 홍길동의 age가 20에서 21로 변경되었습니다
- `created_at`은 INSERT 시점의 시각이 자동으로 들어갔습니다

</details>

### 실습 3: 게시판 테이블 설계하기

게시판에 필요한 `posts`와 `comments` 테이블을 설계하고 생성하세요.

요구사항:
- 게시글(`posts`): 제목, 본문, 작성자(users 참조), 작성일
- 댓글(`comments`): 내용, 작성자(users 참조), 게시글(posts 참조), 작성일

```sql
-- posts 테이블
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    body TEXT NOT NULL,
    user_id INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW()
);

-- comments 테이블
CREATE TABLE comments (
    id SERIAL PRIMARY KEY,
    content TEXT NOT NULL,
    user_id INTEGER NOT NULL REFERENCES users(id),
    post_id INTEGER NOT NULL REFERENCES posts(id),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 테스트 데이터 추가
INSERT INTO posts (title, body, user_id) VALUES
    ('첫 번째 글', '안녕하세요! 첫 글입니다.', 1),
    ('Rust 공부', 'Rust를 공부하고 있습니다.', 2);

INSERT INTO comments (content, user_id, post_id) VALUES
    ('좋은 글이네요!', 2, 1),
    ('화이팅!', 3, 1),
    ('저도 공부 중입니다.', 1, 2);

-- 게시글과 작성자 이름 함께 조회
SELECT posts.title, users.name AS author, posts.created_at
FROM posts
JOIN users ON posts.user_id = users.id;

-- 게시글별 댓글 수 조회
SELECT posts.title, COUNT(comments.id) AS comment_count
FROM posts
LEFT JOIN comments ON posts.id = comments.post_id
GROUP BY posts.id, posts.title;
```

<details>
<summary><b>실행 결과 확인</b></summary>

게시글과 작성자 이름:

```
    title     | author | created_at
--------------+--------+----------------------------
 첫 번째 글   | 홍길동 | 2026-02-16 14:35:00.000000
 Rust 공부    | 김철수 | 2026-02-16 14:35:00.000000
```

게시글별 댓글 수:

```
    title     | comment_count
--------------+--------------
 첫 번째 글   |            2
 Rust 공부    |            1
```

**포인트**:
- `REFERENCES users(id)`는 **외래 키(Foreign Key)**입니다. `users` 테이블에 존재하는 `id`만 넣을 수 있습니다
- `JOIN`은 두 테이블을 연결해서 조회하는 문법입니다. 20장에서 더 자세히 다룹니다
- `LEFT JOIN`은 댓글이 0개인 게시글도 포함합니다

</details>

---

## 8. 확인 문제

### 문제 1

다음 SQL에서 잘못된 부분은?

```sql
INSERT INTO users (id, name, email) VALUES (1, '홍길동', 'hong@mail.com');
```

- (a) `id`를 직접 지정하면 안 된다
- (b) `age`를 빼먹어서 에러가 난다
- (c) `VALUES` 대신 `VALUE`를 써야 한다
- (d) 문법적으로 틀린 부분은 없다

<details>
<summary>정답 보기</summary>

**(d) 문법적으로 틀린 부분은 없다**

- `SERIAL`은 자동 증가이지만, 직접 `id`를 지정할 수도 있습니다 (비추천이지만 에러는 아님)
- `age`는 `NOT NULL` 제약 조건이 없으므로 생략하면 `NULL`이 들어갑니다
- `VALUES`가 맞는 키워드입니다

다만, 실무에서는 `SERIAL` 컬럼의 `id`를 직접 지정하는 것은 피하는 것이 좋습니다. 시퀀스 값과 충돌할 수 있기 때문입니다.

</details>

### 문제 2

20세 이상 30세 이하인 사용자를 이름 오름차순으로 조회하는 SQL을 작성하세요.

<details>
<summary>정답 보기</summary>

```sql
-- 방법 1: AND 사용
SELECT * FROM users WHERE age >= 20 AND age <= 30 ORDER BY name ASC;

-- 방법 2: BETWEEN 사용
SELECT * FROM users WHERE age BETWEEN 20 AND 30 ORDER BY name ASC;
```

`BETWEEN`은 양쪽 경계값을 **포함**합니다. `ORDER BY name ASC`에서 `ASC`는 기본값이므로 생략해도 동일합니다.

</details>

### 문제 3

다음 SQL의 실행 결과는?

```sql
SELECT * FROM users WHERE age = NULL;
```

- (a) age가 NULL인 모든 행이 조회된다
- (b) 에러가 발생한다
- (c) 결과가 0건이다
- (d) 전체 행이 조회된다

<details>
<summary>정답 보기</summary>

**(c) 결과가 0건이다**

NULL과의 비교 연산(`=`, `!=`, `<`, `>` 등)은 항상 NULL을 반환합니다. NULL은 참(TRUE)이 아니므로 어떤 행도 조건을 만족하지 않습니다.

NULL을 찾으려면 `IS NULL`을 사용해야 합니다:

```sql
SELECT * FROM users WHERE age IS NULL;
```

</details>

### 문제 4

`VARCHAR(100)`과 `TEXT`의 차이점은?

<details>
<summary>정답 보기</summary>

- **`VARCHAR(100)`**: 최대 **100자**까지 저장 가능. 길이 제한이 있어 데이터 무결성을 보장
- **`TEXT`**: **길이 제한 없이** 문자열 저장 가능

사용 가이드:
- 이름, 이메일 등 **길이가 정해진** 데이터 -> `VARCHAR(n)`
- 게시글 본문, 설명 등 **길이를 예측할 수 없는** 데이터 -> `TEXT`

PostgreSQL에서는 내부적으로 `VARCHAR`과 `TEXT`의 성능 차이가 거의 없습니다. `VARCHAR(n)`의 장점은 길이 제한을 통한 데이터 검증입니다.

</details>

### 문제 5

다음 테이블 정의에서 `REFERENCES users(id)`의 역할은?

```sql
CREATE TABLE posts (
    id SERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    user_id INTEGER NOT NULL REFERENCES users(id)
);
```

<details>
<summary>정답 보기</summary>

**외래 키(Foreign Key)** 제약 조건입니다.

`user_id`에 들어갈 수 있는 값을 **`users` 테이블의 `id` 컬럼에 존재하는 값**으로 제한합니다.

```sql
-- users 테이블에 id=1인 사용자가 있다면:
INSERT INTO posts (title, user_id) VALUES ('글', 1);    -- 성공

-- users 테이블에 id=999인 사용자가 없다면:
INSERT INTO posts (title, user_id) VALUES ('글', 999);  -- 에러!
```

이를 통해 **데이터 무결성**을 보장합니다. "존재하지 않는 사용자가 작성한 게시글"이 생기는 것을 방지합니다.

</details>

---

## 9. 19장 정리

| 배운 것 | 핵심 |
|---------|------|
| 데이터베이스 | 데이터를 체계적으로 저장하는 시스템. 테이블(표) 형태 |
| PostgreSQL | 무료, 강력, 웹 개발에서 인기 있는 관계형 DB |
| `CREATE TABLE` | 테이블 생성. 컬럼, 타입, 제약 조건 지정 |
| 데이터 타입 | `INTEGER`, `VARCHAR`, `TEXT`, `BOOLEAN`, `TIMESTAMP` 등 |
| 제약 조건 | `PRIMARY KEY`, `NOT NULL`, `UNIQUE`, `DEFAULT`, `REFERENCES` |
| `INSERT` | 데이터 추가 |
| `SELECT` | 데이터 조회. `WHERE`, `ORDER BY`, `LIMIT` 조합 |
| `UPDATE` | 데이터 수정. `WHERE` 필수! |
| `DELETE` | 데이터 삭제. `WHERE` 필수! |
| `WHERE` 조건 | 비교, 논리, `LIKE`, `BETWEEN`, `IN`, `IS NULL` |
| 외래 키 | `REFERENCES`로 테이블 간 관계 설정 |
| SQLx | Rust에서 DB를 사용하는 라이브러리. 컴파일 타임 검증 |

---

## 다음 장 예고

> **20장. SQLx로 DB 연동**에서는 Rust 코드 안에서 데이터베이스를 사용하는 방법을 배웁니다.
> 연결 설정, CRUD 쿼리 실행, 마이그레이션, 커넥션 풀, 트랜잭션 처리까지 다룹니다!
