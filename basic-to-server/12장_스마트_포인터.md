# 12장. 스마트 포인터

> **목표**: 스마트 포인터의 종류와 용도를 이해하고, 적절히 사용할 수 있다.
> 💡 당장 외울 필요 없어요! "이런 게 있구나"를 알고, 필요할 때 찾아 쓰면 됩니다.

---

## 1. 스마트 포인터란?

**포인터**는 메모리 주소를 담고 있는 변수입니다. Rust에서 가장 흔한 포인터는 `&`(참조)입니다.

**스마트 포인터**는 포인터에 **추가 기능**(메타데이터, 자동 정리 등)이 붙은 것입니다.

```
일반 참조(&T)  = 메모지    → 데이터가 어디 있는지만 알려줌
스마트 포인터    = 스마트 메모지 → 데이터 위치 + 자동 정리 + 추가 정보
```

### 사실 이미 써봤습니다

```rust
fn main() {
    let s = String::from("안녕");     // String은 스마트 포인터!
    let v = vec![1, 2, 3];           // Vec<T>도 스마트 포인터!
}
```

`String`은 힙에 저장된 문자열 데이터를 가리키면서, 길이와 용량 정보도 함께 관리합니다. `Vec<T>`도 마찬가지입니다. 둘 다 스코프를 벗어나면 힙 메모리를 **자동으로 정리**합니다.

### 이 장에서 배울 스마트 포인터

| 스마트 포인터 | 한줄 요약 |
|-------------|----------|
| `Box<T>` | 힙에 데이터 저장 |
| `Rc<T>` | 여러 소유자 (단일 스레드) |
| `Arc<T>` | 여러 소유자 (멀티 스레드) |
| `RefCell<T>` | 불변 참조로 내부 값 변경 |

---

## 2. Box\<T> - 힙에 데이터 저장

`Box<T>`는 데이터를 **힙(heap)**에 저장하는 가장 단순한 스마트 포인터입니다.

### 기본 사용법

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b); // b = 5 (자동 역참조)
}
```

`Box::new(값)`으로 힙에 값을 저장합니다. 사용할 때는 일반 변수처럼 쓰면 됩니다. Rust가 **자동으로 역참조(Deref)**해줍니다.

### 언제 쓰나?

**1) 크기가 큰 데이터를 이동할 때**

```rust
fn main() {
    // 큰 배열을 Box로 힙에 저장
    let big_data = Box::new([0u8; 1_000_000]); // 1MB 데이터
    let moved = big_data; // 포인터만 이동 (빠름!)
    println!("길이: {}", moved.len());
}
```

스택에 큰 데이터를 두면 복사 비용이 큽니다. `Box`로 힙에 두면 포인터(8바이트)만 이동하면 됩니다.

**2) 크기를 모르는 타입을 사용할 때**

컴파일러가 크기를 알 수 없는 타입은 스택에 놓을 수 없습니다. `Box`로 감싸면 해결됩니다.

```rust
// 트레이트 객체: 크기를 알 수 없음
fn get_greeting(korean: bool) -> Box<dyn std::fmt::Display> {
    if korean {
        return Box::new(String::from("안녕하세요"));
    }

    Box::new(String::from("Hello"))
}

fn main() {
    let msg = get_greeting(true);
    println!("{}", msg);
}
```

<details>
<summary><b>🔍 재귀적 타입과 Box (원리)</b></summary>

### 재귀적 타입 문제

재귀적 타입은 자기 자신을 포함하는 타입입니다. 대표적인 예가 **연결 리스트**입니다.

```rust
// 이 코드는 컴파일되지 않습니다!
enum List {
    Cons(i32, List),  // List 안에 List가 또 있음
    Nil,
}
```

컴파일러는 `List`의 크기를 계산하려 합니다:

```
List 크기 = i32 크기 + List 크기
          = 4바이트 + (i32 크기 + List 크기)
          = 4바이트 + 4바이트 + (i32 크기 + List 크기)
          = ... 무한!
```

크기가 무한대가 되어 컴파일할 수 없습니다.

### Box로 해결

```rust
enum List {
    Cons(i32, Box<List>),  // Box는 포인터라 크기가 고정(8바이트)
    Nil,
}

fn main() {
    let list = List::Cons(1,
        Box::new(List::Cons(2,
            Box::new(List::Cons(3,
                Box::new(List::Nil)
            ))
        ))
    );
    // list: 1 -> 2 -> 3 -> Nil

    print_list(&list);
}

fn print_list(list: &List) {
    match list {
        List::Cons(val, next) => {
            print!("{} -> ", val);
            print_list(next);
        }
        List::Nil => println!("Nil"),
    }
}
```

실행 결과:
```
1 -> 2 -> 3 -> Nil
```

`Box<List>`는 항상 포인터 크기(8바이트)이므로, 컴파일러가 `List`의 크기를 계산할 수 있습니다:

```
List 크기 = i32 크기 + Box<List> 크기
          = 4바이트 + 8바이트
          = 12바이트 (고정!)
```

</details>

---

## 3. Rc\<T> - 참조 카운팅

Rust의 소유권 규칙에서는 **하나의 값에 소유자가 하나**입니다. 하지만 현실에서는 **여러 곳에서 같은 데이터를 공유**해야 할 때가 있습니다.

`Rc<T>`(Reference Counting)는 **참조 카운팅**으로 여러 소유자를 허용합니다.

### 기본 사용법

```rust
use std::rc::Rc;

fn main() {
    let data = Rc::new(String::from("공유 데이터"));

    let a = Rc::clone(&data);  // 참조 카운트: 2
    let b = Rc::clone(&data);  // 참조 카운트: 3

    println!("a = {}", a);
    println!("b = {}", b);
    println!("참조 카운트: {}", Rc::strong_count(&data)); // 3
}
// 여기서 data, a, b가 모두 드롭 → 카운트가 0 → 메모리 해제
```

실행 결과:
```
a = 공유 데이터
b = 공유 데이터
참조 카운트: 3
```

### 핵심 규칙

- `Rc::clone(&rc)`은 **데이터를 복사하지 않습니다**. 참조 카운트만 1 증가합니다.
- 참조 카운트가 **0이 되면** 자동으로 메모리가 해제됩니다.
- `Rc<T>`는 **읽기 전용**입니다. 내부 값을 변경할 수 없습니다.
- **단일 스레드**에서만 사용할 수 있습니다.

### 실전 예시: 여러 리스트가 같은 꼬리를 공유

```rust
use std::rc::Rc;

enum List {
    Cons(i32, Rc<List>),
    Nil,
}

fn main() {
    //        a: 5 -> |
    //                 +-> shared: 10 -> 20 -> Nil
    //        b: 3 -> |

    let shared = Rc::new(List::Cons(10,
        Rc::new(List::Cons(20,
            Rc::new(List::Nil)
        ))
    ));

    let a = List::Cons(5, Rc::clone(&shared));
    let b = List::Cons(3, Rc::clone(&shared));

    println!("shared 참조 카운트: {}", Rc::strong_count(&shared)); // 3
}
```

`shared` 부분을 `a`와 `b`가 함께 소유합니다. `Box`였다면 소유권 이동 때문에 이렇게 쓸 수 없습니다.

<details>
<summary><b>🔍 참조 카운팅이 동작하는 원리</b></summary>

### 참조 카운팅의 원리

`Rc<T>`는 내부적으로 **카운터**를 함께 저장합니다:

```
┌──────────────────────┐
│  Rc 내부 구조         │
├──────────────────────┤
│  strong_count: 3     │  ← 현재 몇 개의 Rc가 이 데이터를 가리키는지
│  data: "공유 데이터"   │  ← 실제 데이터
└──────────────────────┘
      ↑     ↑     ↑
     data    a     b      ← 세 개의 Rc가 같은 곳을 가리킴
```

### 동작 흐름

```
1. Rc::new("데이터")     → count = 1
2. Rc::clone(&data)     → count = 2 (데이터 복사 없음!)
3. Rc::clone(&data)     → count = 3
4. b가 스코프를 벗어남    → count = 2
5. a가 스코프를 벗어남    → count = 1
6. data가 스코프를 벗어남  → count = 0 → 메모리 해제!
```

### 왜 단일 스레드에서만?

카운터를 증가/감소하는 연산이 **원자적(atomic)**이지 않습니다. 두 스레드가 동시에 카운터를 바꾸면 값이 꼬일 수 있습니다. 멀티 스레드에서는 `Arc<T>`를 사용해야 합니다.

### Rc::clone vs .clone()

```rust
// Rc::clone → 참조 카운트만 증가 (빠름, O(1))
let a = Rc::clone(&data);

// data.clone()도 같은 동작이지만,
// 코드를 읽을 때 "진짜 깊은 복사"로 오해할 수 있어서
// Rc::clone(&data) 형태를 권장합니다.
```

</details>

---

## 4. Arc\<T> - 스레드 안전한 참조 카운팅

`Arc<T>`(Atomic Reference Counting)는 `Rc<T>`의 **멀티 스레드 버전**입니다.

### Rc vs Arc

```rust
// 단일 스레드: Rc 사용
use std::rc::Rc;
let data = Rc::new(5);

// 멀티 스레드: Arc 사용
use std::sync::Arc;
let data = Arc::new(5);
```

사용법은 `Rc`와 거의 동일합니다. 차이는 **스레드 안전성**뿐입니다.

### 기본 사용법

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3]);

    let mut handles = vec![];

    for i in 0..3 {
        let data_clone = Arc::clone(&data);

        let handle = thread::spawn(move || {
            println!("스레드 {}: {:?}", i, data_clone);
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

실행 결과 (순서는 다를 수 있음):
```
스레드 0: [1, 2, 3]
스레드 1: [1, 2, 3]
스레드 2: [1, 2, 3]
```

### Rc 대신 Arc를 쓰면 안 되나?

`Arc`는 원자적 연산을 사용하기 때문에 `Rc`보다 **약간 느립니다**. 단일 스레드에서는 불필요한 비용이므로 `Rc`를 쓰세요.

| | `Rc<T>` | `Arc<T>` |
|---|---|---|
| 스레드 안전 | 아니오 | **예** |
| 성능 | 빠름 | 약간 느림 |
| 사용처 | 단일 스레드 | 멀티 스레드 |

> `Arc<T>`는 13장(동시성 프로그래밍)에서 더 자세히 다룹니다.
> 웹서버에서 여러 요청 핸들러가 **설정값이나 DB 커넥션 풀**을 공유할 때 자주 사용합니다.

---

## 5. RefCell\<T> - 내부 가변성

Rust의 빌림 규칙을 기억하시나요?

```
규칙: 불변 참조(&T)가 있으면, 가변 참조(&mut T)를 동시에 가질 수 없다.
```

`RefCell<T>`는 이 규칙을 **런타임에 검사**하여, 불변 참조를 통해서도 내부 값을 변경할 수 있게 합니다.

### 기본 사용법

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    // borrow(): 불변 참조 (컴파일 타임의 &T와 비슷)
    println!("값: {}", data.borrow());

    // borrow_mut(): 가변 참조 (컴파일 타임의 &mut T와 비슷)
    *data.borrow_mut() += 10;

    println!("변경 후: {}", data.borrow()); // 15
}
```

실행 결과:
```
값: 5
변경 후: 15
```

### 빌림 규칙은 여전히 적용됩니다

`RefCell`은 빌림 규칙을 없애는 게 아니라, 검사 시점을 **컴파일 타임에서 런타임으로 미룹니다**. 규칙을 어기면 **런타임에 패닉**이 발생합니다:

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    let a = data.borrow();      // 불변 참조 1개
    let b = data.borrow_mut();  // 가변 참조 시도 → 패닉!

    // 런타임 에러:
    // thread 'main' panicked at 'already borrowed: BorrowMutError'
}
```

### Rc\<RefCell\<T>> 조합 패턴

`Rc<T>`는 읽기 전용이라 값을 변경할 수 없었습니다. `RefCell<T>`을 조합하면 **여러 소유자가 값을 변경**할 수 있습니다:

```rust
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let shared_value = Rc::new(RefCell::new(0));

    let a = Rc::clone(&shared_value);
    let b = Rc::clone(&shared_value);

    // a를 통해 값 변경
    *a.borrow_mut() += 10;

    // b를 통해 값 변경
    *b.borrow_mut() += 20;

    println!("최종 값: {}", shared_value.borrow()); // 30
}
```

실행 결과:
```
최종 값: 30
```

이 패턴은 **단일 스레드에서 여러 곳이 같은 가변 데이터를 공유**할 때 유용합니다.

<details>
<summary><b>🔍 컴파일 타임 검사 vs 런타임 검사 트레이드오프 (원리)</b></summary>

### 두 가지 검사 방식 비교

**컴파일 타임 검사 (기본 &T, &mut T)**
- 잘못된 코드를 **컴파일 단계에서** 잡아줌
- 런타임 비용 없음 (검사가 이미 끝남)
- 규칙이 엄격해서 일부 안전한 패턴도 거부됨

**런타임 검사 (RefCell\<T>)**
- 빌림 규칙을 **실행 중에** 검사
- 약간의 런타임 비용 (매번 카운터 확인)
- 규칙을 어기면 패닉 발생 (프로그램 종료)
- 컴파일 타임 검사가 너무 엄격할 때 대안

### 내부 동작

```
RefCell 내부 상태:
┌──────────────────────┐
│  borrow_count: 0     │  ← 현재 불변 참조 개수
│  borrow_mut: false   │  ← 가변 참조 존재 여부
│  data: T             │  ← 실제 데이터
└──────────────────────┘

borrow() 호출 시:
  borrow_mut가 false이면 → borrow_count += 1, 참조 반환
  borrow_mut가 true이면  → 패닉!

borrow_mut() 호출 시:
  borrow_count가 0이고 borrow_mut가 false이면 → borrow_mut = true, 가변 참조 반환
  그 외 → 패닉!
```

### 언제 RefCell을 쓰나?

```
1. 컴파일러가 너무 엄격해서 안전한 코드도 거부할 때
2. 불변 인터페이스 뒤에서 내부 상태를 변경해야 할 때
   (예: 캐시, 카운터, 로깅)
3. 테스트에서 모의 객체(mock)를 만들 때
```

### 주의사항

```rust
// 이렇게 하면 안 됩니다 (런타임 패닉)
let data = RefCell::new(5);
let a = data.borrow();
let b = data.borrow();
let c = data.borrow_mut(); // 패닉! 불변 참조가 이미 존재

// borrow()의 결과를 빨리 드롭(해제)하세요
{
    let a = data.borrow();
    println!("{}", a);
} // a가 여기서 드롭됨
*data.borrow_mut() += 1; // 이제 가변 참조 가능
```

**정리**: RefCell은 "나는 이 코드가 안전하다는 걸 알고 있으니, 런타임에 검증해줘"라고 컴파일러에게 말하는 것입니다. 남용하면 런타임 패닉의 위험이 커지므로, 꼭 필요한 경우에만 사용하세요.

</details>

---

## 6. 멀티 스레드에서 값 변경: Arc\<Mutex\<T>>

멀티 스레드에서 공유 데이터를 변경하려면 `Arc<Mutex<T>>`를 사용합니다:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..5 {
        let counter = Arc::clone(&counter);

        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("최종 카운터: {}", *counter.lock().unwrap()); // 5
}
```

실행 결과:
```
최종 카운터: 5
```

| 상황 | 조합 |
|------|------|
| 단일 스레드 + 여러 소유자 + 읽기만 | `Rc<T>` |
| 단일 스레드 + 여러 소유자 + 값 변경 | `Rc<RefCell<T>>` |
| 멀티 스레드 + 여러 소유자 + 읽기만 | `Arc<T>` |
| 멀티 스레드 + 여러 소유자 + 값 변경 | `Arc<Mutex<T>>` |

> `Mutex`는 13장(동시성 프로그래밍)에서 자세히 다룹니다. 지금은 "멀티 스레드에서 값을 안전하게 바꾸는 도구"라고 알아두세요.

---

## 7. 언제 뭘 쓸까? (선택 가이드)

스마트 포인터를 고를 때 이 순서로 질문하세요:

```
소유자가 하나인가?
├─ 예 → 힙에 저장해야 하나?
│       ├─ 예 → Box<T>
│       └─ 아니오 → 그냥 일반 변수 사용
│
└─ 아니오 (여러 소유자) → 멀티 스레드인가?
        ├─ 아니오 → 값을 변경해야 하나?
        │          ├─ 예 → Rc<RefCell<T>>
        │          └─ 아니오 → Rc<T>
        │
        └─ 예 → 값을 변경해야 하나?
                ├─ 예 → Arc<Mutex<T>>
                └─ 아니오 → Arc<T>
```

### 정리 표

| 상황 | 사용할 것 | 예시 |
|------|----------|------|
| 힙에 저장하고 싶다 | `Box<T>` | 재귀적 타입, 큰 데이터 |
| 여러 소유자 (단일 스레드) | `Rc<T>` | 그래프 구조, 공유 설정 |
| 여러 소유자 (멀티 스레드) | `Arc<T>` | 스레드 간 설정 공유 |
| 불변 참조로 값 변경 | `RefCell<T>` | 캐시, 내부 카운터 |
| 멀티 스레드 + 값 변경 | `Arc<Mutex<T>>` | 공유 카운터, DB 풀 |

---

## 8. 실습

### 실습 1: Box로 재귀적 타입 만들기

이진 트리를 `Box`로 구현하세요. 각 노드는 값(i32)과 왼쪽/오른쪽 자식을 가집니다.

```rust
enum Tree {
    Node {
        value: i32,
        left: Box<Tree>,
        right: Box<Tree>,
    },
    Empty,
}

fn sum(tree: &Tree) -> i32 {
    match tree {
        Tree::Empty => 0,
        Tree::Node { value, left, right } => {
            value + sum(left) + sum(right)
        }
    }
}

fn main() {
    //       10
    //      /  \
    //     5    20
    //    / \   / \

    let tree = Tree::Node {
        value: 10,
        left: Box::new(Tree::Node {
            value: 5,
            left: Box::new(Tree::Empty),
            right: Box::new(Tree::Empty),
        }),
        right: Box::new(Tree::Node {
            value: 20,
            left: Box::new(Tree::Empty),
            right: Box::new(Tree::Empty),
        }),
    };

    println!("트리 합계: {}", sum(&tree)); // 35
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
트리 합계: 35
```

**포인트**: `Tree`는 자기 자신을 포함하는 재귀적 타입이므로 `Box`가 필요합니다. `Box::new(Tree::Empty)`는 빈 노드를 힙에 저장합니다.

</details>

### 실습 2: Rc로 공유 데이터 만들기

여러 팀원이 같은 프로젝트 이름을 공유하는 구조를 만드세요.

```rust
use std::rc::Rc;

struct Member {
    name: String,
    project: Rc<String>,
}

fn main() {
    let project = Rc::new(String::from("웹서버 프로젝트"));

    let alice = Member {
        name: String::from("Alice"),
        project: Rc::clone(&project),
    };

    let bob = Member {
        name: String::from("Bob"),
        project: Rc::clone(&project),
    };

    let charlie = Member {
        name: String::from("Charlie"),
        project: Rc::clone(&project),
    };

    println!("{}: {}", alice.name, alice.project);
    println!("{}: {}", bob.name, bob.project);
    println!("{}: {}", charlie.name, charlie.project);
    println!("프로젝트 참조 수: {}", Rc::strong_count(&project));
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
Alice: 웹서버 프로젝트
Bob: 웹서버 프로젝트
Charlie: 웹서버 프로젝트
프로젝트 참조 수: 4
```

**포인트**: `project` 본체(1) + alice(1) + bob(1) + charlie(1) = 참조 카운트 4입니다. `Rc::clone`은 데이터를 복사하지 않고 카운터만 증가시킵니다.

</details>

### 실습 3: Rc\<RefCell\<T>>로 공유 가변 데이터 만들기

여러 곳에서 공유하면서 값도 변경할 수 있는 점수판을 만드세요.

```rust
use std::cell::RefCell;
use std::rc::Rc;

fn add_score(scoreboard: &Rc<RefCell<Vec<i32>>>, score: i32) {
    if score < 0 {
        println!("음수 점수는 추가할 수 없습니다.");
        return;
    }

    scoreboard.borrow_mut().push(score);
}

fn total_score(scoreboard: &Rc<RefCell<Vec<i32>>>) -> i32 {
    scoreboard.borrow().iter().sum()
}

fn main() {
    let scoreboard = Rc::new(RefCell::new(Vec::new()));

    let player1_board = Rc::clone(&scoreboard);
    let player2_board = Rc::clone(&scoreboard);

    // player1이 점수 추가
    add_score(&player1_board, 100);
    add_score(&player1_board, 200);

    // player2가 점수 추가
    add_score(&player2_board, 150);

    // 전체 점수 확인
    println!("점수판: {:?}", scoreboard.borrow());
    println!("총점: {}", total_score(&scoreboard));
    println!("참조 카운트: {}", Rc::strong_count(&scoreboard));
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
점수판: [100, 200, 150]
총점: 450
참조 카운트: 3
```

**포인트**: `Rc`로 여러 소유자가 같은 데이터를 공유하고, `RefCell`로 불변 참조를 통해서도 내부 벡터를 변경할 수 있습니다. `borrow_mut()`으로 가변 참조를 얻고, `borrow()`로 불변 참조를 얻습니다.

</details>

---

## 9. 확인 문제

### 문제 1

아래 코드의 출력 결과는?

```rust
fn main() {
    let b = Box::new(42);
    let c = *b + 8;
    println!("{}", c);
}
```

<details>
<summary>정답 보기</summary>

**`50`**

`*b`는 `Box`를 역참조하여 내부 값 42를 꺼냅니다. 42 + 8 = 50입니다.

</details>

### 문제 2

`Rc<T>`에서 `Rc::clone()`을 호출하면 무슨 일이 일어나나요?

<details>
<summary>정답 보기</summary>

**참조 카운트가 1 증가합니다.** 데이터를 복사하지 않고, 같은 데이터를 가리키는 새로운 포인터가 생깁니다. 카운트가 0이 되면 메모리가 해제됩니다.

</details>

### 문제 3

`Rc<T>` 대신 `Arc<T>`를 사용해야 하는 상황은?

<details>
<summary>정답 보기</summary>

**멀티 스레드 환경에서 데이터를 공유해야 할 때** `Arc<T>`를 사용합니다. `Rc<T>`는 단일 스레드에서만 안전합니다. `Arc`는 원자적(atomic) 연산으로 참조 카운트를 관리하여 스레드 안전성을 보장합니다.

</details>

### 문제 4

아래 코드가 런타임에 패닉을 일으키는 이유는?

```rust
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(10);
    let a = data.borrow();
    let b = data.borrow_mut();
    println!("{} {}", a, b);
}
```

<details>
<summary>정답 보기</summary>

`a`가 `borrow()`로 불변 참조를 이미 가지고 있는 상태에서, `borrow_mut()`으로 가변 참조를 시도했기 때문입니다. **불변 참조가 존재하는 동안에는 가변 참조를 만들 수 없습니다.** 이것은 Rust의 빌림 규칙과 동일하며, `RefCell`은 이를 런타임에 검사합니다.

수정 방법:
```rust
let data = RefCell::new(10);
{
    let a = data.borrow();
    println!("{}", a);
} // a가 여기서 드롭됨
let b = data.borrow_mut(); // 이제 안전
```

</details>

### 문제 5

웹서버에서 여러 요청 핸들러 스레드가 **설정 데이터를 읽기만** 해야 한다면, 어떤 스마트 포인터를 사용하는 것이 적절한가요?

<details>
<summary>정답 보기</summary>

**`Arc<T>`**

멀티 스레드 환경이므로 `Rc`는 사용할 수 없고, `Arc`를 사용해야 합니다. 읽기만 하므로 `Mutex`는 불필요합니다. 만약 설정을 변경해야 한다면 `Arc<Mutex<T>>` 또는 `Arc<RwLock<T>>`를 사용합니다.

</details>

---

## 10. 12장 정리

| 배운 것 | 핵심 |
|---------|------|
| 스마트 포인터 | 포인터 + 추가 기능(자동 정리, 메타데이터) |
| `Box<T>` | 힙에 저장, 재귀적 타입에 필수 |
| `Rc<T>` | 참조 카운팅, 여러 소유자 (단일 스레드) |
| `Arc<T>` | `Rc`의 멀티 스레드 버전 (원자적 연산) |
| `RefCell<T>` | 런타임 빌림 검사, 내부 가변성 |
| `Rc<RefCell<T>>` | 여러 소유자 + 값 변경 (단일 스레드) |
| `Arc<Mutex<T>>` | 여러 소유자 + 값 변경 (멀티 스레드) |
| `Rc::clone()` | 데이터 복사 없이 카운트만 증가 |
| `borrow()` / `borrow_mut()` | RefCell의 불변/가변 참조 획득 |

---

## 다음 장 예고

> **13장. 동시성 프로그래밍**에서는 스레드를 생성하고, 스레드 간 데이터를 안전하게 주고받는 방법을 배웁니다.
> 이 장에서 배운 `Arc<T>`와 `Mutex`가 본격적으로 활용됩니다.
> 메시지 패싱(channel), 공유 상태(Mutex), Send/Sync 트레이트 등 Rust만의 안전한 동시성 모델을 다룹니다!
