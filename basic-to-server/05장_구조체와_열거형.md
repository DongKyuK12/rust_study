# 05장. 구조체와 열거형

> **목표**: 자신만의 데이터 타입을 만들어 데이터를 구조화할 수 있다.

---

## 1. 구조체 (struct)

여러 값을 하나로 묶어서 **의미 있는 데이터 덩어리**를 만드는 방법입니다.

### 구조체 정의

```rust
struct User {
    name: String,
    age: u32,
    active: bool,
}
```

`struct` 키워드로 정의합니다. 중괄호 안의 각 항목을 **필드**라고 부릅니다.

### 인스턴스 생성

```rust
fn main() {
    let user = User {
        name: String::from("홍길동"),
        age: 25,
        active: true,
    };
}
```

구조체 이름 뒤에 `{}` 안에서 모든 필드에 값을 넣어주면 됩니다. **하나라도 빠지면 에러**입니다.

### 필드 접근

```rust
fn main() {
    let user = User {
        name: String::from("홍길동"),
        age: 25,
        active: true,
    };

    println!("이름: {}", user.name);   // 이름: 홍길동
    println!("나이: {}", user.age);    // 나이: 25
    println!("활성: {}", user.active); // 활성: true
}
```

점(`.`)으로 필드에 접근합니다.

### 가변 인스턴스

필드 값을 바꾸려면 인스턴스 전체를 `mut`로 선언해야 합니다. **일부 필드만 mut로 만들 수 없습니다.**

```rust
fn main() {
    let mut user = User {
        name: String::from("홍길동"),
        age: 25,
        active: true,
    };

    user.age = 26;                          // ✅ 가능 (mut이니까)
    user.name = String::from("김철수");       // ✅ 다른 필드도 변경 가능

    println!("이름: {}, 나이: {}", user.name, user.age);
    // 이름: 김철수, 나이: 26
}
```

### 구조체 업데이트 문법 (..other)

기존 인스턴스에서 일부만 바꿔서 새 인스턴스를 만들 때 편리합니다.

```rust
fn main() {
    let user1 = User {
        name: String::from("홍길동"),
        age: 25,
        active: true,
    };

    // user1을 기반으로, age만 바꾼 새 인스턴스
    let user2 = User {
        age: 30,
        ..user1  // 나머지 필드는 user1에서 가져옴
    };

    println!("user2 나이: {}", user2.age); // user2 나이: 30
}
```

> **주의**: `..user1`에서 `String` 같은 소유권이 있는 필드가 이동(move)됩니다. 이동 후에는 `user1.name`을 쓸 수 없습니다. (04장 소유권 참고)

---

## 2. 메서드와 연관 함수 (impl)

구조체에 **동작(함수)**을 붙이는 방법입니다.

### impl 블록

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 여기에 메서드와 연관 함수를 정의
}
```

`impl 구조체이름 { }` 안에 함수를 작성합니다.

### &self로 메서드 정의

```rust
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn is_square(&self) -> bool {
        self.width == self.height
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 5 };

    println!("넓이: {}", rect.area());        // 넓이: 50
    println!("정사각형? {}", rect.is_square()); // 정사각형? false
}
```

- 첫 번째 매개변수가 `&self`이면 **메서드**입니다
- `&self`는 이 구조체 인스턴스를 빌려온다는 뜻입니다
- 호출할 때 `rect.area()`처럼 점(`.`)을 씁니다

### &mut self로 값 변경하는 메서드

```rust
impl Rectangle {
    fn double_width(&mut self) {
        self.width *= 2;
    }
}

fn main() {
    let mut rect = Rectangle { width: 10, height: 5 };
    println!("변경 전: {}", rect.width); // 변경 전: 10

    rect.double_width();
    println!("변경 후: {}", rect.width); // 변경 후: 20
}
```

필드를 수정하려면 `&mut self`를 씁니다. 당연히 인스턴스도 `mut`여야 합니다.

### 연관 함수 (Self::new() 패턴)

`self`가 없는 함수를 **연관 함수**라고 합니다. 주로 인스턴스를 생성하는 `new()`에 씁니다.

```rust
impl Rectangle {
    fn new(width: u32, height: u32) -> Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}

fn main() {
    let rect = Rectangle::new(10, 5);     // ::로 호출
    let sq = Rectangle::square(7);         // ::로 호출

    println!("넓이: {}", rect.area());     // 넓이: 50
    println!("정사각형 넓이: {}", sq.area()); // 정사각형 넓이: 49
}
```

- 연관 함수는 `::`로 호출합니다 (`Rectangle::new(...)`)
- `String::from("hello")`도 연관 함수입니다. 익숙하죠?

<details>
<summary><b>🔍 왜 impl을 따로 쓰나? (데이터와 행동의 분리)</b></summary>

### 데이터와 행동을 분리하는 이유

다른 언어(Java, C++)에서는 클래스 안에 데이터와 함수를 함께 씁니다:

```
// 다른 언어 스타일 (Rust는 이렇게 안 함)
class Rectangle {
    width: u32,
    height: u32,

    fn area() -> u32 { ... }  // 데이터와 함수가 섞여있음
}
```

Rust는 **데이터 정의**(`struct`)와 **행동 정의**(`impl`)를 분리합니다:

```rust
// 1단계: 데이터가 뭔지 정의
struct Rectangle {
    width: u32,
    height: u32,
}

// 2단계: 이 데이터로 뭘 할 수 있는지 정의
impl Rectangle {
    fn area(&self) -> u32 { ... }
}
```

이렇게 분리하면 좋은 점:
- **구조체의 모양만 보면** 어떤 데이터를 담는지 한눈에 파악
- **impl 블록을 여러 개** 작성 가능 (기능별로 나눌 수 있음)
- **트레이트**(09장)를 통해 외부에서 행동을 추가할 수 있음

```rust
// impl 블록을 나눠서 쓸 수도 있음
impl Rectangle {
    fn area(&self) -> u32 { self.width * self.height }
}

impl Rectangle {
    fn is_square(&self) -> bool { self.width == self.height }
}
```

지금은 "데이터 따로, 행동 따로"라는 점만 기억하면 됩니다.

</details>

---

## 3. 열거형 (enum)

**여러 가지 중 하나**를 표현하는 타입입니다.

### 기본 열거형

```rust
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

fn main() {
    let dir = Direction::Up;
}
```

`Direction`은 `Up`, `Down`, `Left`, `Right` 네 가지 중 하나만 될 수 있습니다.

### 데이터를 가진 열거형

열거형의 각 변형(variant)이 데이터를 가질 수 있습니다. 이것이 Rust 열거형의 강력한 점입니다.

```rust
enum Message {
    Quit,                          // 데이터 없음
    Text(String),                  // String 하나를 가짐
    Position { x: i32, y: i32 },   // 이름 있는 필드들을 가짐
    Color(u8, u8, u8),             // 여러 값을 가짐
}

fn main() {
    let msg1 = Message::Quit;
    let msg2 = Message::Text(String::from("안녕!"));
    let msg3 = Message::Position { x: 10, y: 20 };
    let msg4 = Message::Color(255, 0, 0);
}
```

하나의 `Message` 타입으로 완전히 다른 종류의 데이터를 표현할 수 있습니다.

### 열거형과 match

`match`를 사용하면 열거형의 **모든 경우**를 빠짐없이 처리할 수 있습니다.

```rust
fn process_direction(dir: Direction) {
    match dir {
        Direction::Up => println!("위로 이동"),
        Direction::Down => println!("아래로 이동"),
        Direction::Left => println!("왼쪽으로 이동"),
        Direction::Right => println!("오른쪽으로 이동"),
    }
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => {
            println!("종료합니다");
        }
        Message::Text(text) => {
            println!("메시지: {}", text);
        }
        Message::Position { x, y } => {
            println!("위치: ({}, {})", x, y);
        }
        Message::Color(r, g, b) => {
            println!("색상: ({}, {}, {})", r, g, b);
        }
    }
}

fn main() {
    process_direction(Direction::Up);               // 위로 이동
    process_message(Message::Text(String::from("안녕!"))); // 메시지: 안녕!
}
```

> **중요**: `match`는 **모든 변형을 처리해야** 합니다. 하나라도 빠지면 컴파일 에러가 납니다. 이 덕분에 "깜빡하고 빠뜨린 경우"가 사라집니다.

---

## 4. Option\<T>

### null이 없는 Rust

많은 언어에서 "값이 없음"을 `null`로 표현합니다. 하지만 `null`은 온갖 버그의 원인이 됩니다.

```
// 다른 언어 (위험!)
String name = null;
name.length();  // 💥 런타임 에러! (NullPointerException)
```

Rust에는 `null`이 없습니다. 대신 **`Option<T>`**를 씁니다.

### Some(값)과 None

`Option<T>`는 표준 라이브러리에 정의된 열거형입니다:

```rust
// 이렇게 생겼습니다 (직접 정의할 필요 없음, 이미 내장)
enum Option<T> {
    Some(T),   // 값이 있음
    None,      // 값이 없음
}
```

```rust
fn main() {
    let some_number: Option<i32> = Some(42);   // 값이 있음: 42
    let no_number: Option<i32> = None;          // 값이 없음

    println!("{:?}", some_number); // Some(42)
    println!("{:?}", no_number);   // None
}
```

### match로 Option 처리

`Option`은 **그냥 쓸 수 없습니다**. 반드시 값이 있는지 확인해야 합니다.

```rust
fn find_user(id: u32) -> Option<String> {
    if id == 1 {
        return Some(String::from("홍길동"));
    }
    None
}

fn main() {
    let result = find_user(1);

    match result {
        Some(name) => println!("찾았다: {}", name),
        None => println!("해당 유저가 없습니다"),
    }
    // 찾았다: 홍길동
}
```

### if let으로 간단히 처리

`Some`일 때만 관심 있고, `None`은 무시해도 될 때 `if let`이 편합니다.

```rust
fn main() {
    let some_value: Option<i32> = Some(42);

    // match로 쓰면
    match some_value {
        Some(v) => println!("값: {}", v),
        None => {}  // 아무것도 안 함 (쓸데없는 코드)
    }

    // if let으로 쓰면 (더 깔끔)
    if let Some(v) = some_value {
        println!("값: {}", v);
    }
}
```

### unwrap(), unwrap_or() 등 편의 메서드

```rust
fn main() {
    let a: Option<i32> = Some(42);
    let b: Option<i32> = None;

    // unwrap: 값이 있으면 꺼냄, None이면 패닉(프로그램 죽음)
    println!("{}", a.unwrap());        // 42
    // println!("{}", b.unwrap());     // 💥 패닉! 절대 None에 쓰지 마세요

    // unwrap_or: 값이 없으면 기본값 사용 (안전)
    println!("{}", b.unwrap_or(0));    // 0

    // unwrap_or_else: 값이 없으면 함수를 실행해서 기본값 생성
    println!("{}", b.unwrap_or_else(|| {
        println!("기본값을 계산합니다");
        100
    }));
    // 기본값을 계산합니다
    // 100

    // is_some(), is_none(): 값이 있는지 없는지 확인
    println!("a에 값 있나? {}", a.is_some()); // true
    println!("b에 값 있나? {}", b.is_some()); // false
}
```

> **실무 팁**: `unwrap()`은 프로그램이 죽을 수 있어서 위험합니다. 연습용으로만 쓰고, 실제 코드에서는 `match`, `if let`, `unwrap_or()` 등을 쓰세요.

<details>
<summary><b>🔍 왜 null 대신 Option을 쓰나? (null 참조의 10억 달러 실수)</b></summary>

### null 참조의 역사

`null`을 만든 Tony Hoare는 2009년에 이렇게 말했습니다:

> "나는 그것을 10억 달러짜리 실수라고 부릅니다."

`null`이 문제가 되는 이유:

```
// 다른 언어
String getName() {
    return null;  // 값이 없으면 null 반환
}

// 사용하는 쪽
String name = getName();
int len = name.length();  // 💥 NullPointerException!
// 컴파일할 때는 에러 없음. 실행해야 터짐.
```

**문제의 핵심**: 컴파일러가 `null` 가능성을 검사하지 않습니다. 실행해봐야 에러를 발견합니다.

### Rust의 해결법

Rust는 "값이 없을 수도 있는 경우"를 **타입 시스템으로 강제**합니다:

```rust
fn get_name() -> Option<String> {  // "없을 수도 있다"가 타입에 명시됨
    None
}

fn main() {
    let name = get_name();
    // name.len();  // ❌ 컴파일 에러! Option에 직접 .len()을 쓸 수 없음

    // 반드시 값이 있는지 확인해야 함
    match name {
        Some(n) => println!("길이: {}", n.len()),
        None => println!("이름이 없습니다"),
    }
}
```

**핵심 차이점**:

| | null | Option |
|---|---|---|
| 컴파일 시 검사 | 안 함 | **함** |
| 값이 없을 때 | 런타임에 터짐 | 컴파일에서 잡힘 |
| 처리 강제 | 안 됨 | **됨** (match 등) |
| 버그 발견 시점 | 배포 후 (최악) | 코딩 중 (최선) |

"값이 없을 수도 있다"는 정보가 타입에 담겨 있기 때문에, 깜빡하고 처리를 빠뜨릴 수 없습니다. 컴파일러가 잡아주니까요.

</details>

---

## 5. Result\<T, E> (맛보기)

`Option`이 "값이 있거나 없거나"를 표현한다면, `Result`는 **"성공했거나 실패했거나"**를 표현합니다.

### Ok(값)과 Err(에러)

```rust
// 이렇게 생겼습니다 (이미 내장)
enum Result<T, E> {
    Ok(T),    // 성공, 값은 T 타입
    Err(E),   // 실패, 에러는 E 타입
}
```

```rust
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        return Err(String::from("0으로 나눌 수 없습니다"));
    }
    Ok(a / b)
}

fn main() {
    let result1 = divide(10.0, 3.0);
    let result2 = divide(10.0, 0.0);

    match result1 {
        Ok(value) => println!("결과: {}", value),    // 결과: 3.3333...
        Err(msg) => println!("에러: {}", msg),
    }

    match result2 {
        Ok(value) => println!("결과: {}", value),
        Err(msg) => println!("에러: {}", msg),        // 에러: 0으로 나눌 수 없습니다
    }
}
```

### 에러 처리의 기본

파일 읽기, 네트워크 요청 등 **실패할 수 있는 작업**은 모두 `Result`를 반환합니다.

```rust
use std::fs;

fn main() {
    let result = fs::read_to_string("hello.txt");

    match result {
        Ok(content) => println!("파일 내용: {}", content),
        Err(error) => println!("파일 읽기 실패: {}", error),
    }
}
```

> `Result`를 더 편하게 다루는 `?` 연산자, 커스텀 에러 타입 등은 **07장 에러 처리**에서 자세히 배웁니다. 지금은 "성공/실패를 `Ok`/`Err`로 표현한다"는 것만 알면 충분합니다.

---

## 6. 실습

### 실습 1: 상품 구조체 만들기

상품 정보를 담는 구조체를 만들고, 총 가격을 계산하는 메서드를 구현하세요.

```rust
struct Product {
    name: String,
    price: u32,
    quantity: u32,
}

impl Product {
    fn new(name: &str, price: u32, quantity: u32) -> Product {
        Product {
            name: String::from(name),
            price,
            quantity,
        }
    }

    fn total_price(&self) -> u32 {
        self.price * self.quantity
    }

    fn display(&self) {
        println!(
            "상품: {} | 단가: {}원 | 수량: {}개 | 합계: {}원",
            self.name,
            self.price,
            self.quantity,
            self.total_price()
        );
    }
}

fn main() {
    let apple = Product::new("사과", 1500, 5);
    let banana = Product::new("바나나", 3000, 2);

    apple.display();
    banana.display();
    // 상품: 사과 | 단가: 1500원 | 수량: 5개 | 합계: 7500원
    // 상품: 바나나 | 단가: 3000원 | 수량: 2개 | 합계: 6000원

    let total = apple.total_price() + banana.total_price();
    println!("총 금액: {}원", total);
    // 총 금액: 13500원
}
```

**도전**: `discount` 메서드를 추가해서, 할인율(%)을 받아 할인된 총 가격을 반환하도록 만들어보세요!

### 실습 2: 주문 상태 열거형

주문 상태를 열거형으로 만들고, 상태별 메시지를 출력하는 함수를 작성하세요.

```rust
enum OrderStatus {
    Pending,
    Confirmed,
    Shipping(String),     // 배송 추적번호
    Delivered,
    Cancelled(String),    // 취소 사유
}

fn print_status(status: &OrderStatus) {
    match status {
        OrderStatus::Pending => {
            println!("주문이 접수되었습니다. 확인 대기 중...");
        }
        OrderStatus::Confirmed => {
            println!("주문이 확인되었습니다!");
        }
        OrderStatus::Shipping(tracking) => {
            println!("배송 중입니다. 추적번호: {}", tracking);
        }
        OrderStatus::Delivered => {
            println!("배송이 완료되었습니다!");
        }
        OrderStatus::Cancelled(reason) => {
            println!("주문이 취소되었습니다. 사유: {}", reason);
        }
    }
}

fn main() {
    let statuses = [
        OrderStatus::Pending,
        OrderStatus::Confirmed,
        OrderStatus::Shipping(String::from("KR1234567890")),
        OrderStatus::Delivered,
        OrderStatus::Cancelled(String::from("고객 요청")),
    ];

    for status in &statuses {
        print_status(status);
    }
}
```

**도전**: `is_active()` 함수를 만들어서, `Cancelled`와 `Delivered`가 아닌 경우 `true`를 반환하도록 만들어보세요!

### 실습 3: Option으로 사용자 검색

사용자 목록에서 이름으로 검색하는 함수를 만들고, 결과를 처리하세요.

```rust
struct User {
    id: u32,
    name: String,
    email: String,
}

fn find_user_by_name(users: &[User], name: &str) -> Option<&User> {
    for user in users {
        if user.name == name {
            return Some(user);
        }
    }
    None
}

fn main() {
    let users = vec![
        User { id: 1, name: String::from("홍길동"), email: String::from("hong@mail.com") },
        User { id: 2, name: String::from("김철수"), email: String::from("kim@mail.com") },
        User { id: 3, name: String::from("이영희"), email: String::from("lee@mail.com") },
    ];

    // 존재하는 사용자 검색
    match find_user_by_name(&users, "김철수") {
        Some(user) => {
            println!("찾았습니다! ID: {}, 이메일: {}", user.id, user.email);
        }
        None => {
            println!("해당 사용자를 찾을 수 없습니다.");
        }
    }
    // 찾았습니다! ID: 2, 이메일: kim@mail.com

    // 존재하지 않는 사용자 검색
    if let Some(user) = find_user_by_name(&users, "박지민") {
        println!("찾았습니다! {}", user.name);
    } else {
        println!("박지민을 찾을 수 없습니다.");
    }
    // 박지민을 찾을 수 없습니다.
}
```

**도전**: `find_user_by_id` 함수도 만들어보세요!

---

## 7. 확인 문제

### 문제 1
아래 코드가 에러나는 이유는?
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 10, y: 20 };
    p.x = 30;
}
```

### 문제 2
연관 함수와 메서드의 차이점은?
```rust
impl Rectangle {
    fn new(w: u32, h: u32) -> Rectangle { ... }  // (A)
    fn area(&self) -> u32 { ... }                 // (B)
}
```

### 문제 3
아래 코드의 출력 결과는?
```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value(coin: Coin) -> u32 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {
    println!("{}", value(Coin::Dime));
}
```

### 문제 4
아래 빈칸을 채워서 `Option`을 안전하게 처리하세요:
```rust
fn main() {
    let name: Option<String> = Some(String::from("Rust"));

    // ??? 을 사용해서 "Hello, Rust!" 를 출력하세요
}
```

### 문제 5
다음 중 `Option`에 대한 설명으로 **틀린 것**은?
- (a) `Some(42)`는 값 42를 가진 Option이다
- (b) `None`은 값이 없음을 나타낸다
- (c) `unwrap()`은 항상 안전하게 값을 꺼낸다
- (d) `if let`으로 `Some`일 때만 처리할 수 있다

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
`p`가 불변 변수이기 때문입니다. 필드 값을 변경하려면 인스턴스를 `mut`로 선언해야 합니다.
수정: `let mut p = Point { x: 10, y: 20 };`

### 문제 2 정답
- **(A) `new`는 연관 함수**입니다. 첫 번째 매개변수에 `self`가 없고, `Rectangle::new(w, h)`처럼 `::`로 호출합니다.
- **(B) `area`는 메서드**입니다. 첫 번째 매개변수가 `&self`이고, `rect.area()`처럼 `.`으로 호출합니다.

### 문제 3 정답
**`10`**

`Coin::Dime`은 `match`에서 `10`과 매칭됩니다.

### 문제 4 정답
여러 가지 방법이 있습니다:

```rust
fn main() {
    let name: Option<String> = Some(String::from("Rust"));

    // 방법 1: match
    match &name {
        Some(n) => println!("Hello, {}!", n),
        None => println!("이름이 없습니다"),
    }

    // 방법 2: if let
    if let Some(n) = &name {
        println!("Hello, {}!", n);
    }

    // 방법 3: unwrap (연습용으로만!)
    println!("Hello, {}!", name.unwrap());
}
```

### 문제 5 정답
**(c) `unwrap()`은 항상 안전하게 값을 꺼낸다**

`unwrap()`은 값이 `None`일 때 프로그램이 패닉(crash)합니다. 안전하지 않습니다. 실제 코드에서는 `match`, `if let`, `unwrap_or()` 등을 사용해야 합니다.

</details>

---

## 8. 5장 정리

| 배운 것 | 핵심 |
|---------|------|
| 구조체 정의 | `struct Name { field: Type }` |
| 인스턴스 생성 | `Name { field: value }` |
| 필드 접근 | `instance.field` |
| 업데이트 문법 | `Name { field: new_val, ..other }` |
| 메서드 | `impl Name { fn method(&self) { } }` |
| 연관 함수 | `impl Name { fn new() -> Name { } }` |
| 열거형 | `enum Name { A, B(Type), C { x: Type } }` |
| 열거형 + match | 모든 변형을 빠짐없이 처리 |
| Option\<T> | `Some(값)` 또는 `None` (null 대체) |
| Result\<T, E> | `Ok(값)` 또는 `Err(에러)` (에러 처리) |
| if let | `Some`일 때만 간단히 처리 |

---

## 다음 장 예고

> **06장. 컬렉션**에서는 여러 개의 데이터를 담는 방법을 배웁니다.
> 벡터(`Vec<T>`)로 목록을 관리하고, 해시맵(`HashMap`)으로 키-값 쌍을 저장합니다. 이터레이터와 클로저도 맛봅니다!
