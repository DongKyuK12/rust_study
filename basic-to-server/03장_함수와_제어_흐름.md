# 03장. 함수와 제어 흐름

> **목표**: 함수를 만들어 코드를 구조화하고, 조건문과 반복문으로 흐름을 제어할 수 있다.

---

## 1. 함수 정의와 호출

```rust
fn greet() {
    println!("안녕하세요!");
}

fn main() {
    greet(); // 함수 호출
    greet(); // 여러 번 호출 가능
}
```

함수는 `fn` 키워드로 만듭니다. 끝.

### 함수 이름 규칙

Rust에서 함수 이름은 **snake_case**를 사용합니다:

```rust
fn say_hello() { }       // O snake_case
fn calculate_total() { }  // O snake_case

fn sayHello() { }         // X camelCase (컴파일은 되지만 경고 발생)
```

### 함수 정의 위치

Rust는 함수를 **어디에 정의해도** 상관없습니다. `main` 위든 아래든 자유입니다:

```rust
fn main() {
    hello();  // hello는 아래에 정의되어 있지만 문제없음
}

fn hello() {
    println!("안녕!");
}
```

> 다른 언어(C 등)에서는 함수를 먼저 선언해야 하지만, Rust는 순서가 상관없습니다.

---

## 2. 매개변수와 반환값

### 매개변수

함수에 값을 전달할 수 있습니다. **매개변수에는 반드시 타입을 명시**해야 합니다:

```rust
fn greet(name: &str) {
    println!("안녕하세요, {}님!", name);
}

fn add(a: i32, b: i32) {
    println!("{} + {} = {}", a, b, a + b);
}

fn main() {
    greet("홍길동");
    add(3, 5);
}
```

실행 결과:
```
안녕하세요, 홍길동님!
3 + 5 = 8
```

### 반환값

반환값이 있는 함수는 `->` 뒤에 타입을 적습니다:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b  // 세미콜론 없음 = 이 값을 반환
}

fn main() {
    let result = add(3, 5);
    println!("3 + 5 = {}", result); // 3 + 5 = 8
}
```

### return 키워드 vs 마지막 표현식

값을 반환하는 방법이 **2가지** 있습니다:

```rust
// 방법 1: 마지막 표현식 (세미콜론 없이) - 권장!
fn add_v1(a: i32, b: i32) -> i32 {
    a + b
}

// 방법 2: return 키워드 사용
fn add_v2(a: i32, b: i32) -> i32 {
    return a + b;
}
```

두 함수는 동일한 결과를 반환합니다. Rust에서는 **방법 1(마지막 표현식)**이 일반적입니다.

> **주의!** 마지막 줄에 세미콜론을 붙이면 반환값이 사라집니다:
> ```rust
> fn add(a: i32, b: i32) -> i32 {
>     a + b;  // 세미콜론 붙이면 에러!
> }
> ```

<details>
<summary><b>문(statement)과 식(expression)의 차이 (원리)</b></summary>

### 문(Statement)과 식(Expression)

Rust에서 코드는 크게 **문**과 **식**으로 나뉩니다.

**식(Expression)**: 값을 만들어내는 코드

```rust
5 + 3          // 8이라는 값을 만들어냄
add(1, 2)      // 3이라는 값을 만들어냄
true           // true라는 값
```

**문(Statement)**: 값을 만들어내지 않는 코드

```rust
let x = 5;    // 변수 선언은 문 (값을 반환하지 않음)
```

### 왜 이게 중요한가요?

Rust에서 함수의 마지막 식이 **반환값**이 됩니다:

```rust
fn example() -> i32 {
    let x = 5;     // 문 (세미콜론 있음)
    x + 1          // 식 (세미콜론 없음) → 반환값!
}
```

세미콜론을 붙이면 식이 문으로 바뀝니다:

```
x + 1   → 식 (값 6을 반환)
x + 1;  → 문 (값을 반환하지 않음)
```

이 규칙 덕분에 `return`을 쓰지 않아도 자연스럽게 값을 반환할 수 있습니다. 이것이 Rust가 **"표현식 기반 언어"**라고 불리는 이유입니다.

### `{}` 블록도 식입니다

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1       // 세미콜론 없음 → 이 블록의 값은 4
    };

    println!("y = {}", y); // y = 4
}
```

중괄호 블록의 마지막 식이 블록 전체의 값이 됩니다.

</details>

---

## 3. if / else 표현식

### 기본 if / else

```rust
fn main() {
    let age = 20;

    if age >= 18 {
        println!("성인입니다.");
    } else {
        println!("미성년자입니다.");
    }
}
```

> Rust의 조건에는 **괄호가 필요 없습니다**. `if (age >= 18)` 대신 `if age >= 18`으로 씁니다.

### else if

```rust
fn main() {
    let score = 85;

    if score >= 90 {
        println!("A등급");
    } else if score >= 80 {
        println!("B등급");
    } else if score >= 70 {
        println!("C등급");
    } else {
        println!("F등급");
    }
}
```

### if는 표현식이다 (변수에 대입 가능)

Rust에서 `if`는 **값을 만들어내는 식(expression)**입니다:

```rust
fn main() {
    let age = 20;
    let status = if age >= 18 { "성인" } else { "미성년자" };

    println!("상태: {}", status); // 상태: 성인
}
```

> 이렇게 쓰려면 `if`와 `else`의 반환 타입이 같아야 합니다.

### 얼리 리턴 패턴

**얼리 리턴(Early Return)**은 조건이 맞지 않으면 **일찍 빠져나가는** 패턴입니다.
이 학습지에서는 앞으로 모든 코드에서 이 패턴을 사용합니다.

```rust
// 나쁜 예: 중첩이 깊어짐
fn process_order(quantity: i32, price: i32) -> String {
    if quantity > 0 {
        if price > 0 {
            let total = quantity * price;
            if total <= 100000 {
                format!("주문 완료! 총액: {}원", total)
            } else {
                String::from("10만원 초과 주문 불가")
            }
        } else {
            String::from("가격이 잘못되었습니다")
        }
    } else {
        String::from("수량이 잘못되었습니다")
    }
}
```

```rust
// 좋은 예: 얼리 리턴으로 깔끔하게
fn process_order(quantity: i32, price: i32) -> String {
    if quantity <= 0 {
        return String::from("수량이 잘못되었습니다");
    }

    if price <= 0 {
        return String::from("가격이 잘못되었습니다");
    }

    let total = quantity * price;

    if total > 100000 {
        return String::from("10만원 초과 주문 불가");
    }

    format!("주문 완료! 총액: {}원", total)
}

fn main() {
    println!("{}", process_order(3, 15000));
    println!("{}", process_order(0, 1000));
    println!("{}", process_order(5, -100));
}
```

실행 결과:
```
주문 완료! 총액: 45000원
수량이 잘못되었습니다
가격이 잘못되었습니다
```

**얼리 리턴의 핵심 원칙:**

| | 중첩 방식 | 얼리 리턴 |
|---|---|---|
| 비정상 조건 | 마지막에 else로 처리 | **먼저 걸러냄** |
| 정상 로직 | 깊은 중첩 안에 묻힘 | **함수 맨 아래에 깔끔하게** |
| 가독성 | 들여쓰기가 깊어짐 | 일직선으로 읽힘 |

<details>
<summary><b>왜 얼리 리턴이 좋은가 (원리)</b></summary>

### 얼리 리턴이 좋은 이유

#### 1. 중첩(indent)이 줄어든다

```
// 중첩 방식: 점점 오른쪽으로 밀림
if 조건1 {
    if 조건2 {
        if 조건3 {
            // 실제 로직이 여기 숨어있음
        }
    }
}

// 얼리 리턴: 항상 한 단계
if !조건1 { return; }
if !조건2 { return; }
if !조건3 { return; }
// 실제 로직
```

#### 2. 읽는 순서가 자연스럽다

얼리 리턴은 "경비원 패턴(Guard Clause)"이라고도 부릅니다. 건물 입구에서 자격 조건을 하나씩 검사하는 경비원처럼, 함수 시작 부분에서 잘못된 입력을 하나씩 걸러냅니다.

```rust
fn enter_building(has_id: bool, has_ticket: bool, age: i32) -> &'static str {
    // 경비원 1: 신분증 확인
    if !has_id {
        return "신분증이 없습니다";
    }

    // 경비원 2: 티켓 확인
    if !has_ticket {
        return "티켓이 없습니다";
    }

    // 경비원 3: 나이 확인
    if age < 18 {
        return "미성년자는 입장 불가";
    }

    // 모든 검사 통과 - 입장!
    "입장을 환영합니다"
}
```

#### 3. 실수를 줄여준다

중첩이 깊으면 `else` 블록이 어떤 `if`에 대응하는지 헷갈립니다. 얼리 리턴은 각 조건이 독립적이라 실수할 여지가 줄어듭니다.

**정리**: 비정상 케이스를 먼저 처리하고, 정상 로직을 함수 끝에 두세요.

</details>

---

## 4. match 표현식

### 기본 match 문법

`match`는 값을 여러 패턴과 비교하는 표현식입니다:

```rust
fn main() {
    let number = 3;

    match number {
        1 => println!("하나"),
        2 => println!("둘"),
        3 => println!("셋"),
        _ => println!("그 외"),
    }
}
```

실행 결과:
```
셋
```

### 모든 경우를 처리해야 한다 (exhaustive)

Rust의 `match`는 **모든 가능한 값을 처리해야** 합니다. 빠뜨리면 컴파일 에러가 발생합니다:

```rust
fn main() {
    let number = 3;

    // 에러! i32의 모든 값을 처리하지 않았음
    match number {
        1 => println!("하나"),
        2 => println!("둘"),
    }
}
```

### _ (와일드카드) 패턴

나머지 모든 값을 처리할 때 `_`를 사용합니다:

```rust
fn describe_number(n: i32) -> &'static str {
    match n {
        1 => "하나",
        2 => "둘",
        3 => "셋",
        _ => "기타", // 나머지 전부
    }
}

fn main() {
    println!("{}", describe_number(1));   // 하나
    println!("{}", describe_number(99));  // 기타
}
```

### match도 표현식이다

`if`와 마찬가지로 `match`도 값을 만들어냅니다:

```rust
fn main() {
    let grade = 'B';

    let description = match grade {
        'A' => "최고",
        'B' => "우수",
        'C' => "보통",
        _ => "기타",
    };

    println!("{} 등급: {}", grade, description); // B 등급: 우수
}
```

### 여러 패턴 묶기

`|`(또는)를 사용하여 여러 패턴을 하나로 묶을 수 있습니다:

```rust
fn main() {
    let day = "토";

    let kind = match day {
        "월" | "화" | "수" | "목" | "금" => "평일",
        "토" | "일" => "주말",
        _ => "알 수 없음",
    };

    println!("{}요일은 {}", day, kind); // 토요일은 주말
}
```

<details>
<summary><b>match vs if else, 언제 뭘 쓸까 (원리)</b></summary>

### match vs if else 비교

#### if else가 적합한 경우

- 조건이 **범위 비교**일 때 (크다, 작다, 이상, 이하)
- 조건이 **2~3개**로 단순할 때
- 서로 다른 변수를 비교할 때

```rust
// if else가 자연스러운 경우
fn check_age(age: i32) -> &'static str {
    if age < 0 {
        return "잘못된 나이";
    }

    if age < 18 {
        return "미성년자";
    }

    "성인"
}
```

#### match가 적합한 경우

- 하나의 값을 **여러 구체적인 값과 비교**할 때
- **열거형(enum)**을 다룰 때 (5장에서 배움)
- 모든 경우를 빠짐없이 처리해야 할 때

```rust
// match가 자연스러운 경우
fn get_day_type(day: &str) -> &str {
    match day {
        "월" | "화" | "수" | "목" | "금" => "평일",
        "토" | "일" => "주말",
        _ => "알 수 없음",
    }
}
```

#### 실전 가이드

| 상황 | 선택 |
|------|------|
| 참/거짓 조건 분기 | `if else` |
| 범위 비교 (>=, <= 등) | `if else` + 얼리 리턴 |
| 구체적인 값 매칭 | `match` |
| enum 처리 | `match` (거의 필수) |
| 2개 분기 | `if else` |
| 4개 이상 분기 | `match` |

**정리**: 범위 비교는 `if`, 값 매칭은 `match`가 자연스럽습니다. 애매하면 가독성이 좋은 쪽을 택하세요.

</details>

---

## 5. 반복문

### loop (무한 반복)

`loop`는 `break`를 만날 때까지 계속 반복합니다:

```rust
fn main() {
    let mut count = 0;

    loop {
        if count >= 5 {
            break;
        }

        println!("count = {}", count);
        count += 1;
    }
}
```

실행 결과:
```
count = 0
count = 1
count = 2
count = 3
count = 4
```

### while

조건이 참인 동안 반복합니다:

```rust
fn main() {
    let mut count = 0;

    while count < 5 {
        println!("count = {}", count);
        count += 1;
    }
}
```

결과는 위의 `loop` 예제와 동일합니다.

### for와 범위(range)

**`for`는 가장 많이 쓰는 반복문**입니다:

```rust
fn main() {
    // 0, 1, 2, 3, 4 (5는 미포함)
    for i in 0..5 {
        println!("i = {}", i);
    }

    println!("---");

    // 0, 1, 2, 3, 4, 5 (5도 포함)
    for i in 0..=5 {
        println!("i = {}", i);
    }
}
```

| 문법 | 의미 | 범위 |
|------|------|------|
| `0..5` | 0 이상 5 미만 | 0, 1, 2, 3, 4 |
| `0..=5` | 0 이상 5 이하 | 0, 1, 2, 3, 4, 5 |

### for와 이터레이터

배열(리스트)의 각 요소를 순회할 수도 있습니다:

```rust
fn main() {
    let fruits = ["사과", "바나나", "딸기"];

    for fruit in fruits.iter() {
        println!("과일: {}", fruit);
    }
}
```

실행 결과:
```
과일: 사과
과일: 바나나
과일: 딸기
```

### loop에서 break로 값 반환하기

`loop`는 `break`와 함께 값을 반환할 수 있습니다:

```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2; // 20을 반환
        }
    };

    println!("result = {}", result); // result = 20
}
```

### continue로 건너뛰기

`continue`는 나머지 코드를 건너뛰고 다음 반복으로 넘어갑니다:

```rust
fn main() {
    for i in 1..=10 {
        if i % 3 == 0 {
            continue; // 3의 배수는 건너뜀
        }

        println!("{}", i);
    }
}
```

실행 결과:
```
1
2
4
5
7
8
10
```

---

## 6. 실습

### 실습 1: 두 수 중 큰 수 반환하기 (얼리 리턴)

얼리 리턴을 사용하여 두 정수 중 큰 값을 반환하는 함수를 작성하세요.

```rust
fn max_of_two(a: i32, b: i32) -> i32 {
    if a >= b {
        return a;
    }

    b
}

fn main() {
    println!("max(3, 7) = {}", max_of_two(3, 7));
    println!("max(10, 2) = {}", max_of_two(10, 2));
    println!("max(5, 5) = {}", max_of_two(5, 5));
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
max(3, 7) = 7
max(10, 2) = 10
max(5, 5) = 5
```

**포인트**: `a >= b`이면 `a`를 즉시 반환(얼리 리턴)하고, 그렇지 않으면 함수 끝에서 `b`를 반환합니다.

</details>

### 실습 2: 1부터 100까지 합 구하기 (for 사용)

`for`문을 사용하여 1부터 100까지의 합을 계산하세요.

```rust
fn sum_1_to_100() -> i32 {
    let mut total = 0;

    for i in 1..=100 {
        total += i;
    }

    total
}

fn main() {
    let result = sum_1_to_100();
    println!("1부터 100까지의 합: {}", result);
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
1부터 100까지의 합: 5050
```

**포인트**: `1..=100`은 1부터 100까지(100 포함)를 뜻합니다. `total += i`는 `total = total + i`와 같습니다.

</details>

### 실습 3: FizzBuzz (match 사용)

1부터 30까지 반복하면서 다음 규칙에 따라 출력하세요:
- 3과 5의 배수 -> "FizzBuzz"
- 3의 배수 -> "Fizz"
- 5의 배수 -> "Buzz"
- 그 외 -> 숫자 출력

```rust
fn fizzbuzz(n: i32) -> String {
    match (n % 3, n % 5) {
        (0, 0) => String::from("FizzBuzz"),
        (0, _) => String::from("Fizz"),
        (_, 0) => String::from("Buzz"),
        _ => n.to_string(),
    }
}

fn main() {
    for i in 1..=30 {
        println!("{}: {}", i, fizzbuzz(i));
    }
}
```

<details>
<summary><b>실행 결과 확인 (일부)</b></summary>

```
1: 1
2: 2
3: Fizz
4: 4
5: Buzz
6: Fizz
7: 7
8: 8
9: Fizz
10: Buzz
11: 11
12: Fizz
13: 13
14: 14
15: FizzBuzz
...
30: FizzBuzz
```

**포인트**: `match (n % 3, n % 5)`는 두 나머지를 **튜플**로 묶어서 동시에 비교합니다. `(0, 0)`은 3과 5 모두의 배수, `(0, _)`는 3의 배수이고 5의 나머지는 상관없음(`_`), `(_, 0)`은 5의 배수, `_`는 나머지 전부를 뜻합니다.

</details>

---

## 7. 확인 문제

### 문제 1

아래 함수가 컴파일되지 않는 이유는?

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b;
}
```

<details>
<summary>정답 보기</summary>

`a + b` 뒤에 **세미콜론(`;`)** 이 있어서 문(statement)이 되었습니다. 문은 값을 반환하지 않으므로 `-> i32`와 맞지 않습니다.

수정 방법:
```rust
// 방법 1: 세미콜론 제거
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// 방법 2: return 사용
fn add(a: i32, b: i32) -> i32 {
    return a + b;
}
```

</details>

### 문제 2

아래 코드의 출력 결과는?

```rust
fn double(x: i32) -> i32 {
    x * 2
}

fn main() {
    let a = double(3);
    let b = double(a);
    println!("{}", b);
}
```

<details>
<summary>정답 보기</summary>

**`12`**

```
double(3) = 3 * 2 = 6  → a = 6
double(6) = 6 * 2 = 12 → b = 12
```

</details>

### 문제 3

아래 코드의 `status` 값은?

```rust
let temperature = 35;
let status = if temperature >= 30 { "더움" } else { "적당" };
```

<details>
<summary>정답 보기</summary>

**`"더움"`**

`temperature`가 35이고, 35 >= 30은 참이므로 `"더움"`이 `status`에 대입됩니다.

</details>

### 문제 4

`0..5`와 `0..=5`의 차이점은 무엇인가요?

<details>
<summary>정답 보기</summary>

- `0..5` : 0, 1, 2, 3, 4 (5를 **포함하지 않음**)
- `0..=5` : 0, 1, 2, 3, 4, 5 (5를 **포함함**)

`..`은 미만, `..=`은 이하입니다.

</details>

### 문제 5

아래 코드에서 `result`의 값은?

```rust
let result = match 7 % 2 {
    0 => "짝수",
    1 => "홀수",
    _ => "알 수 없음",
};
```

<details>
<summary>정답 보기</summary>

**`"홀수"`**

`7 % 2`는 1이므로, `1 => "홀수"` 패턴에 매칭됩니다.

> 참고: 나머지 연산(`%`)의 결과는 0 또는 1뿐이므로 사실 `_` 패턴에 도달할 일은 없지만, Rust 컴파일러는 i32의 모든 가능한 값을 처리해야 하므로 `_`가 필요합니다.

</details>

---

## 8. 3장 정리

| 배운 것 | 핵심 |
|---------|------|
| 함수 정의 | `fn 이름(매개변수: 타입) -> 반환타입 { }` |
| 함수 이름 | snake_case 사용 |
| 매개변수 | 타입 명시 필수: `fn add(a: i32, b: i32)` |
| 반환값 | 마지막 식(세미콜론 없이)이 반환값 |
| return | 함수 중간에서 일찍 반환할 때 사용 |
| if / else | 조건 분기, 표현식으로 변수에 대입 가능 |
| 얼리 리턴 | 비정상 조건을 먼저 걸러내는 패턴 |
| match | 값 매칭, 모든 경우 처리 필수, `_`로 나머지 처리 |
| loop | 무한 반복, `break`로 탈출 |
| while | 조건이 참인 동안 반복 |
| for | `for i in 0..5`, `for item in list.iter()` |
| break 값 반환 | `let x = loop { break 값; };` |

---

## 다음 장 예고

> **04장. 소유권(Ownership)**에서는 Rust만의 가장 독특하고 중요한 개념을 배웁니다.
> 소유권은 Rust가 가비지 컬렉터 없이도 메모리를 안전하게 관리하는 비결입니다.
> 이동(Move), 복사(Copy), 참조와 빌림(&, &mut) 등 Rust의 핵심을 다룹니다!
