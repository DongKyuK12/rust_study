# 18장. 라우팅과 미들웨어

> **목표**: Axum의 라우팅을 체계적으로 구성하고, 미들웨어로 공통 로직을 처리할 수 있다.

---

## 1. 중첩 라우터

17장에서 라우터 하나에 모든 경로를 넣었습니다. 경로가 많아지면 어떻게 될까요?

```rust
// 모든 경로를 한 곳에 넣으면 관리가 어렵다
let app = Router::new()
    .route("/api/users", get(list_users).post(create_user))
    .route("/api/users/:id", get(get_user).put(update_user).delete(delete_user))
    .route("/api/posts", get(list_posts).post(create_post))
    .route("/api/posts/:id", get(get_post).put(update_post).delete(delete_post))
    .route("/api/posts/:id/comments", get(list_comments).post(create_comment));
    // 경로가 계속 늘어난다...
```

### Router::nest()로 그룹화

`nest()`를 사용하면 **관련 경로끼리 묶을 수 있습니다**:

```rust
use axum::{Router, routing::get};

// 사용자 관련 라우터
fn user_routes() -> Router {
    Router::new()
        .route("/", get(list_users).post(create_user))
        .route("/:id", get(get_user).put(update_user).delete(delete_user))
}

// 게시글 관련 라우터
fn post_routes() -> Router {
    Router::new()
        .route("/", get(list_posts).post(create_post))
        .route("/:id", get(get_post).put(update_post).delete(delete_post))
}

// 메인 라우터에서 합치기
let app = Router::new()
    .nest("/api/users", user_routes())
    .nest("/api/posts", post_routes());
```

`nest("/api/users", user_routes())`는 `user_routes()` 안의 모든 경로 앞에 `/api/users`를 붙입니다.

결과:

| user_routes() 내부 경로 | 실제 접근 경로 |
|---|---|
| `/` | `/api/users` |
| `/:id` | `/api/users/:id` |

### API 버전 관리

`nest()`를 중첩하면 API 버전 관리도 간단합니다:

```rust
fn api_v1() -> Router {
    Router::new()
        .nest("/users", user_routes())
        .nest("/posts", post_routes())
}

let app = Router::new()
    .nest("/api/v1", api_v1());
// /api/v1/users, /api/v1/posts, ...
```

나중에 v2가 필요하면 `api_v2()` 함수를 추가하고 `.nest("/api/v2", api_v2())`만 하면 됩니다.

---

## 2. 경로 매개변수와 쿼리 파라미터 심화

17장에서 기본적인 `Path`와 `Query` 추출을 배웠습니다. 더 다양한 상황을 다뤄봅시다.

### 여러 경로 매개변수

경로에 매개변수가 여러 개일 수 있습니다:

```rust
use axum::extract::Path;

// /api/users/42/posts/7
async fn get_user_post(
    Path((user_id, post_id)): Path<(u32, u32)>,
) -> String {
    format!("사용자 {}의 게시글 {}", user_id, post_id)
}

let app = Router::new()
    .route("/api/users/:user_id/posts/:post_id", get(get_user_post));
```

`Path`에 **튜플**을 쓰면 순서대로 매칭됩니다.

### 선택적 쿼리 파라미터

검색 기능처럼 파라미터가 있을 수도 없을 수도 있는 경우:

```rust
use axum::extract::Query;
use serde::Deserialize;

#[derive(Deserialize)]
struct SearchParams {
    keyword: Option<String>,    // 있어도 되고 없어도 됨
    page: Option<u32>,          // 있어도 되고 없어도 됨
    per_page: Option<u32>,      // 있어도 되고 없어도 됨
}

async fn search_users(Query(params): Query<SearchParams>) -> String {
    let keyword = params.keyword.unwrap_or_default();
    let page = params.page.unwrap_or(1);
    let per_page = params.per_page.unwrap_or(20);

    format!(
        "검색: '{}', 페이지: {}, 한 페이지당: {}개",
        keyword, page, per_page
    )
}
```

요청 예시:

| URL | keyword | page | per_page |
|---|---|---|---|
| `/search` | `""` (기본값) | `1` (기본값) | `20` (기본값) |
| `/search?keyword=rust` | `"rust"` | `1` | `20` |
| `/search?keyword=rust&page=3` | `"rust"` | `3` | `20` |
| `/search?keyword=rust&page=3&per_page=10` | `"rust"` | `3` | `10` |

`Option<T>`으로 감싸면 **해당 파라미터가 없어도 에러가 나지 않습니다**.

### 유효성 검사

쿼리 파라미터 값을 받았다고 바로 쓰면 안 됩니다. **검증을 먼저** 합니다:

```rust
use axum::http::StatusCode;
use axum::response::IntoResponse;

async fn get_users_page(
    Query(params): Query<SearchParams>,
) -> Result<String, (StatusCode, String)> {
    let page = params.page.unwrap_or(1);
    if page == 0 {
        return Err((StatusCode::BAD_REQUEST, "페이지는 1 이상이어야 합니다".to_string()));
    }

    let per_page = params.per_page.unwrap_or(20);
    if per_page > 100 {
        return Err((StatusCode::BAD_REQUEST, "한 페이지당 최대 100개입니다".to_string()));
    }

    Ok(format!("페이지 {}, {}개씩", page, per_page))
}
```

얼리 리턴으로 잘못된 값을 먼저 걸러내고, 마지막에 성공 로직만 남깁니다.

---

## 3. 상태 공유 (State)

웹서버에서는 **모든 핸들러가 공유하는 데이터**가 필요합니다. 예를 들어:

- 데이터베이스 연결 풀
- 설정 값
- 캐시

### 왜 전역 변수를 안 쓸까?

Rust에서는 전역 변수에 가변 접근이 기본적으로 안 됩니다. `unsafe`를 쓸 수도 있지만, 위험합니다.

대신 Axum은 **State 추출자**를 제공합니다:

```rust
use axum::{Router, routing::get, extract::State};

// 1. 공유할 상태를 정의
#[derive(Clone)]
struct AppState {
    app_name: String,
    max_connections: u32,
}

// 2. 핸들러에서 State로 꺼내 쓰기
async fn index(State(state): State<AppState>) -> String {
    format!("앱 이름: {}, 최대 연결: {}",
        state.app_name, state.max_connections)
}

async fn health(State(state): State<AppState>) -> String {
    format!("{} 서버 정상 작동 중", state.app_name)
}

// 3. Router에 상태 등록
#[tokio::main]
async fn main() {
    let state = AppState {
        app_name: String::from("내 웹서버"),
        max_connections: 100,
    };

    let app = Router::new()
        .route("/", get(index))
        .route("/health", get(health))
        .with_state(state);  // 상태 등록

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

`.with_state(state)`로 등록하면, **모든 핸들러에서 `State(state)`로 꺼내 쓸 수 있습니다**.

### 실전: 데이터베이스 풀을 상태로 공유

실제 프로젝트에서는 데이터베이스 연결 풀을 공유합니다:

```rust
use std::sync::Arc;

// 여러 스레드에서 안전하게 공유하려면 Arc로 감싼다
#[derive(Clone)]
struct AppState {
    // Arc: 참조 카운팅 스마트 포인터 (12장에서 배움)
    // 여러 스레드가 동시에 접근해도 안전
    db_pool: Arc<String>, // 실제로는 Arc<PgPool> 등
}
```

<details>
<summary><b>왜 State가 필요한가? (원리)</b></summary>

### 함수형 핸들러의 한계와 의존성 주입

Axum의 핸들러는 **일반 함수**입니다:

```rust
async fn get_user(Path(id): Path<u32>) -> String {
    // 여기서 데이터베이스에 접근하려면?
    // 함수 매개변수로 받는 수밖에 없다!
    format!("사용자 {}", id)
}
```

객체지향 프레임워크(Spring, Express 등)에서는 클래스의 필드로 DB 연결을 보관합니다:

```java
// Java Spring - 클래스 필드에 저장
class UserController {
    private UserRepository repo;  // 필드에 저장

    User getUser(int id) {
        return repo.findById(id);  // 필드 접근
    }
}
```

Rust의 함수형 핸들러에는 "필드"가 없습니다. 그래서 **State 추출자가 의존성 주입(DI) 역할**을 합니다:

```rust
// Rust Axum - State가 DI 역할
async fn get_user(
    State(state): State<AppState>,  // 프레임워크가 주입해줌
    Path(id): Path<u32>,
) -> String {
    // state.db_pool로 데이터베이스 접근
    format!("사용자 {}", id)
}
```

Axum이 핸들러를 호출할 때 **자동으로 State를 주입**해줍니다. 우리는 매개변수에 `State(state)`만 추가하면 됩니다.

</details>

---

## 4. 미들웨어 개념

**미들웨어(middleware)**는 요청과 응답 사이에서 **공통 로직을 처리**하는 계층입니다.

### 양파 모델

미들웨어는 양파 껍질처럼 겹겹이 쌓여 있습니다:

```
요청 (Request)
  │
  ▼
┌─────────────────────────┐
│  미들웨어 1 (로깅)       │ ← 요청 로그 기록
│  ┌───────────────────┐  │
│  │ 미들웨어 2 (CORS)  │  │ ← CORS 헤더 확인
│  │  ┌─────────────┐  │  │
│  │  │  핸들러      │  │  │ ← 실제 비즈니스 로직
│  │  └─────────────┘  │  │
│  │                   │  │ ← CORS 헤더 추가
│  └───────────────────┘  │
│                         │ ← 응답 로그 기록
└─────────────────────────┘
  │
  ▼
응답 (Response)
```

흐름을 정리하면:

```
요청 → 미들웨어1 진입 → 미들웨어2 진입 → 핸들러 실행
                                              │
응답 ← 미들웨어1 퇴장 ← 미들웨어2 퇴장 ←──────┘
```

### 미들웨어가 하는 일

| 용도 | 예시 |
|---|---|
| 로깅 | 모든 요청/응답을 기록 |
| 인증 | 로그인 여부 확인 |
| CORS | 브라우저 보안 정책 처리 |
| 압축 | 응답 본문을 gzip으로 압축 |
| 에러 처리 | 통일된 에러 응답 형식 |

핸들러마다 같은 코드를 반복하지 않고, **미들웨어 한 곳에서 공통 처리**합니다.

### Axum에서 미들웨어 추가하기

Axum은 `tower`라는 미들웨어 생태계를 사용합니다. `.layer()`로 미들웨어를 추가합니다:

```rust
let app = Router::new()
    .route("/", get(index))
    .layer(미들웨어1)
    .layer(미들웨어2);
```

> **주의**: `.layer()`는 **아래에서 위로** 적용됩니다. 위 코드에서 요청은 `미들웨어2 → 미들웨어1 → 핸들러` 순서로 통과합니다.

---

## 5. 로깅 미들웨어

모든 요청과 응답을 기록하는 것은 서버 운영의 기본입니다. Axum에서는 `tower-http`와 `tracing` 크레이트를 사용합니다.

### 의존성 추가

```toml
# Cargo.toml
[dependencies]
axum = "0.8"
tokio = { version = "1", features = ["full"] }
tower-http = { version = "0.6", features = ["trace"] }
tracing = "0.1"
tracing-subscriber = "0.3"
```

### 기본 설정

```rust
use axum::{Router, routing::get};
use tower_http::trace::TraceLayer;

async fn hello() -> &'static str {
    "안녕하세요!"
}

async fn health() -> &'static str {
    "OK"
}

#[tokio::main]
async fn main() {
    // 로그 출력 초기화
    tracing_subscriber::fmt()
        .with_target(false)       // 모듈 경로 숨기기
        .compact()                // 간결한 형식
        .init();

    let app = Router::new()
        .route("/", get(hello))
        .route("/health", get(health))
        .layer(TraceLayer::new_for_http());  // 로깅 미들웨어 추가

    tracing::info!("서버 시작: http://localhost:3000");

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

서버를 실행하고 요청을 보내면 터미널에 이런 로그가 나옵니다:

```
2025-01-15T12:00:00  INFO 서버 시작: http://localhost:3000
2025-01-15T12:00:05  INFO request{method=GET uri=/ version=HTTP/1.1} started
2025-01-15T12:00:05  INFO request{method=GET uri=/ version=HTTP/1.1} completed 200 OK in 1ms
```

### tracing 매크로

코드 곳곳에서 로그를 남기고 싶을 때 `tracing` 매크로를 사용합니다:

```rust
async fn create_user() -> &'static str {
    tracing::info!("새 사용자 생성 요청");
    // ... 사용자 생성 로직 ...
    tracing::debug!("사용자 생성 완료");
    "생성됨"
}
```

| 매크로 | 수준 | 용도 |
|---|---|---|
| `tracing::error!()` | ERROR | 에러 발생 |
| `tracing::warn!()` | WARN | 경고 |
| `tracing::info!()` | INFO | 주요 이벤트 |
| `tracing::debug!()` | DEBUG | 디버깅 정보 |
| `tracing::trace!()` | TRACE | 매우 상세한 정보 |

<details>
<summary><b>tracing vs println! (원리)</b></summary>

### 왜 println! 대신 tracing을 쓸까?

`println!`은 단순히 문자열을 출력합니다. `tracing`은 **구조화된 로깅**을 제공합니다.

차이점:

```rust
// println! - 단순 문자열
println!("사용자 {} 로그인", user_id);
// 출력: 사용자 42 로그인

// tracing - 구조화된 데이터
tracing::info!(user_id = 42, "사용자 로그인");
// 출력: 2025-01-15T12:00:00 INFO 사용자 로그인 user_id=42
```

`tracing`의 장점:

| 기능 | println! | tracing |
|---|---|---|
| 타임스탬프 | 직접 추가해야 함 | 자동 |
| 로그 수준 | 없음 | ERROR/WARN/INFO/DEBUG/TRACE |
| 수준별 필터링 | 불가 | `RUST_LOG=info`로 필터 |
| 구조화 데이터 | 불가 | `key=value` 형태로 검색 가능 |
| 성능 | 항상 출력 | 비활성화된 수준은 비용 없음 |

프로덕션에서는 `RUST_LOG` 환경 변수로 로그 수준을 제어합니다:

```bash
RUST_LOG=info cargo run    # INFO 이상만 출력
RUST_LOG=debug cargo run   # DEBUG 이상 출력
RUST_LOG=error cargo run   # ERROR만 출력
```

</details>

---

## 6. CORS 설정

### CORS란?

브라우저는 보안을 위해 **다른 출처(origin)의 요청을 차단**합니다. 이것이 **CORS (Cross-Origin Resource Sharing)** 정책입니다.

```
프론트엔드: http://localhost:5173  (Vite 개발 서버)
백엔드:     http://localhost:3000  (Axum 서버)
```

프론트엔드에서 백엔드로 API를 호출하면, **출처가 다르기 때문에** 브라우저가 차단합니다:

```
브라우저: "localhost:5173에서 localhost:3000으로 요청?
          출처가 다르니까 차단!"
```

서버에서 "이 출처의 요청을 허용한다"고 알려줘야 합니다. 이것이 CORS 설정입니다.

### 의존성 추가

```toml
# Cargo.toml
[dependencies]
tower-http = { version = "0.6", features = ["trace", "cors"] }
```

### 기본 CORS 설정

```rust
use tower_http::cors::{CorsLayer, Any};

let cors = CorsLayer::new()
    .allow_origin(Any)      // 모든 출처 허용
    .allow_methods(Any)     // 모든 HTTP 메서드 허용
    .allow_headers(Any);    // 모든 헤더 허용

let app = Router::new()
    .route("/", get(hello))
    .layer(cors);
```

> **주의**: `allow_origin(Any)`는 **개발 환경에서만** 사용하세요. 프로덕션에서는 허용할 출처를 명시해야 합니다.

### 프로덕션 CORS 설정

```rust
use tower_http::cors::{CorsLayer, AllowOrigin};
use axum::http::{Method, HeaderName};

let cors = CorsLayer::new()
    .allow_origin([
        "https://myapp.com".parse().unwrap(),
        "https://admin.myapp.com".parse().unwrap(),
    ])
    .allow_methods([Method::GET, Method::POST, Method::PUT, Method::DELETE])
    .allow_headers([
        HeaderName::from_static("content-type"),
        HeaderName::from_static("authorization"),
    ]);

let app = Router::new()
    .route("/api/users", get(list_users))
    .layer(cors);
```

| 설정 | 개발 환경 | 프로덕션 |
|---|---|---|
| `allow_origin` | `Any` | 허용할 도메인만 명시 |
| `allow_methods` | `Any` | 필요한 메서드만 |
| `allow_headers` | `Any` | 필요한 헤더만 |

---

## 7. 에러 처리 미들웨어

API 서버에서 에러가 발생하면 **통일된 형식으로** 응답해야 합니다. 어떤 핸들러에서든 같은 구조의 에러 JSON을 반환하는 것이 좋습니다.

### 통일된 에러 응답 형식

```json
{
    "error": {
        "code": "NOT_FOUND",
        "message": "사용자를 찾을 수 없습니다"
    }
}
```

### 커스텀 에러 타입 만들기

`IntoResponse` 트레이트를 구현하면 Axum이 에러를 HTTP 응답으로 변환합니다:

```rust
use axum::response::IntoResponse;
use axum::http::StatusCode;
use axum::Json;
use serde::Serialize;

// 에러 응답 JSON 구조
#[derive(Serialize)]
struct ErrorBody {
    error: ErrorDetail,
}

#[derive(Serialize)]
struct ErrorDetail {
    code: String,
    message: String,
}

// 커스텀 에러 타입
enum AppError {
    NotFound(String),
    BadRequest(String),
    InternalError(String),
}

// AppError를 HTTP 응답으로 변환
impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, code, message) = match self {
            AppError::NotFound(msg) => (
                StatusCode::NOT_FOUND,
                "NOT_FOUND",
                msg,
            ),
            AppError::BadRequest(msg) => (
                StatusCode::BAD_REQUEST,
                "BAD_REQUEST",
                msg,
            ),
            AppError::InternalError(msg) => (
                StatusCode::INTERNAL_SERVER_ERROR,
                "INTERNAL_ERROR",
                msg,
            ),
        };

        let body = ErrorBody {
            error: ErrorDetail {
                code: code.to_string(),
                message,
            },
        };

        (status, Json(body)).into_response()
    }
}
```

### 핸들러에서 사용하기

```rust
use axum::extract::Path;

async fn get_user(Path(id): Path<u32>) -> Result<Json<serde_json::Value>, AppError> {
    if id == 0 {
        return Err(AppError::BadRequest("ID는 0이 될 수 없습니다".to_string()));
    }

    if id > 1000 {
        return Err(AppError::NotFound(
            format!("ID {}인 사용자를 찾을 수 없습니다", id)
        ));
    }

    // 성공 응답
    Ok(Json(serde_json::json!({
        "id": id,
        "name": "홍길동"
    })))
}
```

요청과 응답 예시:

```
GET /api/users/0
→ 400 Bad Request
{
    "error": {
        "code": "BAD_REQUEST",
        "message": "ID는 0이 될 수 없습니다"
    }
}

GET /api/users/9999
→ 404 Not Found
{
    "error": {
        "code": "NOT_FOUND",
        "message": "ID 9999인 사용자를 찾을 수 없습니다"
    }
}

GET /api/users/1
→ 200 OK
{
    "id": 1,
    "name": "홍길동"
}
```

핸들러에서는 **얼리 리턴으로 에러를 반환**하고, `IntoResponse` 구현이 **자동으로 JSON 에러 응답을 생성**합니다.

<details>
<summary><b>IntoResponse 트레이트의 동작 원리 (원리)</b></summary>

### Axum은 어떻게 다양한 반환 타입을 처리할까?

Axum 핸들러는 `IntoResponse` 트레이트를 구현한 **어떤 타입이든** 반환할 수 있습니다:

```rust
// 문자열 반환 - IntoResponse가 구현되어 있음
async fn hello() -> &'static str {
    "안녕하세요"
}

// 튜플 반환 - (StatusCode, 본문)도 IntoResponse 구현
async fn not_found() -> (StatusCode, &'static str) {
    (StatusCode::NOT_FOUND, "찾을 수 없습니다")
}

// Json 반환 - Json<T>도 IntoResponse 구현
async fn user() -> Json<User> {
    Json(User { name: "홍길동".into() })
}

// Result 반환 - T와 E 모두 IntoResponse이면 Result도 IntoResponse
async fn get_user() -> Result<Json<User>, AppError> {
    // ...
}
```

`Result<T, E>`의 동작:
- `Ok(value)` -> `value.into_response()` 호출 (성공 응답)
- `Err(error)` -> `error.into_response()` 호출 (에러 응답)

그래서 `AppError`에 `IntoResponse`를 구현하면, `Err(AppError::NotFound(...))`를 반환했을 때 자동으로 404 JSON 응답이 됩니다.

이 패턴의 장점:
- 핸들러는 비즈니스 로직에만 집중
- 에러 응답 형식은 `IntoResponse` 구현에서 한 곳에서 관리
- 새 에러 종류를 추가해도 핸들러 코드를 수정할 필요 없음

</details>

---

## 8. 전체 예제

지금까지 배운 것을 합쳐서 완전한 웹서버를 만들어봅시다.

### Cargo.toml

```toml
[package]
name = "chapter18"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.8"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tower-http = { version = "0.6", features = ["trace", "cors"] }
tracing = "0.1"
tracing-subscriber = "0.3"
```

### main.rs

```rust
use axum::{
    Router, Json,
    extract::{Path, Query, State},
    http::StatusCode,
    response::IntoResponse,
    routing::get,
};
use serde::{Deserialize, Serialize};
use tower_http::cors::{CorsLayer, Any};
use tower_http::trace::TraceLayer;

// ── 상태 ──
#[derive(Clone)]
struct AppState {
    app_name: String,
}

// ── 에러 ──
#[derive(Serialize)]
struct ErrorBody {
    error: ErrorDetail,
}

#[derive(Serialize)]
struct ErrorDetail {
    code: String,
    message: String,
}

enum AppError {
    NotFound(String),
    BadRequest(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, code, message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, "NOT_FOUND", msg),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, "BAD_REQUEST", msg),
        };

        let body = ErrorBody {
            error: ErrorDetail {
                code: code.to_string(),
                message,
            },
        };

        (status, Json(body)).into_response()
    }
}

// ── 핸들러 ──
async fn index(State(state): State<AppState>) -> String {
    format!("{} 서버에 오신 것을 환영합니다!", state.app_name)
}

#[derive(Serialize)]
struct User {
    id: u32,
    name: String,
}

async fn list_users() -> Json<Vec<User>> {
    let users = vec![
        User { id: 1, name: "홍길동".to_string() },
        User { id: 2, name: "김철수".to_string() },
    ];
    Json(users)
}

async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, AppError> {
    if id == 0 {
        return Err(AppError::BadRequest("ID는 0이 될 수 없습니다".to_string()));
    }
    if id > 100 {
        return Err(AppError::NotFound(
            format!("ID {}인 사용자를 찾을 수 없습니다", id),
        ));
    }

    Ok(Json(User {
        id,
        name: "홍길동".to_string(),
    }))
}

#[derive(Deserialize)]
struct SearchParams {
    keyword: Option<String>,
    page: Option<u32>,
}

async fn search_users(
    Query(params): Query<SearchParams>,
) -> Result<String, AppError> {
    let page = params.page.unwrap_or(1);
    if page == 0 {
        return Err(AppError::BadRequest("페이지는 1 이상이어야 합니다".to_string()));
    }

    let keyword = params.keyword.unwrap_or_default();
    Ok(format!("검색: '{}', 페이지: {}", keyword, page))
}

// ── 라우터 ──
fn user_routes() -> Router<AppState> {
    Router::new()
        .route("/", get(list_users))
        .route("/search", get(search_users))
        .route("/:id", get(get_user))
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_target(false)
        .compact()
        .init();

    let state = AppState {
        app_name: String::from("18장 실습 서버"),
    };

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers(Any);

    let app = Router::new()
        .route("/", get(index))
        .nest("/api/users", user_routes())
        .layer(cors)
        .layer(TraceLayer::new_for_http())
        .with_state(state);

    tracing::info!("서버 시작: http://localhost:3000");

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

---

## 9. 실습

### 실습 1: 중첩 라우터로 API 구조 잡기

게시글(posts)과 댓글(comments) 라우터를 중첩 라우터로 구성하세요.

**요구사항:**
- `/api/posts` -> 게시글 목록
- `/api/posts/:id` -> 게시글 상세
- `/api/posts/:id/comments` -> 해당 게시글의 댓글 목록
- 각 라우터를 별도 함수로 분리

```rust
use axum::{Router, Json, extract::Path, routing::get};
use serde::Serialize;

#[derive(Serialize)]
struct Post {
    id: u32,
    title: String,
}

#[derive(Serialize)]
struct Comment {
    id: u32,
    post_id: u32,
    body: String,
}

async fn list_posts() -> Json<Vec<Post>> {
    Json(vec![
        Post { id: 1, title: "첫 번째 글".to_string() },
        Post { id: 2, title: "두 번째 글".to_string() },
    ])
}

async fn get_post(Path(id): Path<u32>) -> Json<Post> {
    Json(Post { id, title: format!("게시글 {}", id) })
}

async fn list_comments(Path(post_id): Path<u32>) -> Json<Vec<Comment>> {
    Json(vec![
        Comment { id: 1, post_id, body: "좋은 글이네요!".to_string() },
        Comment { id: 2, post_id, body: "감사합니다.".to_string() },
    ])
}

fn post_routes() -> Router {
    Router::new()
        .route("/", get(list_posts))
        .route("/:id", get(get_post))
        .route("/:id/comments", get(list_comments))
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .nest("/api/posts", post_routes());

    println!("서버 시작: http://localhost:3000");
    println!("GET /api/posts");
    println!("GET /api/posts/1");
    println!("GET /api/posts/1/comments");

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

**테스트 방법** (터미널에서):
```bash
curl http://localhost:3000/api/posts
curl http://localhost:3000/api/posts/1
curl http://localhost:3000/api/posts/1/comments
```

### 실습 2: 로깅 미들웨어 추가하고 요청 로그 확인

실습 1의 서버에 로깅 미들웨어를 추가하고, 요청이 올 때마다 로그가 출력되는지 확인하세요.

**요구사항:**
- `tracing_subscriber` 초기화
- `TraceLayer::new_for_http()` 미들웨어 추가
- 각 핸들러에 `tracing::info!()` 로그 추가

```rust
use axum::{Router, Json, extract::Path, routing::get};
use serde::Serialize;
use tower_http::trace::TraceLayer;

#[derive(Serialize)]
struct Post {
    id: u32,
    title: String,
}

async fn list_posts() -> Json<Vec<Post>> {
    tracing::info!("게시글 목록 조회");
    Json(vec![
        Post { id: 1, title: "첫 번째 글".to_string() },
        Post { id: 2, title: "두 번째 글".to_string() },
    ])
}

async fn get_post(Path(id): Path<u32>) -> Json<Post> {
    tracing::info!(post_id = id, "게시글 상세 조회");
    Json(Post { id, title: format!("게시글 {}", id) })
}

fn post_routes() -> Router {
    Router::new()
        .route("/", get(list_posts))
        .route("/:id", get(get_post))
}

#[tokio::main]
async fn main() {
    // 로그 출력 초기화
    tracing_subscriber::fmt()
        .with_target(false)
        .compact()
        .init();

    let app = Router::new()
        .nest("/api/posts", post_routes())
        .layer(TraceLayer::new_for_http());  // 로깅 미들웨어

    tracing::info!("서버 시작: http://localhost:3000");

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

**예상 로그 출력:**
```
2025-01-15T12:00:00  INFO 서버 시작: http://localhost:3000
2025-01-15T12:00:05  INFO request{method=GET uri=/api/posts version=HTTP/1.1} started
2025-01-15T12:00:05  INFO 게시글 목록 조회
2025-01-15T12:00:05  INFO request{method=GET uri=/api/posts version=HTTP/1.1} completed 200 OK
```

### 실습 3: 커스텀 에러 타입 만들어서 JSON 에러 응답

게시글 CRUD에서 에러가 발생할 때 통일된 JSON 형식으로 응답하세요.

**요구사항:**
- `AppError` 타입에 `NotFound`, `BadRequest`, `InternalError` 정의
- `IntoResponse` 구현으로 자동 JSON 에러 응답
- 핸들러에서 얼리 리턴 패턴으로 에러 반환

```rust
use axum::{
    Router, Json,
    extract::Path,
    http::StatusCode,
    response::IntoResponse,
    routing::{get, post},
};
use serde::{Deserialize, Serialize};

// 에러 응답 구조
#[derive(Serialize)]
struct ErrorBody {
    error: ErrorDetail,
}

#[derive(Serialize)]
struct ErrorDetail {
    code: String,
    message: String,
}

// 커스텀 에러
enum AppError {
    NotFound(String),
    BadRequest(String),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, code, message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, "NOT_FOUND", msg),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, "BAD_REQUEST", msg),
            AppError::InternalError(msg) => (
                StatusCode::INTERNAL_SERVER_ERROR, "INTERNAL_ERROR", msg,
            ),
        };

        let body = ErrorBody {
            error: ErrorDetail {
                code: code.to_string(),
                message,
            },
        };

        (status, Json(body)).into_response()
    }
}

// 게시글
#[derive(Serialize)]
struct Post {
    id: u32,
    title: String,
    body: String,
}

#[derive(Deserialize)]
struct CreatePost {
    title: String,
    body: String,
}

async fn get_post(Path(id): Path<u32>) -> Result<Json<Post>, AppError> {
    // 검증: 얼리 리턴
    if id == 0 {
        return Err(AppError::BadRequest("ID는 0이 될 수 없습니다".to_string()));
    }
    if id > 100 {
        return Err(AppError::NotFound(
            format!("ID {}인 게시글을 찾을 수 없습니다", id),
        ));
    }

    // 성공
    Ok(Json(Post {
        id,
        title: format!("게시글 {}", id),
        body: "내용입니다.".to_string(),
    }))
}

async fn create_post(
    Json(input): Json<CreatePost>,
) -> Result<(StatusCode, Json<Post>), AppError> {
    // 검증: 얼리 리턴
    if input.title.is_empty() {
        return Err(AppError::BadRequest("제목을 입력하세요".to_string()));
    }
    if input.title.len() > 100 {
        return Err(AppError::BadRequest("제목은 100자 이하여야 합니다".to_string()));
    }
    if input.body.is_empty() {
        return Err(AppError::BadRequest("내용을 입력하세요".to_string()));
    }

    // 성공
    let post = Post {
        id: 1,
        title: input.title,
        body: input.body,
    };

    Ok((StatusCode::CREATED, Json(post)))
}

#[tokio::main]
async fn main() {
    let app = Router::new()
        .route("/api/posts", post(create_post))
        .route("/api/posts/:id", get(get_post));

    println!("서버 시작: http://localhost:3000");

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000")
        .await
        .unwrap();
    axum::serve(listener, app).await.unwrap();
}
```

**테스트:**
```bash
# 정상 조회
curl http://localhost:3000/api/posts/1
# → {"id":1,"title":"게시글 1","body":"내용입니다."}

# 잘못된 ID
curl http://localhost:3000/api/posts/0
# → {"error":{"code":"BAD_REQUEST","message":"ID는 0이 될 수 없습니다"}}

# 존재하지 않는 게시글
curl http://localhost:3000/api/posts/999
# → {"error":{"code":"NOT_FOUND","message":"ID 999인 게시글을 찾을 수 없습니다"}}

# 게시글 생성
curl -X POST http://localhost:3000/api/posts \
  -H "Content-Type: application/json" \
  -d '{"title":"새 글","body":"내용"}'
# → {"id":1,"title":"새 글","body":"내용"}

# 빈 제목으로 생성
curl -X POST http://localhost:3000/api/posts \
  -H "Content-Type: application/json" \
  -d '{"title":"","body":"내용"}'
# → {"error":{"code":"BAD_REQUEST","message":"제목을 입력하세요"}}
```

---

## 10. 확인 문제

### 문제 1

`Router::nest("/api/users", user_routes())`에서 `user_routes()` 안의 경로가 `"/"`와 `"/:id"`라면, 실제 접근 가능한 URL은 무엇인가요?

### 문제 2

다음 코드에서 미들웨어의 실행 순서는?

```rust
let app = Router::new()
    .route("/", get(handler))
    .layer(로깅_미들웨어)
    .layer(CORS_미들웨어);
```

- (a) 요청 -> 로깅 -> CORS -> 핸들러
- (b) 요청 -> CORS -> 로깅 -> 핸들러
- (c) 요청 -> 핸들러 -> 로깅 -> CORS
- (d) 순서 상관없음

### 문제 3

`State`를 사용하려면 상태 구조체에 반드시 구현해야 하는 트레이트는?

- (a) `Debug`
- (b) `Clone`
- (c) `Serialize`
- (d) `Display`

### 문제 4

CORS에서 `allow_origin(Any)`를 프로덕션에서 사용하면 안 되는 이유는 무엇인가요?

### 문제 5

다음 핸들러에서 빈칸을 채우세요:

```rust
async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, AppError> {
    if id == 0 {
        ______(AppError::BadRequest("잘못된 ID".to_string()));
    }

    Ok(Json(User { id, name: "홍길동".to_string() }))
}
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답

`/api/users`와 `/api/users/:id`입니다. `nest()`는 내부 경로 앞에 지정한 접두사를 붙입니다.

### 문제 2 정답: **(b) 요청 -> CORS -> 로깅 -> 핸들러**

`.layer()`는 **아래에서 위로(나중에 추가된 것이 바깥쪽)** 적용됩니다. 마지막에 추가한 CORS가 가장 바깥쪽이므로 요청을 먼저 받습니다.

```
요청 → CORS(바깥) → 로깅(안쪽) → 핸들러
```

### 문제 3 정답: **(b) Clone**

`State`는 각 요청마다 핸들러에 전달되므로 복제가 필요합니다. 따라서 `#[derive(Clone)]`이 필수입니다.

### 문제 4 정답

`allow_origin(Any)`는 **모든 출처의 요청을 허용**하기 때문에, 악의적인 웹사이트에서도 API를 호출할 수 있게 됩니다. 프로덕션에서는 허용할 도메인만 명시적으로 지정해야 보안을 유지할 수 있습니다.

### 문제 5 정답

```rust
return Err(AppError::BadRequest("잘못된 ID".to_string()));
```

얼리 리턴 패턴으로 `return Err(...)`를 사용합니다. 잘못된 조건을 먼저 확인하고 즉시 반환하면, 나머지 코드는 정상 경로만 처리하면 됩니다.

</details>

---

## 11. 18장 정리

| 배운 것 | 핵심 |
|---------|------|
| 중첩 라우터 | `Router::nest()`로 관련 경로를 그룹화 |
| API 버전 관리 | `nest("/api/v1", ...)`으로 버전별 라우터 분리 |
| 여러 경로 매개변수 | `Path((a, b)): Path<(u32, u32)>` 튜플로 추출 |
| 선택적 쿼리 파라미터 | `Option<T>`으로 감싸면 없어도 에러 안 남 |
| State | `.with_state()`로 등록, `State(state)`로 추출 |
| 미들웨어 | `.layer()`로 추가, 양파 모델로 동작 |
| 로깅 | `TraceLayer` + `tracing` 크레이트 |
| CORS | `CorsLayer`로 브라우저 보안 정책 처리 |
| 에러 처리 | `IntoResponse` 구현으로 통일된 JSON 에러 응답 |
| 얼리 리턴 | 검증 실패 시 `return Err(...)`, 성공 로직은 마지막에 |

---

## 다음 장 예고

> **19장. 데이터베이스 기초**에서는 SQL의 기본 문법과 PostgreSQL 설치를 다룹니다.
> SELECT, INSERT, UPDATE, DELETE를 배우고, SQLx 크레이트를 소개합니다.
> 진짜 데이터를 저장하고 조회하는 웹서버를 만들 준비를 해봅시다!
