# 02장. 변수와 데이터 타입

> **목표**: 변수에 값을 저장하고, Rust의 데이터 타입을 이해한다.

---

## 1. 변수 선언

```rust
fn main() {
    let name = "홍길동";
    let age = 20;
    println!("이름: {}, 나이: {}", name, age);
}
```

`let`으로 변수를 만듭니다. 끝.

---

## 2. 불변과 가변

Rust의 변수는 **기본이 불변(immutable)** 입니다.

```rust
fn main() {
    let x = 5;
    x = 10; // ❌ 에러! 값을 바꿀 수 없음
}
```

값을 바꾸고 싶으면 `mut`를 붙입니다:

```rust
fn main() {
    let mut x = 5;
    println!("x = {}", x); // x = 5

    x = 10;
    println!("x = {}", x); // x = 10
}
```

<details>
<summary><b>🔍 왜 기본이 불변인가요? (원리)</b></summary>

### 불변이 기본인 이유

대부분의 버그는 **"값이 예상치 못하게 바뀌어서"** 생깁니다.

```
함수A가 x를 100으로 설정 → 함수B가 몰래 x를 0으로 변경 → 함수A가 x를 쓰면 → 버그!
```

Rust는 이런 실수를 원천 차단합니다:
- 변하지 않는 변수 → `let` (기본)
- 변해야 하는 변수 → `let mut` (명시적으로 선언)

이렇게 하면 코드를 읽을 때 `mut`가 붙은 변수만 주의하면 됩니다. "이 변수는 어딘가에서 값이 바뀔 수 있구나"라는 신호가 되는 거예요.

컴파일러 입장에서도 불변 변수는 최적화가 훨씬 쉽습니다. 값이 안 바뀌니까 안심하고 효율적인 코드를 만들 수 있거든요.

**정리**: 바뀔 필요 없으면 `let`, 바뀌어야 하면 `let mut`.

</details>

---

## 3. 섀도잉 (Shadowing)

같은 이름으로 변수를 다시 선언할 수 있습니다:

```rust
fn main() {
    let x = 5;
    let x = x + 1;     // 새로운 x = 6
    let x = x * 2;     // 새로운 x = 12

    println!("x = {}", x); // x = 12
}
```

`mut`와 다릅니다. **타입도 바꿀 수 있거든요**:

```rust
fn main() {
    let data = "hello";     // &str 타입
    let data = data.len();  // usize 타입 (글자 수 = 5)

    println!("data = {}", data); // data = 5
}
```

<details>
<summary><b>🔍 mut로 바꾸기 vs 섀도잉, 뭐가 다른가요?</b></summary>

### mut vs 섀도잉 비교

```rust
// mut: 같은 변수의 값을 바꿈 (타입은 고정)
let mut x = 5;
x = 10;       // ✅ 값 변경 가능
x = "hello";  // ❌ 타입을 바꿀 수 없음

// 섀도잉: 아예 새 변수를 만듦 (타입도 변경 가능)
let x = 5;
let x = "hello"; // ✅ 완전히 새로운 변수
```

| | `mut` | 섀도잉 |
|---|---|---|
| 값 변경 | ✅ | ✅ |
| 타입 변경 | ❌ | ✅ |
| 본질 | 같은 변수 수정 | 새 변수 생성 |

섀도잉은 "이전 값은 더 이상 필요 없고, 변환된 결과만 쓸 때" 유용합니다.

</details>

---

## 4. 기본 데이터 타입

### 정수 (Integer)

```rust
fn main() {
    let a: i32 = 100;    // 32비트 정수 (기본)
    let b: i64 = 100;    // 64비트 정수 (더 큰 범위)
    let c: u32 = 100;    // 부호 없는 32비트 (0 이상만)
}
```

| 타입 | 크기 | 범위 | 용도 |
|------|------|------|------|
| `i8` | 1바이트 | -128 ~ 127 | 아주 작은 수 |
| `i16` | 2바이트 | -32,768 ~ 32,767 | 작은 수 |
| **`i32`** | **4바이트** | **약 -21억 ~ 21억** | **기본값, 대부분 이걸 씀** |
| `i64` | 8바이트 | 엄청 큰 범위 | 큰 수가 필요할 때 |
| `u32` | 4바이트 | 0 ~ 약 42억 | 음수가 필요 없을 때 |

> 잘 모르겠으면 그냥 **`i32`** 쓰세요. Rust의 기본값입니다.

<details>
<summary><b>🔍 i와 u의 차이, 숫자는 뭔가요? (원리)</b></summary>

### 정수 타입 이름 규칙

```
i32
│ └─ 32비트 = 4바이트 = 32칸의 0과 1로 숫자를 표현
└── i = integer(정수), signed(부호 있음) = 음수도 가능

u32
│ └─ 32비트
└── u = unsigned(부호 없음) = 0과 양수만
```

### 왜 크기가 여러 개인가요?

컴퓨터 메모리는 유한합니다. 나이(0~150)를 저장하는데 `i64`(8바이트)를 쓰면 낭비예요. `i8`(1바이트)이면 충분합니다.

하지만 일반적인 프로그래밍에서는 이 차이가 거의 의미 없으므로, **대부분 `i32`를 쓰면 됩니다**.

### 비트와 범위의 관계

32비트는 2^32 = 약 42억 가지 숫자를 표현할 수 있습니다.
- `u32`: 0부터 42억까지 전부 양수로 사용
- `i32`: 절반은 음수, 절반은 양수로 사용 (약 -21억 ~ 21억)

</details>

### 실수 (Float)

```rust
fn main() {
    let pi = 3.14;          // f64 (기본)
    let x: f32 = 2.5;       // f32 (메모리 절약, 정밀도 낮음)
}
```

- `f64`: 기본값. 대부분 이걸 씁니다.
- `f32`: 메모리를 아끼고 싶을 때.

### 불리언 (Boolean)

```rust
fn main() {
    let is_student = true;
    let is_adult = false;

    println!("학생인가요? {}", is_student);  // true
    println!("성인인가요? {}", is_adult);    // false
}
```

`true` 또는 `false` 딱 두 가지뿐입니다.

### 문자 (Character)

```rust
fn main() {
    let letter = 'A';
    let korean = '가';
    let emoji = '😊';

    println!("{} {} {}", letter, korean, emoji);
}
```

- **작은따옴표** `' '`로 감쌉니다 (문자열은 큰따옴표 `" "`)
- 한글, 이모지도 가능합니다

---

## 5. 문자열

Rust에는 문자열이 **2종류**입니다.

```rust
fn main() {
    let s1 = "안녕하세요";              // &str (문자열 슬라이스)
    let s2 = String::from("안녕하세요"); // String (소유 문자열)

    println!("{}", s1);
    println!("{}", s2);
}
```

### 간단 비교

| | `&str` | `String` |
|---|---|---|
| 코드에서 | `"안녕"` | `String::from("안녕")` |
| 변경 가능 | ❌ | ✅ |
| 크기 | 고정 | 늘어남 |
| 비유 | 벽에 적힌 글씨 (읽기만) | 노트에 적은 글씨 (수정 가능) |

```rust
fn main() {
    // String은 내용을 바꿀 수 있다
    let mut greeting = String::from("안녕");
    greeting.push_str("하세요!");
    println!("{}", greeting); // 안녕하세요!
}
```

<details>
<summary><b>🔍 왜 문자열이 2종류나 있나요? (원리)</b></summary>

### 메모리 관점에서 이해하기

컴퓨터 메모리에는 두 영역이 있습니다:

```
┌─────────────────────────────┐
│          스택 (Stack)         │  ← 크기가 정해진 것
│  빠르고, 자동으로 정리됨          │
├─────────────────────────────┤
│          힙 (Heap)           │  ← 크기가 변하는 것
│  느리지만, 유연함               │
└─────────────────────────────┘
```

**`&str` (문자열 슬라이스)**
- 프로그램에 직접 박혀있는 글자입니다
- 프로그램이 실행될 때 이미 메모리에 들어가 있습니다
- 크기가 고정이라 변경이 불가능합니다

```rust
let s = "hello"; // 프로그램 바이너리 안에 "hello"가 들어있고, s는 그걸 가리킴
```

**`String` (소유 문자열)**
- 힙 메모리에 저장됩니다
- 실행 중에 크기를 늘리거나 줄일 수 있습니다
- 사용자 입력, API 응답 등 실행 중에 만들어지는 문자열에 사용합니다

```rust
let mut s = String::from("hello"); // 힙에 "hello" 저장
s.push_str(" world");              // 힙에서 공간을 늘려서 " world" 추가
```

### 언제 뭘 쓰나요?

```
코드에 직접 쓴 고정 문자열 → &str
  예: 에러 메시지, 설정값

실행 중에 만들거나 바꾸는 문자열 → String
  예: 사용자 이름, DB에서 읽어온 데이터
```

지금은 헷갈리면 **`String`을 쓰세요**. 나중에 자연스럽게 구분하게 됩니다.

</details>

### &str → String 변환

```rust
fn main() {
    let a: &str = "hello";

    // &str → String (3가지 방법, 결과는 동일)
    let b = String::from("hello");
    let c = "hello".to_string();
    let d = "hello".to_owned();

    // String → &str
    let e: &str = &b;
}
```

---

## 6. 타입 추론과 타입 명시

Rust는 타입을 **알아서 추론**합니다:

```rust
fn main() {
    let x = 5;           // 컴파일러가 i32로 추론
    let y = 3.14;        // 컴파일러가 f64로 추론
    let name = "홍길동";   // 컴파일러가 &str로 추론
    let flag = true;     // 컴파일러가 bool로 추론
}
```

직접 타입을 지정할 수도 있습니다:

```rust
fn main() {
    let x: i64 = 5;          // 명시적으로 i64
    let y: f32 = 3.14;       // 명시적으로 f32
    let name: &str = "홍길동";
    let flag: bool = true;
}
```

> 보통은 추론에 맡기고, **추론이 안 되거나 특정 타입이 필요할 때만 명시**합니다.

---

## 7. 상수 (const)

변수(`let`)와 다른 **상수**도 있습니다:

```rust
const MAX_SCORE: i32 = 100;
const PI: f64 = 3.14159;

fn main() {
    println!("최대 점수: {}", MAX_SCORE);
    println!("원주율: {}", PI);
}
```

| | `let` | `const` |
|---|---|---|
| 타입 명시 | 선택 | **필수** |
| `mut` 가능 | ✅ | ❌ |
| 이름 규칙 | snake_case | **SCREAMING_SNAKE_CASE** |
| 위치 | 함수 안 | 어디서든 (함수 밖도 가능) |

---

## 8. 실습

### 실습 1: 자기소개 프로그램

```rust
fn main() {
    let name = "홍길동";
    let age = 20;
    let height = 175.5;
    let is_student = true;

    println!("=== 자기소개 ===");
    println!("이름: {}", name);
    println!("나이: {}세", age);
    println!("키: {}cm", height);
    println!("학생 여부: {}", is_student);
}
```

**도전**: 자신의 정보로 바꿔서 실행해보세요!

### 실습 2: 간단한 계산기

```rust
fn main() {
    let price = 15000;
    let quantity = 3;
    let total = price * quantity;

    println!("단가: {}원", price);
    println!("수량: {}개", quantity);
    println!("합계: {}원", total);
}
```

**도전**: 할인율 10%를 적용한 최종 가격도 출력해보세요!
(힌트: 실수 타입을 써야 합니다)

### 실습 3: 문자열 조합

```rust
fn main() {
    let first = String::from("Rust");
    let second = String::from("최고!");

    // format! 매크로로 문자열 합치기
    let message = format!("{} {}", first, second);
    println!("{}", message); // Rust 최고!
}
```

---

## 9. 확인 문제

### 문제 1
아래 코드가 에러나는 이유는?
```rust
fn main() {
    let x = 5;
    x = 10;
}
```

### 문제 2
`i32`와 `u32`의 차이점은?

### 문제 3
아래 코드의 출력 결과는?
```rust
fn main() {
    let x = 5;
    let x = x + 10;
    let x = x * 2;
    println!("{}", x);
}
```

### 문제 4
`&str`과 `String`의 차이를 한 문장으로 설명하세요.

### 문제 5
아래 빈칸을 채우세요:
```rust
fn main() {
    let mut count = 0;
    count = count + 1;
    count = count + 1;
    count = count + 1;
    println!("count = {}", count); // count = ???
}
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
`let x`는 불변 변수입니다. `mut`를 붙이지 않았으므로 값을 바꿀 수 없습니다.
수정: `let mut x = 5;`

### 문제 2 정답
- `i32`: 부호 있는 정수. 음수와 양수 모두 가능 (약 -21억 ~ 21억)
- `u32`: 부호 없는 정수. 0과 양수만 가능 (0 ~ 약 42억)

### 문제 3 정답
**`30`**
```
x = 5
x = 5 + 10 = 15  (섀도잉)
x = 15 * 2 = 30  (섀도잉)
```

### 문제 4 정답
`&str`은 고정 크기의 읽기 전용 문자열이고, `String`은 크기를 변경할 수 있는 소유 문자열입니다.

### 문제 5 정답
**`count = 3`**
```
count = 0
count = 0 + 1 = 1
count = 1 + 1 = 2
count = 2 + 1 = 3
```

</details>

---

## 10. 2장 정리

| 배운 것 | 핵심 |
|---------|------|
| 변수 선언 | `let x = 값;` |
| 가변 변수 | `let mut x = 값;` |
| 섀도잉 | 같은 이름으로 `let`을 다시 선언 |
| 정수 | `i32`(기본), `i64`, `u32` 등 |
| 실수 | `f64`(기본), `f32` |
| 불리언 | `true` / `false` |
| 문자 | `'A'` (작은따옴표) |
| 문자열 | `&str`(고정) vs `String`(가변) |
| 타입 추론 | 대부분 Rust가 알아서 추론 |
| 상수 | `const NAME: 타입 = 값;` |

---

## 다음 장 예고

> **03장. 함수와 제어 흐름**에서는 코드를 구조화하는 방법을 배웁니다.
> 함수로 코드를 쪼개고, if/else와 반복문으로 프로그램의 흐름을 제어합니다!
