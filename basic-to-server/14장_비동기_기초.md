# 14장. 비동기 기초

> **목표**: 비동기 프로그래밍의 개념을 이해하고, async/await를 사용할 수 있다.

> **웹서버의 핵심!** 이 장부터 진짜 웹 개발 준비가 시작됩니다.

---

## 1. 동기 vs 비동기

### 동기(Synchronous): 줄 서서 기다리기

동기 방식은 **한 작업이 끝나야 다음 작업**을 시작합니다.

```
커피숍 예시 (동기):

1. 주문한다
2. 커피가 나올 때까지 카운터 앞에서 기다린다 (아무것도 못 함)
3. 커피를 받는다
4. 그제서야 다음 일을 한다
```

코드로 보면 이렇습니다:

```rust
fn main() {
    let data1 = fetch_from_db();      // 3초 대기...
    let data2 = fetch_from_api();     // 2초 대기...
    let data3 = read_file();          // 1초 대기...
    // 총 6초 걸림 (3 + 2 + 1)
}
```

### 비동기(Asynchronous): 진동벨 받고 다른 일 하기

비동기 방식은 **기다리는 동안 다른 작업**을 합니다.

```
커피숍 예시 (비동기):

1. 주문한다
2. 진동벨을 받는다
3. 자리에 앉아서 다른 일을 한다 (노트북 작업, 책 읽기 등)
4. 진동벨이 울리면 커피를 받으러 간다
```

```rust
async fn main() {
    // 세 작업을 동시에 시작!
    let (data1, data2, data3) = tokio::join!(
        fetch_from_db(),    // 3초
        fetch_from_api(),   // 2초
        read_file(),        // 1초
    );
    // 총 3초 걸림 (가장 느린 작업 시간)
}
```

### 왜 웹서버에 비동기가 필요한가?

웹서버는 대부분의 시간을 **기다리는 데** 씁니다.

```
웹서버가 하는 일:

1. 클라이언트 요청 받기         (0.001초)
2. 데이터베이스에서 데이터 조회   (50ms 대기)   ← I/O 대기
3. 외부 API 호출               (200ms 대기)   ← I/O 대기
4. 응답 보내기                  (0.001초)
```

동기 방식이면 요청 하나를 처리하는 동안 다른 사용자는 **줄을 서서 기다려야** 합니다. 1000명이 동시에 접속하면? 재앙입니다.

비동기 방식이면 데이터베이스 응답을 기다리는 동안 **다른 사용자의 요청을 처리**할 수 있습니다. 같은 서버로 훨씬 많은 사용자를 감당합니다.

> 웹서버에서 비동기는 선택이 아니라 **필수**입니다. CPU가 놀지 않고 일하게 만드는 것이 핵심입니다.

---

## 2. async / await 문법

### async fn으로 비동기 함수 정의

`async` 키워드를 함수 앞에 붙이면 비동기 함수가 됩니다.

```rust
// 일반 함수
fn greet() -> String {
    "안녕하세요".to_string()
}

// 비동기 함수
async fn greet_async() -> String {
    "안녕하세요".to_string()
}
```

### .await로 결과 기다리기

비동기 함수를 호출할 때는 `.await`를 붙여야 실제로 실행됩니다.

```rust
async fn fetch_data() -> String {
    // 네트워크 요청 시뮬레이션
    "서버에서 받은 데이터".to_string()
}

async fn main_logic() {
    let data = fetch_data().await;  // .await로 결과를 기다림
    println!("{}", data);           // 서버에서 받은 데이터
}
```

**핵심 포인트**:
- `fetch_data()` 만 호출하면 **아직 실행되지 않습니다** (Future를 반환할 뿐)
- `.await`를 붙여야 **실제로 실행**되고 결과를 받습니다
- `.await`는 **async 함수 안에서만** 쓸 수 있습니다

### async fn은 Future를 반환한다

`async fn`은 호출하면 곧바로 실행되는 게 아니라, **"나중에 실행할 작업"을 반환**합니다. 이것을 `Future`라고 부릅니다.

```rust
async fn fetch_data() -> String {
    "데이터".to_string()
}

async fn example() {
    // fetch_data()는 String이 아니라 Future를 반환!
    let future = fetch_data();      // 아직 실행 안 됨 (게으른 평가)
    let data = future.await;        // 이제 실행됨
    println!("{}", data);
}
```

```
비유:

async fn fetch_data() → "피자 주문서"를 만듦 (아직 피자를 만들지 않음)
fetch_data().await   → 주문서를 주방에 넘기고, 피자가 나올 때까지 기다림
```

<details>
<summary><b>Future 트레이트가 뭔가? (원리)</b></summary>

### Future 트레이트

`Future`는 Rust 표준 라이브러리에 정의된 트레이트입니다:

```rust
// 표준 라이브러리의 간략화된 정의
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),    // 작업 완료! 결과값이 있음
    Pending,     // 아직 안 끝남, 나중에 다시 확인해줘
}
```

### 동작 원리

```
1회차 poll() → Pending  (아직 데이터 안 옴)
2회차 poll() → Pending  (아직...)
3회차 poll() → Ready("데이터")  (완료!)
```

런타임(Tokio)이 Future를 **반복적으로 poll**합니다:
1. `Pending`이 나오면 → 다른 작업을 처리하러 감
2. `Ready(값)`이 나오면 → 결과를 반환

이것이 비동기의 핵심입니다. `Pending` 상태일 때 CPU가 **다른 일**을 할 수 있습니다.

### async/await는 컴파일러 마법

`async fn`을 쓰면 컴파일러가 자동으로 `Future`를 구현하는 코드를 만들어줍니다. 직접 `poll()`을 구현할 필요가 없습니다.

```rust
// 우리가 쓰는 코드
async fn fetch_data() -> String {
    "데이터".to_string()
}

// 컴파일러가 대략 이렇게 변환 (실제로는 더 복잡함)
fn fetch_data() -> impl Future<Output = String> {
    // ... 상태 머신 생성 ...
}
```

지금은 "async/await가 Future를 편하게 다루는 문법"이라는 점만 기억하면 됩니다.

</details>

---

## 3. Tokio 런타임 소개

### Rust 자체에는 비동기 실행기가 없다

Rust는 `async/await` **문법**은 제공하지만, 실제로 비동기 코드를 **실행해주는 엔진**은 포함하지 않습니다.

```
비유:

async/await = 자동차의 핸들과 페달 (인터페이스)
Tokio       = 자동차의 엔진 (실제로 굴러가게 하는 것)

핸들만 있으면 차가 안 굴러가듯, async/await만으로는 비동기 코드가 실행되지 않습니다.
```

### Tokio = 가장 인기 있는 비동기 런타임

Tokio는 Rust 생태계에서 **사실상 표준**인 비동기 런타임입니다. Axum, Actix-web 등 대부분의 웹 프레임워크가 Tokio 위에서 동작합니다.

### 설치: Cargo.toml에 tokio 추가

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
```

> `features = ["full"]`은 Tokio의 모든 기능을 사용하겠다는 뜻입니다. 학습 중에는 이렇게 쓰고, 프로덕션에서는 필요한 기능만 켜는 게 좋습니다.

### #[tokio::main] 매크로

일반 `main` 함수는 `async`가 될 수 없습니다. `#[tokio::main]`을 붙이면 Tokio가 비동기 `main`을 실행해줍니다.

```rust
use tokio;

async fn fetch_data() -> String {
    "서버 데이터".to_string()
}

#[tokio::main]
async fn main() {
    println!("비동기 시작!");
    let result = fetch_data().await;
    println!("결과: {}", result);
}
```

```
출력:
비동기 시작!
결과: 서버 데이터
```

<details>
<summary><b>#[tokio::main]이 실제로 하는 일 (원리)</b></summary>

`#[tokio::main]`은 매크로입니다. 컴파일 시 코드를 자동 변환합니다:

```rust
// 우리가 쓴 코드
#[tokio::main]
async fn main() {
    println!("안녕!");
}

// 매크로가 변환한 실제 코드
fn main() {
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async {
            println!("안녕!");
        })
}
```

`block_on()`이 비동기 코드를 실행하는 진입점입니다. Tokio 런타임을 생성하고, 그 위에서 async 블록을 실행합니다.

</details>

---

## 4. 동기 vs 스레드 vs 비동기 비교

| | 동기 | 스레드 | 비동기 |
|---|---|---|---|
| 동시 처리 | 불가 | 가능 | 가능 |
| 메모리 사용 | 적음 | 많음 (스레드당 수 MB) | 적음 (태스크당 수 KB) |
| I/O 대기 | CPU가 놀고 있음 | 스레드마다 각자 대기 | 대기 중 다른 일 처리 |
| 생성 비용 | 없음 | 높음 (OS 호출) | 낮음 (가벼운 태스크) |
| 적합한 상황 | 간단한 스크립트 | CPU 집약 작업 | 웹서버, I/O 많은 작업 |

### 코드로 비교

**동기 방식**:

```rust
fn main() {
    let a = do_work_a(); // 2초 대기
    let b = do_work_b(); // 2초 대기
    // 총 4초
}
```

**스레드 방식**:

```rust
use std::thread;

fn main() {
    let handle_a = thread::spawn(|| do_work_a()); // 2초
    let handle_b = thread::spawn(|| do_work_b()); // 2초 (동시 실행)

    let a = handle_a.join().unwrap();
    let b = handle_b.join().unwrap();
    // 총 2초 (동시에 실행했으니까)
}
```

**비동기 방식**:

```rust
#[tokio::main]
async fn main() {
    let (a, b) = tokio::join!(
        do_work_a(), // 2초
        do_work_b(), // 2초 (동시 실행)
    );
    // 총 2초 (동시에 실행했으니까) + 메모리 훨씬 적게 사용
}
```

> 스레드와 비동기 모두 동시 실행이 가능하지만, **웹서버처럼 수천 개의 동시 연결**을 처리할 때는 비동기가 훨씬 효율적입니다. 스레드 1만 개를 만들면 메모리가 수십 GB 필요하지만, 비동기 태스크 1만 개는 수십 MB면 됩니다.

<details>
<summary><b>OS 스레드 vs 그린 스레드 vs async 태스크 (원리)</b></summary>

### 세 가지 동시성 모델

**1. OS 스레드** (std::thread)
- 운영체제가 직접 관리하는 스레드
- 스레드당 **1~8MB 스택 메모리** 할당
- 스레드 전환(context switch)에 비용이 큼
- 동시에 수백~수천 개가 한계

```
OS 스레드:
[스레드1: 8MB] [스레드2: 8MB] [스레드3: 8MB] ...
→ 1000개 = 약 8GB 메모리
```

**2. 그린 스레드** (Go의 goroutine 등)
- 런타임이 관리하는 경량 스레드
- 작은 스택으로 시작하여 필요시 확장
- Go 언어가 대표적

**3. async 태스크** (Tokio)
- 스택을 아예 사용하지 않음 (상태 머신으로 변환)
- 태스크당 **수 KB** 정도
- 수십만 개의 동시 태스크 가능

```
async 태스크:
[태스크1: 몇KB] [태스크2: 몇KB] [태스크3: 몇KB] ...
→ 100,000개 = 약 수십 MB 메모리
```

### Rust가 async를 선택한 이유

Rust는 "비용을 지불하지 않으면 사용하지 않는다(zero-cost abstractions)" 철학을 따릅니다. 그린 스레드는 사용하지 않더라도 런타임 비용이 발생합니다. async는 사용할 때만 비용이 생기므로, Rust의 철학에 더 맞습니다.

</details>

---

## 5. 첫 비동기 프로그램

### 타이머 예제: tokio::time::sleep

`tokio::time::sleep`은 비동기적으로 지정한 시간만큼 대기합니다. 네트워크 요청이나 DB 조회를 시뮬레이션할 때 유용합니다.

```rust
use std::time::Duration;
use tokio::time::sleep;

async fn make_coffee() -> String {
    println!("커피 제조 시작...");
    sleep(Duration::from_secs(2)).await;  // 2초 대기
    println!("커피 완성!");
    "아메리카노".to_string()
}

#[tokio::main]
async fn main() {
    println!("주문을 받았습니다.");
    let coffee = make_coffee().await;
    println!("음료: {}", coffee);
}
```

```
출력:
주문을 받았습니다.
커피 제조 시작...
(2초 후)
커피 완성!
음료: 아메리카노
```

> **주의**: `std::thread::sleep`이 아니라 **`tokio::time::sleep`**을 써야 합니다. `std::thread::sleep`은 스레드 전체를 멈추지만, `tokio::time::sleep`은 현재 태스크만 대기시키고 다른 태스크가 실행될 수 있게 합니다.

### 여러 작업 동시 실행: tokio::join!

`tokio::join!`을 쓰면 여러 비동기 작업을 **동시에** 실행할 수 있습니다.

```rust
use std::time::Duration;
use tokio::time::sleep;

async fn make_coffee() -> String {
    println!("[커피] 제조 시작...");
    sleep(Duration::from_secs(3)).await;
    println!("[커피] 완성!");
    "아메리카노".to_string()
}

async fn make_sandwich() -> String {
    println!("[샌드위치] 제조 시작...");
    sleep(Duration::from_secs(2)).await;
    println!("[샌드위치] 완성!");
    "클럽 샌드위치".to_string()
}

async fn pour_juice() -> String {
    println!("[주스] 제조 시작...");
    sleep(Duration::from_secs(1)).await;
    println!("[주스] 완성!");
    "오렌지 주스".to_string()
}

#[tokio::main]
async fn main() {
    println!("=== 순서대로 만들기 (동기식) ===");
    let start = std::time::Instant::now();

    let coffee = make_coffee().await;
    let sandwich = make_sandwich().await;
    let juice = pour_juice().await;

    println!("소요 시간: {:?}", start.elapsed()); // 약 6초
    println!("{}, {}, {}\n", coffee, sandwich, juice);

    println!("=== 동시에 만들기 (비동기식) ===");
    let start = std::time::Instant::now();

    let (coffee, sandwich, juice) = tokio::join!(
        make_coffee(),
        make_sandwich(),
        pour_juice(),
    );

    println!("소요 시간: {:?}", start.elapsed()); // 약 3초 (가장 느린 작업 시간)
    println!("{}, {}, {}", coffee, sandwich, juice);
}
```

```
출력 (대략):
=== 순서대로 만들기 (동기식) ===
[커피] 제조 시작...
[커피] 완성!
[샌드위치] 제조 시작...
[샌드위치] 완성!
[주스] 제조 시작...
[주스] 완성!
소요 시간: 6.00s
아메리카노, 클럽 샌드위치, 오렌지 주스

=== 동시에 만들기 (비동기식) ===
[커피] 제조 시작...
[샌드위치] 제조 시작...
[주스] 제조 시작...
[주스] 완성!
[샌드위치] 완성!
[커피] 완성!
소요 시간: 3.00s
아메리카노, 클럽 샌드위치, 오렌지 주스
```

동시에 만들면 **가장 오래 걸리는 작업(3초)** 만큼만 기다리면 됩니다. 6초가 3초로 줄었습니다!

---

## 6. 실습

### 실습 1: 기본 async 함수 만들고 호출하기

두 개의 비동기 함수를 만들어서 순서대로 호출하세요.

```rust
// Cargo.toml에 tokio 추가 필요:
// [dependencies]
// tokio = { version = "1", features = ["full"] }

use tokio;

// 여기에 코드를 작성하세요!
// 1. async fn greet(name: &str) -> String 함수를 만드세요
//    - "안녕하세요, {name}님!" 형태의 문자열을 반환
// 2. async fn add(a: i32, b: i32) -> i32 함수를 만드세요
//    - 두 수의 합을 반환
// 3. main에서 두 함수를 .await로 호출하고 결과를 출력하세요

// 예상 출력:
// 인사: 안녕하세요, 홍길동님!
// 합계: 30
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use tokio;

async fn greet(name: &str) -> String {
    format!("안녕하세요, {}님!", name)
}

async fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[tokio::main]
async fn main() {
    let message = greet("홍길동").await;
    println!("인사: {}", message);

    let sum = add(10, 20).await;
    println!("합계: {}", sum);
}
```

</details>

### 실습 2: tokio::time::sleep으로 지연 시뮬레이션

DB 조회와 API 호출을 시뮬레이션하는 비동기 함수를 만들고, 순서대로 실행한 시간과 동시 실행한 시간을 비교하세요.

```rust
use std::time::{Duration, Instant};
use tokio::time::sleep;

// 여기에 코드를 작성하세요!
// 1. async fn query_db() -> String 함수를 만드세요
//    - "DB 조회 시작" 출력
//    - 2초 대기 (sleep)
//    - "DB 조회 완료" 출력
//    - "사용자 목록" 문자열 반환
//
// 2. async fn call_api() -> String 함수를 만드세요
//    - "API 호출 시작" 출력
//    - 1초 대기 (sleep)
//    - "API 호출 완료" 출력
//    - "날씨 정보" 문자열 반환
//
// 3. main에서:
//    - 순서대로 실행하고 소요 시간 출력 (약 3초)
//    - tokio::join!으로 동시에 실행하고 소요 시간 출력 (약 2초)

// 예상 출력:
// === 순서대로 실행 ===
// DB 조회 시작
// DB 조회 완료
// API 호출 시작
// API 호출 완료
// 소요 시간: 약 3초
//
// === 동시 실행 ===
// DB 조회 시작
// API 호출 시작
// API 호출 완료
// DB 조회 완료
// 소요 시간: 약 2초
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use std::time::{Duration, Instant};
use tokio::time::sleep;

async fn query_db() -> String {
    println!("DB 조회 시작");
    sleep(Duration::from_secs(2)).await;
    println!("DB 조회 완료");
    "사용자 목록".to_string()
}

async fn call_api() -> String {
    println!("API 호출 시작");
    sleep(Duration::from_secs(1)).await;
    println!("API 호출 완료");
    "날씨 정보".to_string()
}

#[tokio::main]
async fn main() {
    println!("=== 순서대로 실행 ===");
    let start = Instant::now();
    let db_result = query_db().await;
    let api_result = call_api().await;
    println!("결과: {}, {}", db_result, api_result);
    println!("소요 시간: {:.1}초\n", start.elapsed().as_secs_f64());

    println!("=== 동시 실행 ===");
    let start = Instant::now();
    let (db_result, api_result) = tokio::join!(
        query_db(),
        call_api(),
    );
    println!("결과: {}, {}", db_result, api_result);
    println!("소요 시간: {:.1}초", start.elapsed().as_secs_f64());
}
```

</details>

### 실습 3: 여러 async 함수를 순서대로 호출하기

웹서버의 요청 처리 흐름을 시뮬레이션하세요. 각 단계는 이전 단계의 결과를 사용합니다.

```rust
use std::time::Duration;
use tokio::time::sleep;

// 여기에 코드를 작성하세요!
// 1. async fn authenticate(token: &str) -> Result<String, String>
//    - 0.5초 대기
//    - token이 "valid-token"이면 Ok("홍길동") 반환
//    - 아니면 Err("인증 실패") 반환
//
// 2. async fn fetch_user_data(username: &str) -> String
//    - 1초 대기
//    - "{username}의 프로필 데이터" 반환
//
// 3. async fn generate_response(data: &str) -> String
//    - 0.3초 대기
//    - "응답: {data}" 반환
//
// 4. main에서 세 함수를 순서대로 호출하세요
//    - authenticate가 실패하면 에러를 출력하고 종료 (얼리 리턴)
//    - 성공하면 다음 단계로 진행

// 예상 출력 (성공 시):
// [1단계] 인증 중...
// [2단계] 데이터 조회 중...
// [3단계] 응답 생성 중...
// 최종 결과: 응답: 홍길동의 프로필 데이터
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use std::time::Duration;
use tokio::time::sleep;

async fn authenticate(token: &str) -> Result<String, String> {
    println!("[1단계] 인증 중...");
    sleep(Duration::from_millis(500)).await;

    if token != "valid-token" {
        return Err("인증 실패: 유효하지 않은 토큰".to_string());
    }
    Ok("홍길동".to_string())
}

async fn fetch_user_data(username: &str) -> String {
    println!("[2단계] 데이터 조회 중...");
    sleep(Duration::from_secs(1)).await;
    format!("{}의 프로필 데이터", username)
}

async fn generate_response(data: &str) -> String {
    println!("[3단계] 응답 생성 중...");
    sleep(Duration::from_millis(300)).await;
    format!("응답: {}", data)
}

#[tokio::main]
async fn main() {
    // 얼리 리턴: 인증 실패 시 바로 종료
    let username = match authenticate("valid-token").await {
        Ok(name) => name,
        Err(e) => {
            println!("에러: {}", e);
            return;
        }
    };

    let data = fetch_user_data(&username).await;
    let response = generate_response(&data).await;
    println!("최종 결과: {}", response);
}
```

**도전**: `authenticate`에 잘못된 토큰 `"bad-token"`을 넣어서 에러 처리가 동작하는지 확인해보세요!

</details>

---

## 7. 확인 문제

### 문제 1
동기와 비동기의 가장 큰 차이점은 무엇인가요?

### 문제 2
아래 코드에서 잘못된 부분을 찾으세요:
```rust
async fn get_data() -> String {
    "데이터".to_string()
}

fn main() {
    let data = get_data().await;
    println!("{}", data);
}
```

### 문제 3
`tokio::time::sleep`과 `std::thread::sleep`의 차이점은?

### 문제 4
아래 코드의 실행 시간은 대략 몇 초인가요?
```rust
use std::time::Duration;
use tokio::time::sleep;

async fn task_a() {
    sleep(Duration::from_secs(3)).await;
}

async fn task_b() {
    sleep(Duration::from_secs(2)).await;
}

#[tokio::main]
async fn main() {
    tokio::join!(task_a(), task_b());
}
```

### 문제 5
다음 중 비동기 프로그래밍에 대한 설명으로 **틀린 것**은?
- (a) `async fn`은 호출하면 즉시 실행된다
- (b) `.await`는 `async fn` 안에서만 사용할 수 있다
- (c) Tokio는 Rust의 비동기 런타임이다
- (d) 비동기는 I/O가 많은 작업에 적합하다

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
동기는 **한 작업이 끝나야 다음 작업을 시작**합니다. 비동기는 **기다리는 동안 다른 작업을 처리**할 수 있습니다. 웹서버처럼 I/O 대기가 많은 환경에서는 비동기가 CPU를 효율적으로 활용합니다.

### 문제 2 정답
`main` 함수가 `async fn`이 아닙니다. `.await`는 async 함수 안에서만 쓸 수 있습니다.

수정:
```rust
#[tokio::main]
async fn main() {
    let data = get_data().await;
    println!("{}", data);
}
```

`#[tokio::main]`을 붙이고 `main`을 `async fn`으로 바꿔야 합니다.

### 문제 3 정답

| | `tokio::time::sleep` | `std::thread::sleep` |
|---|---|---|
| 방식 | 현재 **태스크**만 대기 | **스레드 전체**를 멈춤 |
| 다른 작업 | 대기 중 다른 태스크 실행 가능 | 대기 중 아무것도 못 함 |
| 사용 위치 | async 함수 안에서 | 어디서든 |

async 코드에서 `std::thread::sleep`을 쓰면 **전체 런타임이 멈출 수 있으므로** 반드시 `tokio::time::sleep`을 사용해야 합니다.

### 문제 4 정답
**약 3초**

`tokio::join!`은 두 작업을 동시에 실행합니다. `task_a`(3초)와 `task_b`(2초)가 동시에 시작되므로, 더 오래 걸리는 `task_a`의 3초가 전체 실행 시간입니다. (3 + 2 = 5초가 아닙니다!)

### 문제 5 정답
**(a) `async fn`은 호출하면 즉시 실행된다**

`async fn`은 호출하면 **즉시 실행되지 않습니다**. `Future`를 반환할 뿐이고, `.await`를 해야 실제로 실행됩니다. 이것을 "게으른 평가(lazy evaluation)"라고 합니다.

</details>

---

## 8. 14장 정리

| 배운 것 | 핵심 |
|---------|------|
| 동기 vs 비동기 | 동기는 순차 실행, 비동기는 대기 중 다른 작업 처리 |
| async fn | `async fn name() -> T`로 비동기 함수 정의 |
| .await | 비동기 함수의 결과를 기다림, async 안에서만 사용 가능 |
| Future | async fn이 반환하는 "나중에 완료될 작업" |
| Tokio | Rust의 비동기 런타임, `tokio = { version = "1", features = ["full"] }` |
| #[tokio::main] | main 함수를 비동기로 실행하게 해주는 매크로 |
| tokio::time::sleep | 비동기 타이머, `std::thread::sleep` 대신 사용 |
| tokio::join! | 여러 비동기 작업을 동시에 실행 |
| 비동기 vs 스레드 | 비동기가 메모리 효율적, 웹서버에 적합 |

---

## 다음 장 예고

> **15장. Tokio 심화**에서는 Tokio의 핵심 기능을 더 깊이 배웁니다.
> `tokio::spawn`으로 독립적인 태스크를 만들고, `select!`로 여러 작업 중 먼저 끝나는 것을 처리하고, 비동기 채널로 태스크 간 통신하는 법을 알아봅니다!
