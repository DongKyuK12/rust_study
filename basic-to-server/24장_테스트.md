# 24장. 테스트

> **목표**: 단위 테스트, 통합 테스트, API 테스트를 작성할 수 있다.

> 테스트는 코드의 안전벨트입니다! 한 번 작성하면 리팩토링할 때마다 자동으로 코드를 검증해줍니다.

---

## 1. 왜 테스트를 작성하나?

### 테스트 없이 개발하면 생기는 일

```
테스트 없는 개발:

1. 기능 A를 만든다
2. 잘 동작한다
3. 기능 B를 추가한다
4. 기능 A가 깨진다 (모른 채 배포)
5. 사용자가 버그를 발견한다
6. 야근한다
```

### 테스트가 있으면

```
테스트 있는 개발:

1. 기능 A를 만들고 테스트를 작성한다
2. 기능 B를 추가한다
3. cargo test 실행 → 기능 A 테스트 실패!
4. 문제를 바로 발견하고 수정한다
5. 안심하고 배포한다
```

### 테스트를 작성하는 이유 정리

| 이유 | 설명 |
|------|------|
| 자동 검증 | 코드가 의도대로 동작하는지 자동으로 확인 |
| 안전망 | 리팩토링할 때 기존 기능이 깨지지 않는지 보장 |
| 버그 재발 방지 | 한 번 고친 버그가 다시 발생하면 테스트가 잡아냄 |
| 문서 역할 | 테스트 코드를 보면 함수가 어떻게 동작하는지 알 수 있음 |

### 실행 방법

```bash
cargo test
```

이 한 줄이면 프로젝트의 모든 테스트가 실행됩니다.

---

## 2. 단위 테스트

단위 테스트는 **함수 하나, 모듈 하나**를 독립적으로 검증하는 테스트입니다. 가장 기본적이고 가장 많이 작성하는 테스트입니다.

### #[cfg(test)]와 #[test]

```rust
// 테스트 대상 함수
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn is_even(n: i32) -> bool {
    n % 2 == 0
}

// 테스트 모듈
#[cfg(test)]
mod tests {
    use super::*;  // 위의 함수들을 가져옴

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }

    #[test]
    fn test_is_even() {
        assert!(is_even(4));
        assert!(!is_even(3));
    }
}
```

```
실행 결과:
running 3 tests
test tests::test_add ... ok
test tests::test_add_negative ... ok
test tests::test_is_even ... ok

test result: ok. 3 passed; 0 failed; 0 ignored
```

핵심 포인트:
- `#[cfg(test)]` : 이 모듈은 `cargo test` 실행 시에만 컴파일됩니다. 릴리즈 빌드에는 포함되지 않습니다.
- `#[test]` : 이 함수가 테스트 함수임을 표시합니다.
- `use super::*` : 부모 모듈(테스트 대상)의 모든 항목을 가져옵니다.

### assert 매크로 3가지

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn assert_examples() {
        // assert!: 조건이 true인지 확인
        assert!(1 + 1 == 2);
        assert!(true);

        // assert_eq!: 두 값이 같은지 확인
        assert_eq!(2 + 2, 4);
        assert_eq!("hello", "hello");

        // assert_ne!: 두 값이 다른지 확인
        assert_ne!(2 + 2, 5);
        assert_ne!("hello", "world");
    }

    #[test]
    fn assert_with_message() {
        let result = 2 + 2;
        // 실패 시 출력될 메시지를 추가할 수 있음
        assert_eq!(result, 4, "2 + 2는 4여야 하는데 {}이 나왔습니다", result);
    }
}
```

| 매크로 | 용도 | 실패 조건 |
|--------|------|-----------|
| `assert!(조건)` | 조건이 true인지 확인 | 조건이 false일 때 |
| `assert_eq!(a, b)` | 두 값이 같은지 확인 | a와 b가 다를 때 |
| `assert_ne!(a, b)` | 두 값이 다른지 확인 | a와 b가 같을 때 |

### 테스트 이름 짓기

테스트 이름은 **무엇을 테스트하는지** 명확하게 드러나야 합니다.

```rust
#[cfg(test)]
mod tests {
    use super::*;

    // 패턴: test_함수이름_시나리오
    #[test]
    fn test_add_positive_numbers() { ... }

    #[test]
    fn test_add_negative_numbers() { ... }

    #[test]
    fn test_add_zero() { ... }

    // 패턴: 함수이름_should_기대결과
    #[test]
    fn validate_email_should_reject_empty_string() { ... }

    #[test]
    fn validate_email_should_accept_valid_format() { ... }
}
```

### should_panic 테스트

`panic!`이 발생해야 하는 상황을 테스트할 수 있습니다.

```rust
fn divide(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("0으로 나눌 수 없습니다");
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn test_divide_by_zero() {
        divide(10, 0);  // panic이 발생해야 테스트 통과
    }

    #[test]
    #[should_panic(expected = "0으로 나눌 수 없습니다")]
    fn test_divide_by_zero_message() {
        divide(10, 0);  // 특정 panic 메시지가 포함되어야 통과
    }
}
```

### Result를 반환하는 테스트

`?` 연산자를 테스트에서도 쓸 수 있습니다.

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn test_parse_number() -> Result<(), String> {
        let number: i32 = "42".parse().map_err(|e| format!("{}", e))?;
        assert_eq!(number, 42);
        Ok(())
    }
}
```

`Result`를 반환하면 `Err`가 반환될 때 테스트가 실패합니다. `assert!` 매크로 대신 `?`로 깔끔하게 에러를 처리할 수 있습니다.

<details>
<summary><b>단위 테스트의 원칙 (원리)</b></summary>

### 좋은 단위 테스트의 특징

**FIRST 원칙**:

| 원칙 | 영문 | 설명 |
|------|------|------|
| 빠르게 | Fast | 몇 초 안에 전체가 실행되어야 함 |
| 독립적 | Independent | 테스트 순서에 의존하지 않아야 함 |
| 반복 가능 | Repeatable | 몇 번을 실행해도 같은 결과 |
| 자체 검증 | Self-Validating | pass/fail이 자동으로 판단됨 |
| 적시에 | Timely | 코드 작성과 함께 테스트도 작성 |

### 하나의 테스트에는 하나의 검증

```rust
// 나쁜 예: 한 테스트에 검증이 너무 많음
#[test]
fn test_user_everything() {
    let user = create_user("kim", "kim@email.com");
    assert_eq!(user.name, "kim");
    assert_eq!(user.email, "kim@email.com");
    assert!(user.is_active);
    assert_eq!(user.role, "member");
    // 하나가 실패하면 나머지는 확인도 못 함
}

// 좋은 예: 검증을 분리
#[test]
fn test_create_user_sets_name() {
    let user = create_user("kim", "kim@email.com");
    assert_eq!(user.name, "kim");
}

#[test]
fn test_create_user_sets_email() {
    let user = create_user("kim", "kim@email.com");
    assert_eq!(user.email, "kim@email.com");
}

#[test]
fn test_create_user_is_active_by_default() {
    let user = create_user("kim", "kim@email.com");
    assert!(user.is_active);
}
```

하나의 테스트가 실패하면, 그 테스트 이름만 보고도 **어떤 기능이 깨졌는지** 바로 알 수 있어야 합니다.

</details>

---

## 3. 통합 테스트

통합 테스트는 **외부 사용자 관점**에서 코드를 테스트합니다. 라이브러리의 공개 API만 사용하여 여러 모듈이 함께 잘 동작하는지 확인합니다.

### tests/ 디렉토리

통합 테스트는 프로젝트 루트의 `tests/` 디렉토리에 작성합니다.

```
my_project/
├── Cargo.toml
├── src/
│   ├── lib.rs      ← 라이브러리 코드
│   └── main.rs     ← 바이너리 진입점
└── tests/
    ├── health_check.rs    ← 통합 테스트 파일 1
    └── user_api.rs        ← 통합 테스트 파일 2
```

### 통합 테스트 작성

`src/lib.rs`에 공개 함수가 있다고 가정합니다:

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn validate_email(email: &str) -> Result<(), String> {
    if email.is_empty() {
        return Err("이메일을 입력하세요".to_string());
    }
    if !email.contains('@') {
        return Err("올바른 이메일 형식이 아닙니다".to_string());
    }
    Ok(())
}
```

통합 테스트 파일을 만듭니다:

```rust
// tests/math_test.rs
use my_project::add;  // 크레이트 이름으로 import

#[test]
fn test_add_from_outside() {
    assert_eq!(add(10, 20), 30);
}
```

```rust
// tests/validation_test.rs
use my_project::validate_email;

#[test]
fn test_valid_email() {
    assert!(validate_email("user@example.com").is_ok());
}

#[test]
fn test_empty_email() {
    let result = validate_email("");
    assert!(result.is_err());
}

#[test]
fn test_email_without_at() {
    let result = validate_email("invalid-email");
    assert!(result.is_err());
}
```

### 단위 테스트 vs 통합 테스트

| 비교 | 단위 테스트 | 통합 테스트 |
|------|------------|------------|
| 위치 | `src/` 파일 안 `#[cfg(test)]` 모듈 | `tests/` 디렉토리 |
| 접근 범위 | 비공개(private) 함수도 테스트 가능 | 공개(pub) 함수만 테스트 |
| 관점 | 개발자 관점 (내부 구현) | 사용자 관점 (외부 API) |
| 목적 | 함수/모듈이 올바른지 확인 | 모듈 간 상호작용이 올바른지 확인 |
| `#[cfg(test)]` | 필요 | 불필요 (tests/ 자체가 테스트) |

<details>
<summary><b>테스트 피라미드: 단위 vs 통합 vs E2E (원리)</b></summary>

### 테스트 피라미드

테스트는 세 가지 계층으로 나뉩니다. 아래에서 위로 갈수록 비용이 높아지지만 현실적인 검증을 합니다.

```
         /  E2E 테스트  \        ← 느림, 비쌈, 현실적
        / (브라우저 테스트) \
       /-------------------\
      /    통합 테스트       \     ← 중간 속도, API 간 상호작용
     / (API 엔드포인트 테스트) \
    /-------------------------\
   /       단위 테스트          \   ← 빠름, 저렴, 함수 단위
  /  (함수, 모듈 개별 테스트)    \
 /-------------------------------\
```

**단위 테스트** (가장 많이):
- 함수 하나를 독립적으로 테스트
- 밀리초 단위로 빠르게 실행
- 버그 위치를 정확히 알려줌

**통합 테스트** (적당히):
- 여러 모듈이 함께 동작하는지 테스트
- API 엔드포인트가 올바른 응답을 반환하는지 확인
- 단위 테스트보다 느리지만 더 현실적

**E2E(End-to-End) 테스트** (최소한으로):
- 실제 사용자 시나리오를 처음부터 끝까지 테스트
- 브라우저를 띄워서 클릭하고 확인
- 가장 느리고 깨지기 쉽지만, 전체 시스템이 동작하는지 확인

**비율 권장**: 단위 70% / 통합 20% / E2E 10%

웹서버 프로젝트에서는 **단위 테스트 + API 통합 테스트**에 집중하는 것이 실용적입니다.

</details>

---

## 4. API 테스트

웹서버를 만들었다면 **HTTP 엔드포인트가 올바르게 동작하는지** 테스트해야 합니다. Axum은 실제 서버를 띄우지 않고도 요청을 시뮬레이션할 수 있는 방법을 제공합니다.

### 필요한 의존성

```toml
# Cargo.toml
[dependencies]
axum = "0.8"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"

[dev-dependencies]
tower = { version = "0.5", features = ["util"] }
http-body-util = "0.1"
```

> `[dev-dependencies]`는 테스트 코드에서만 사용하는 의존성입니다. 릴리즈 빌드에는 포함되지 않습니다.

### 기본 API 테스트

```rust
use axum::{routing::get, Router, Json};
use serde::Serialize;

#[derive(Serialize)]
struct Health {
    status: String,
}

async fn health_check() -> Json<Health> {
    Json(Health {
        status: "ok".to_string(),
    })
}

fn create_app() -> Router {
    Router::new()
        .route("/health", get(health_check))
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::{Request, StatusCode};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_health_check_status() {
        let app = create_app();

        let response = app
            .oneshot(
                Request::builder()
                    .uri("/health")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);
    }

    #[tokio::test]
    async fn test_health_check_body() {
        let app = create_app();

        let response = app
            .oneshot(
                Request::builder()
                    .uri("/health")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let body: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(body["status"], "ok");
    }
}
```

핵심 포인트:
- `#[tokio::test]` : 비동기 테스트 함수를 표시합니다. `#[test]` 대신 이것을 사용합니다.
- `oneshot()` : 하나의 요청을 보내고 응답을 받습니다. 실제 서버를 띄우지 않습니다.
- `Request::builder()` : 가짜 HTTP 요청을 만듭니다.

### POST 요청 테스트

```rust
use axum::{routing::post, Router, Json};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct CreateUser {
    name: String,
    email: String,
}

#[derive(Serialize)]
struct UserResponse {
    id: u64,
    name: String,
}

async fn create_user(Json(payload): Json<CreateUser>) -> Json<UserResponse> {
    Json(UserResponse {
        id: 1,
        name: payload.name,
    })
}

fn create_app() -> Router {
    Router::new()
        .route("/users", post(create_user))
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::{Request, StatusCode, header};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_create_user() {
        let app = create_app();

        let body = serde_json::json!({
            "name": "홍길동",
            "email": "hong@example.com"
        });

        let response = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/users")
                    .header(header::CONTENT_TYPE, "application/json")
                    .body(Body::from(serde_json::to_string(&body).unwrap()))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let user: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(user["name"], "홍길동");
        assert_eq!(user["id"], 1);
    }
}
```

### 테스트 헬퍼 함수

요청을 만드는 코드가 반복되면 헬퍼 함수로 빼면 좋습니다.

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::{Request, StatusCode, header};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    // 헬퍼: GET 요청 보내기
    async fn get_request(app: Router, uri: &str) -> (StatusCode, serde_json::Value) {
        let response = app
            .oneshot(
                Request::builder()
                    .uri(uri)
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        let status = response.status();
        let body = response.into_body().collect().await.unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();

        (status, json)
    }

    #[tokio::test]
    async fn test_health() {
        let (status, body) = get_request(create_app(), "/health").await;
        assert_eq!(status, StatusCode::OK);
        assert_eq!(body["status"], "ok");
    }
}
```

<details>
<summary><b>oneshot vs 실제 서버 테스트 (원리)</b></summary>

### oneshot 방식

`oneshot()`은 Tower의 `ServiceExt` 트레이트가 제공하는 메서드입니다. 실제 TCP 연결 없이 **메모리 내에서** 요청과 응답을 주고받습니다.

```
oneshot 방식:
[테스트 코드] → Request → [Router/Handler] → Response → [테스트 코드]
              (메모리 내에서 직접 전달, TCP 연결 없음)
```

장점:
- 포트 충돌이 없습니다 (서버를 안 띄우니까)
- 매우 빠릅니다
- 테스트를 병렬로 실행할 수 있습니다

단점:
- 미들웨어 스택의 일부가 테스트되지 않을 수 있습니다
- 실제 네트워크 환경과 다를 수 있습니다

### 실제 서버를 띄우는 방식

정말 실제 HTTP를 테스트하고 싶다면 서버를 띄울 수 있습니다:

```rust
#[tokio::test]
async fn test_with_real_server() {
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0").await.unwrap();
    let addr = listener.local_addr().unwrap();

    tokio::spawn(async move {
        axum::serve(listener, create_app()).await.unwrap();
    });

    let client = reqwest::Client::new();
    let response = client
        .get(format!("http://{}/health", addr))
        .send()
        .await
        .unwrap();

    assert_eq!(response.status(), 200);
}
```

포트 `0`을 사용하면 OS가 **사용 가능한 포트를 자동 할당**합니다. 이렇게 하면 포트 충돌을 방지할 수 있습니다.

대부분의 경우 **oneshot 방식이면 충분**합니다. 실제 서버 테스트는 E2E 테스트에서 사용하세요.

</details>

---

## 5. 테스트 데이터베이스

실제 DB를 사용하는 코드를 테스트할 때는 **테스트 전용 데이터베이스**를 사용해야 합니다. 실제 데이터를 망가뜨리면 안 되니까요.

### 테스트용 DB 분리

```rust
// src/config.rs
pub struct DatabaseConfig {
    pub url: String,
}

impl DatabaseConfig {
    pub fn from_env() -> Self {
        let url = std::env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgres://localhost/myapp".to_string());
        Self { url }
    }

    pub fn test_config() -> Self {
        Self {
            url: "postgres://localhost/myapp_test".to_string(),
        }
    }
}
```

### 테스트 전 마이그레이션 실행

테스트 DB에도 테이블이 있어야 합니다. 테스트 시작 시 마이그레이션을 실행합니다.

```rust
use sqlx::PgPool;

async fn setup_test_db() -> PgPool {
    let database_url = "postgres://localhost/myapp_test";
    let pool = PgPool::connect(database_url).await.unwrap();

    // 마이그레이션 실행
    sqlx::migrate!("./migrations")
        .run(&pool)
        .await
        .unwrap();

    pool
}
```

### 트랜잭션 롤백 패턴

테스트마다 데이터를 넣고 빼면 느리고 복잡합니다. **트랜잭션을 시작하고, 테스트가 끝나면 롤백**하는 패턴이 깔끔합니다.

```rust
#[tokio::test]
async fn test_create_user_in_db() {
    let pool = setup_test_db().await;

    // 트랜잭션 시작
    let mut tx = pool.begin().await.unwrap();

    // 테스트 데이터 삽입
    sqlx::query("INSERT INTO users (name, email) VALUES ($1, $2)")
        .bind("테스트유저")
        .bind("test@example.com")
        .execute(&mut *tx)
        .await
        .unwrap();

    // 조회 테스트
    let user = sqlx::query_as::<_, (String, String)>(
        "SELECT name, email FROM users WHERE email = $1"
    )
        .bind("test@example.com")
        .fetch_one(&mut *tx)
        .await
        .unwrap();

    assert_eq!(user.0, "테스트유저");
    assert_eq!(user.1, "test@example.com");

    // tx가 drop되면 자동으로 롤백됨! (commit하지 않았으므로)
    // 다른 테스트에 영향을 주지 않음
}
```

핵심:
- `pool.begin()` 으로 트랜잭션을 시작합니다
- 테스트 안에서 데이터를 자유롭게 넣고 뺍니다
- `tx.commit()`을 호출하지 않으면, `tx`가 drop될 때 **자동으로 롤백**됩니다
- 다음 테스트는 깨끗한 상태에서 시작합니다

<details>
<summary><b>테스트 격리 전략 비교 (원리)</b></summary>

### 테스트 데이터 정리 방법

| 방법 | 장점 | 단점 |
|------|------|------|
| 트랜잭션 롤백 | 빠름, 자동 정리 | 트랜잭션 내에서만 테스트 가능 |
| 각 테스트마다 DB 생성/삭제 | 완벽한 격리 | 매우 느림 |
| TRUNCATE로 테이블 비우기 | 구현이 간단 | 외래 키 순서 문제 |
| Docker로 DB 컨테이너 | 환경이 동일함 | 셋업 시간이 길음 |

**추천**: 단위 테스트는 **트랜잭션 롤백**, CI/CD에서는 **Docker DB 컨테이너**를 조합하세요.

### 테스트 간 독립성이 중요한 이유

```
테스트 A: 유저 "kim"을 생성
테스트 B: 유저가 0명인지 확인

→ A가 먼저 실행되면 B가 실패!
→ 테스트 순서에 따라 결과가 달라짐 = 불안정한 테스트
```

트랜잭션 롤백을 사용하면 각 테스트가 격리되어 순서에 무관하게 동일한 결과를 보장합니다.

</details>

---

## 6. 테스트 실행 명령어

### 기본 명령어

```bash
# 전체 테스트 실행
cargo test

# 특정 테스트 함수 실행 (이름에 "health"가 포함된 테스트만)
cargo test health

# 특정 모듈의 테스트 실행
cargo test tests::test_add

# 테스트 실행 시 println! 출력 보기
cargo test -- --nocapture

# 특정 통합 테스트 파일만 실행
cargo test --test health_check

# 단위 테스트만 실행 (통합 테스트 제외)
cargo test --lib

# 통합 테스트만 실행
cargo test --tests
```

### 유용한 옵션

```bash
# 테스트 목록만 보기 (실행하지 않음)
cargo test -- --list

# 실패한 테스트만 다시 실행
cargo test -- --failed

# 테스트를 1개씩 순서대로 실행 (기본은 병렬)
cargo test -- --test-threads=1

# 무시된 테스트만 실행
cargo test -- --ignored
```

### #[ignore]로 느린 테스트 분리

DB 연결이 필요한 테스트나 시간이 오래 걸리는 테스트는 `#[ignore]`로 표시할 수 있습니다.

```rust
#[test]
fn test_fast() {
    assert_eq!(1 + 1, 2);
}

#[test]
#[ignore]  // cargo test에서 기본 제외
fn test_slow_db_connection() {
    // 실제 DB 연결이 필요한 느린 테스트
}
```

```bash
# 일반 테스트만 실행 (ignore된 건 제외)
cargo test

# ignore된 테스트만 실행
cargo test -- --ignored

# 모든 테스트 실행 (ignore 포함)
cargo test -- --include-ignored
```

---

## 7. 실습

### 실습 1: 서비스 함수 단위 테스트 3개 작성

사용자 유효성 검사 함수를 테스트하세요.

```rust
#[derive(Debug, PartialEq)]
struct User {
    name: String,
    age: u32,
    email: String,
}

fn validate_user(name: &str, age: i32, email: &str) -> Result<User, String> {
    if name.is_empty() {
        return Err("이름을 입력하세요".to_string());
    }
    if name.len() < 2 {
        return Err("이름은 2글자 이상이어야 합니다".to_string());
    }
    if age < 0 {
        return Err("나이는 0 이상이어야 합니다".to_string());
    }
    if age > 150 {
        return Err("나이가 너무 큽니다".to_string());
    }
    if !email.contains('@') {
        return Err("올바른 이메일 형식이 아닙니다".to_string());
    }

    Ok(User {
        name: name.to_string(),
        age: age as u32,
        email: email.to_string(),
    })
}

// 아래에 테스트를 작성하세요!
// 1. test_validate_user_success: 유효한 입력으로 Ok 반환 확인
// 2. test_validate_user_empty_name: 빈 이름으로 Err 반환 확인
// 3. test_validate_user_invalid_email: @가 없는 이메일로 Err 반환 확인

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
#[derive(Debug, PartialEq)]
struct User {
    name: String,
    age: u32,
    email: String,
}

fn validate_user(name: &str, age: i32, email: &str) -> Result<User, String> {
    if name.is_empty() {
        return Err("이름을 입력하세요".to_string());
    }
    if name.len() < 2 {
        return Err("이름은 2글자 이상이어야 합니다".to_string());
    }
    if age < 0 {
        return Err("나이는 0 이상이어야 합니다".to_string());
    }
    if age > 150 {
        return Err("나이가 너무 큽니다".to_string());
    }
    if !email.contains('@') {
        return Err("올바른 이메일 형식이 아닙니다".to_string());
    }

    Ok(User {
        name: name.to_string(),
        age: age as u32,
        email: email.to_string(),
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_validate_user_success() {
        let result = validate_user("홍길동", 25, "hong@example.com");
        assert!(result.is_ok());

        let user = result.unwrap();
        assert_eq!(user.name, "홍길동");
        assert_eq!(user.age, 25);
        assert_eq!(user.email, "hong@example.com");
    }

    #[test]
    fn test_validate_user_empty_name() {
        let result = validate_user("", 25, "hong@example.com");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "이름을 입력하세요");
    }

    #[test]
    fn test_validate_user_invalid_email() {
        let result = validate_user("홍길동", 25, "invalid-email");
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "올바른 이메일 형식이 아닙니다");
    }
}

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

</details>

### 실습 2: API 엔드포인트 통합 테스트 작성

할 일(Todo) API의 엔드포인트를 테스트하세요.

```rust
use axum::{routing::{get, post}, Router, Json, http::StatusCode};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

#[derive(Clone, Serialize, Deserialize, Debug)]
struct Todo {
    id: u64,
    title: String,
    completed: bool,
}

type TodoList = Arc<Mutex<Vec<Todo>>>;

async fn list_todos(
    todos: axum::extract::State<TodoList>,
) -> Json<Vec<Todo>> {
    let todos = todos.lock().unwrap();
    Json(todos.clone())
}

#[derive(Deserialize)]
struct CreateTodo {
    title: String,
}

async fn create_todo(
    todos: axum::extract::State<TodoList>,
    Json(payload): Json<CreateTodo>,
) -> (StatusCode, Json<Todo>) {
    let mut todos = todos.lock().unwrap();
    let todo = Todo {
        id: todos.len() as u64 + 1,
        title: payload.title,
        completed: false,
    };
    todos.push(todo.clone());
    (StatusCode::CREATED, Json(todo))
}

fn create_app() -> Router {
    let todos: TodoList = Arc::new(Mutex::new(Vec::new()));
    Router::new()
        .route("/todos", get(list_todos).post(create_todo))
        .with_state(todos)
}

// 아래에 테스트를 작성하세요!
// 1. test_list_todos_empty: GET /todos → 빈 배열 반환, 200 OK
// 2. test_create_todo: POST /todos → 새 할 일 생성, 201 Created
// 힌트: 실습에서 보여준 oneshot 패턴과 헬퍼를 참고하세요

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use axum::{routing::{get, post}, Router, Json, http::StatusCode};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

#[derive(Clone, Serialize, Deserialize, Debug)]
struct Todo {
    id: u64,
    title: String,
    completed: bool,
}

type TodoList = Arc<Mutex<Vec<Todo>>>;

async fn list_todos(
    todos: axum::extract::State<TodoList>,
) -> Json<Vec<Todo>> {
    let todos = todos.lock().unwrap();
    Json(todos.clone())
}

#[derive(Deserialize)]
struct CreateTodo {
    title: String,
}

async fn create_todo(
    todos: axum::extract::State<TodoList>,
    Json(payload): Json<CreateTodo>,
) -> (StatusCode, Json<Todo>) {
    let mut todos = todos.lock().unwrap();
    let todo = Todo {
        id: todos.len() as u64 + 1,
        title: payload.title,
        completed: false,
    };
    todos.push(todo.clone());
    (StatusCode::CREATED, Json(todo))
}

fn create_app() -> Router {
    let todos: TodoList = Arc::new(Mutex::new(Vec::new()));
    Router::new()
        .route("/todos", get(list_todos).post(create_todo))
        .with_state(todos)
}

#[cfg(test)]
mod tests {
    use super::*;
    use axum::body::Body;
    use axum::http::{Request, header};
    use http_body_util::BodyExt;
    use tower::ServiceExt;

    #[tokio::test]
    async fn test_list_todos_empty() {
        let app = create_app();

        let response = app
            .oneshot(
                Request::builder()
                    .uri("/todos")
                    .body(Body::empty())
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::OK);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let todos: Vec<serde_json::Value> = serde_json::from_slice(&body).unwrap();
        assert!(todos.is_empty());
    }

    #[tokio::test]
    async fn test_create_todo() {
        let app = create_app();

        let body = serde_json::json!({
            "title": "Rust 공부하기"
        });

        let response = app
            .oneshot(
                Request::builder()
                    .method("POST")
                    .uri("/todos")
                    .header(header::CONTENT_TYPE, "application/json")
                    .body(Body::from(serde_json::to_string(&body).unwrap()))
                    .unwrap(),
            )
            .await
            .unwrap();

        assert_eq!(response.status(), StatusCode::CREATED);

        let body = response.into_body().collect().await.unwrap().to_bytes();
        let todo: serde_json::Value = serde_json::from_slice(&body).unwrap();

        assert_eq!(todo["title"], "Rust 공부하기");
        assert_eq!(todo["completed"], false);
        assert_eq!(todo["id"], 1);
    }
}

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

</details>

### 실습 3: 에러 케이스 테스트 작성

주문 금액 계산 함수의 다양한 에러 상황을 테스트하세요.

```rust
#[derive(Debug, PartialEq)]
struct OrderItem {
    name: String,
    price: f64,
    quantity: u32,
}

fn calculate_total(items: &[OrderItem], discount_percent: f64) -> Result<f64, String> {
    if items.is_empty() {
        return Err("주문 항목이 없습니다".to_string());
    }
    if discount_percent < 0.0 {
        return Err("할인율은 0 이상이어야 합니다".to_string());
    }
    if discount_percent > 100.0 {
        return Err("할인율은 100 이하여야 합니다".to_string());
    }

    let subtotal: f64 = items.iter()
        .map(|item| item.price * item.quantity as f64)
        .sum();

    if subtotal < 0.0 {
        return Err("총액이 음수입니다".to_string());
    }

    let total = subtotal * (1.0 - discount_percent / 100.0);
    Ok((total * 100.0).round() / 100.0)  // 소수점 2자리 반올림
}

// 아래에 테스트를 작성하세요!
// 1. test_calculate_total_success: 정상 계산 확인
// 2. test_calculate_total_empty_items: 빈 주문 에러 확인
// 3. test_calculate_total_invalid_discount: 음수 할인율 에러 확인
// 4. test_calculate_total_with_discount: 10% 할인 적용 확인
// 5. test_calculate_total_over_discount: 100% 초과 할인율 에러 확인

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
#[derive(Debug, PartialEq)]
struct OrderItem {
    name: String,
    price: f64,
    quantity: u32,
}

fn calculate_total(items: &[OrderItem], discount_percent: f64) -> Result<f64, String> {
    if items.is_empty() {
        return Err("주문 항목이 없습니다".to_string());
    }
    if discount_percent < 0.0 {
        return Err("할인율은 0 이상이어야 합니다".to_string());
    }
    if discount_percent > 100.0 {
        return Err("할인율은 100 이하여야 합니다".to_string());
    }

    let subtotal: f64 = items.iter()
        .map(|item| item.price * item.quantity as f64)
        .sum();

    if subtotal < 0.0 {
        return Err("총액이 음수입니다".to_string());
    }

    let total = subtotal * (1.0 - discount_percent / 100.0);
    Ok((total * 100.0).round() / 100.0)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_item(name: &str, price: f64, quantity: u32) -> OrderItem {
        OrderItem {
            name: name.to_string(),
            price,
            quantity,
        }
    }

    #[test]
    fn test_calculate_total_success() {
        let items = vec![
            make_item("커피", 4500.0, 2),
            make_item("케이크", 6000.0, 1),
        ];
        let result = calculate_total(&items, 0.0);
        assert_eq!(result, Ok(15000.0));
    }

    #[test]
    fn test_calculate_total_empty_items() {
        let result = calculate_total(&[], 0.0);
        assert_eq!(result, Err("주문 항목이 없습니다".to_string()));
    }

    #[test]
    fn test_calculate_total_invalid_discount() {
        let items = vec![make_item("커피", 4500.0, 1)];
        let result = calculate_total(&items, -10.0);
        assert_eq!(result, Err("할인율은 0 이상이어야 합니다".to_string()));
    }

    #[test]
    fn test_calculate_total_with_discount() {
        let items = vec![
            make_item("커피", 5000.0, 2),  // 10000
        ];
        let result = calculate_total(&items, 10.0);  // 10% 할인
        assert_eq!(result, Ok(9000.0));
    }

    #[test]
    fn test_calculate_total_over_discount() {
        let items = vec![make_item("커피", 4500.0, 1)];
        let result = calculate_total(&items, 150.0);
        assert_eq!(result, Err("할인율은 100 이하여야 합니다".to_string()));
    }
}

fn main() {
    println!("cargo test로 테스트를 실행하세요!");
}
```

**포인트**: 성공 케이스 하나와 에러 케이스 여러 개를 작성합니다. 에러가 발생할 수 있는 경계값(빈 배열, 음수, 최대값 초과)을 빠짐없이 테스트하는 것이 중요합니다.

</details>

---

## 8. 확인 문제

### 문제 1
`#[cfg(test)]`의 역할은 무엇인가요?
- (a) 테스트를 병렬로 실행하게 함
- (b) `cargo test` 실행 시에만 해당 모듈을 컴파일함
- (c) 테스트 결과를 파일로 저장함
- (d) 테스트 실패 시 자동으로 재시도함

### 문제 2
아래 코드에서 테스트가 **통과하는** 경우는?
```rust
#[test]
#[should_panic(expected = "0으로 나눌 수 없습니다")]
fn test_divide() {
    divide(10, 0);
}
```
- (a) `divide(10, 0)`이 정상 실행되어 결과를 반환할 때
- (b) `divide(10, 0)`이 "잘못된 입력" 메시지로 panic할 때
- (c) `divide(10, 0)`이 "0으로 나눌 수 없습니다" 메시지로 panic할 때
- (d) `divide(10, 0)`이 Err를 반환할 때

### 문제 3
단위 테스트와 통합 테스트의 위치는 각각 어디인가요?

### 문제 4
아래 명령어는 무엇을 하나요?
```bash
cargo test -- --nocapture
```

### 문제 5
테스트에서 트랜잭션 롤백 패턴을 사용하는 이유는 무엇인가요?

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답: **(b) `cargo test` 실행 시에만 해당 모듈을 컴파일함**
`#[cfg(test)]`는 조건부 컴파일 어트리뷰트입니다. `cargo test`로 실행할 때만 이 모듈을 컴파일하고, `cargo build`나 `cargo run`에서는 완전히 무시됩니다. 릴리즈 바이너리에 테스트 코드가 포함되지 않습니다.

### 문제 2 정답: **(c) `divide(10, 0)`이 "0으로 나눌 수 없습니다" 메시지로 panic할 때**
`#[should_panic(expected = "...")]`는 panic이 발생해야 하고, panic 메시지에 `expected`에 지정한 문자열이 **포함**되어 있어야 테스트가 통과합니다. (a)처럼 panic이 없으면 실패, (b)처럼 다른 메시지면 실패합니다.

### 문제 3 정답
- **단위 테스트**: `src/` 디렉토리의 소스 파일 안에 `#[cfg(test)] mod tests { ... }` 모듈로 작성합니다. 비공개 함수도 테스트할 수 있습니다.
- **통합 테스트**: 프로젝트 루트의 `tests/` 디렉토리에 별도 파일로 작성합니다. 공개(`pub`) API만 테스트합니다.

### 문제 4 정답
`cargo test -- --nocapture`는 테스트 실행 중 `println!` 등의 **표준 출력을 화면에 그대로 보여줍니다**. 기본적으로 `cargo test`는 통과한 테스트의 출력을 숨기는데, `--nocapture`를 붙이면 모든 출력이 보입니다. 디버깅할 때 유용합니다.

### 문제 5 정답
테스트마다 **트랜잭션을 시작하고 커밋하지 않으면 자동으로 롤백**됩니다. 이렇게 하면 각 테스트가 **서로 독립적**으로 실행됩니다. 테스트 A에서 넣은 데이터가 테스트 B에 영향을 주지 않으므로, 테스트 실행 순서에 관계없이 항상 같은 결과를 보장합니다.

</details>

---

## 9. 24장 정리

| 배운 것 | 핵심 |
|---------|------|
| 테스트의 필요성 | 자동 검증, 리팩토링 안전망, 버그 재발 방지 |
| `#[cfg(test)]` | 테스트 모듈 표시, `cargo test`에서만 컴파일 |
| `#[test]` | 테스트 함수 표시 |
| `assert!`, `assert_eq!`, `assert_ne!` | 값 검증 매크로 3종 |
| `#[should_panic]` | panic이 발생해야 통과하는 테스트 |
| `#[tokio::test]` | 비동기 테스트 함수 표시 |
| 통합 테스트 | `tests/` 디렉토리, 공개 API 테스트 |
| API 테스트 | `oneshot()` + `Request::builder()`로 HTTP 요청 시뮬레이션 |
| 테스트 DB | 별도 DB 사용, 트랜잭션 롤백으로 데이터 격리 |
| `cargo test` 옵션 | `--nocapture`, `--test`, `--lib`, `--ignored` |

---

## 다음 장 예고

> **25장. 배포 준비**에서는 완성한 웹서버를 실제로 배포하는 방법을 배웁니다.
> Docker로 컨테이너를 만들고, 환경 변수를 안전하게 관리하고, 로깅과 모니터링을 설정하는 법을 알아봅니다!
