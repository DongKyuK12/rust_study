# 10장. 라이프타임 심화

> **목표**: 라이프타임 어노테이션을 이해하고, 참조가 유효한 범위를 다룰 수 있다.
> 라이프타임은 어렵게 느껴질 수 있지만, 대부분의 경우 컴파일러가 알아서 처리합니다!

---

## 1. 라이프타임이란?

**라이프타임**은 참조가 유효한 범위(scope)입니다.

Rust 컴파일러는 모든 참조가 유효한지 자동으로 검증합니다. 이미 사라진 데이터를 가리키는 **댕글링 참조(dangling reference)** 를 원천 차단하는 것이 목적입니다.

```rust
fn main() {
    let r;                     // r을 선언 (아직 값 없음)
    {
        let x = 5;
        r = &x;               // x의 참조를 r에 저장
    }                          // x가 여기서 사라짐!
    // println!("{}", r);      // r은 사라진 x를 가리킴 -> 컴파일 에러!
}
```

```
┌─────────────────────────────────────┐
│  r의 라이프타임 ──────────────────>  │
│      ┌─────────────┐               │
│      │ x의 라이프타임 │               │
│      └─────────────┘               │
│              ↑                      │
│         x가 여기서 사라짐             │
│         → r이 댕글링 참조가 됨!       │
└─────────────────────────────────────┘
```

**비유**: 도서관에서 책을 빌렸는데, 반납 기한이 지난 후에도 그 책을 읽으려고 하면 안 되겠죠? 라이프타임은 이 "대출 기간"과 같습니다. 기간 안에서만 참조를 사용할 수 있습니다.

정상적인 코드는 이렇게 작성합니다:

```rust
fn main() {
    let x = 5;
    let r = &x;               // x가 살아있는 동안 참조 사용
    println!("{}", r);         // 정상 작동
}
```

<details>
<summary><b>컴파일러는 어떻게 라이프타임을 검사하나요? (원리)</b></summary>

### 빌림 검사기 (Borrow Checker)

Rust 컴파일러 안에는 **빌림 검사기(Borrow Checker)** 가 있습니다. 이 검사기가 하는 일은 간단합니다:

> "모든 참조가, 참조 대상이 살아있는 동안에만 사용되는가?"

```rust
fn main() {
    let r;                // ---------+-- r의 라이프타임
    {                     //          |
        let x = 5;       // -+-- x의 라이프타임
        r = &x;          //  |       |
    }                     // -+       |  ← x 소멸, r은 댕글링!
    println!("{}", r);    //          |
}                         // ---------+
```

빌림 검사기는 `r`의 라이프타임이 `x`의 라이프타임보다 길다는 것을 감지하고, 컴파일 에러를 발생시킵니다.

다른 언어에서는 이런 문제가 런타임에 발생해서 프로그램이 예기치 않게 죽지만, Rust에서는 **컴파일 단계에서** 미리 잡아줍니다.

</details>

---

## 2. 라이프타임 어노테이션

### 왜 필요한가?

함수 안에서 참조를 다룰 때, 컴파일러가 라이프타임을 추론하지 못하는 경우가 있습니다. 이때 **라이프타임 어노테이션**으로 참조들의 관계를 명시합니다.

```rust
// 이 코드는 컴파일 에러!
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        return x;
    }
    y
}
```

에러 메시지:
```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----      ^ expected named lifetime parameter
```

컴파일러는 "반환값이 `x`의 참조인지 `y`의 참조인지 모르겠다"고 합니다. 라이프타임 어노테이션으로 알려줘야 합니다.

### `'a` 문법

라이프타임 어노테이션은 **아포스트로피 + 이름**으로 작성합니다.

```rust
&i32        // 참조
&'a i32     // 라이프타임 'a를 가진 참조
&'a mut i32 // 라이프타임 'a를 가진 가변 참조
```

- 관례적으로 `'a`, `'b`, `'c` 같은 짧은 소문자를 사용합니다
- 라이프타임 어노테이션 자체는 수명을 늘리거나 줄이지 않습니다
- **참조들 사이의 관계**를 컴파일러에게 알려줄 뿐입니다

### 함수 시그니처에서의 라이프타임

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        return x;
    }
    y
}

fn main() {
    let string1 = String::from("긴 문자열입니다");
    let result;

    {
        let string2 = String::from("짧음");
        result = longest(string1.as_str(), string2.as_str());
        println!("더 긴 문자열: {}", result); // 여기선 OK
    }
    // println!("{}", result); // string2가 사라졌으므로 에러 가능!
}
```

`longest<'a>` 가 의미하는 것:

```
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str
           ^^     ^^          ^^           ^^
           │      │           │            │
           │      └───────────┴────────────┘
           │        "x, y, 반환값 모두 같은 라이프타임 'a를 공유"
           │
           └─ "이 함수는 라이프타임 매개변수 'a를 사용합니다"
```

핵심: **반환값의 라이프타임은 x와 y 중 더 짧은 쪽과 같다**는 뜻입니다.

<details>
<summary><b>라이프타임 어노테이션이 실제로 하는 일 (원리)</b></summary>

### 어노테이션은 "설명"이지 "명령"이 아닙니다

라이프타임 어노테이션은 수명을 늘리거나 줄이지 않습니다. 컴파일러에게 **참조들 사이의 관계**를 알려주는 것뿐입니다.

비유하면:
- 의사에게 "이 약은 식후 30분에 드세요"라고 말하는 것은 명령이 아니라 **복용 안내(설명)** 입니다
- 라이프타임 어노테이션도 마찬가지로, 컴파일러에게 "이 참조들은 이런 관계입니다"라고 **설명**하는 것입니다

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { ... }
```

이 코드가 컴파일러에게 알려주는 내용:
1. `x`와 `y`는 최소 `'a`만큼 살아있을 것이다
2. 반환값도 최소 `'a`만큼 유효할 것이다
3. `'a`는 `x`와 `y`의 라이프타임 중 **더 짧은 쪽**이다

컴파일러는 이 정보를 바탕으로 호출 지점에서 참조가 안전한지 검증합니다:

```rust
fn main() {
    let s1 = String::from("long");    // s1의 라이프타임: 넓음
    {
        let s2 = String::from("hi");  // s2의 라이프타임: 좁음
        let result = longest(&s1, &s2);
        // 'a = s2의 라이프타임 (더 짧은 쪽)
        // result는 이 블록 안에서만 유효
        println!("{}", result);       // OK
    }
    // result를 여기서 쓰면 에러 (s2가 이미 사라짐)
}
```

</details>

---

## 3. 구조체에서의 라이프타임

구조체가 **참조를 필드로 가지면** 라이프타임 어노테이션이 필요합니다.

```rust
struct Excerpt<'a> {
    text: &'a str,
}

fn main() {
    let novel = String::from("어느 날 아침. 그레고르 잠자는 불안한 꿈에서 깨어났다.");
    let first_sentence = novel.split('.').next().unwrap();

    let excerpt = Excerpt {
        text: first_sentence,
    };

    println!("발췌: {}", excerpt.text);
}
```

### 규칙: 구조체는 참조 대상보다 오래 살 수 없다

```rust
struct Excerpt<'a> {
    text: &'a str,
}

fn main() {
    let excerpt;
    {
        let novel = String::from("안녕하세요.");
        excerpt = Excerpt { text: &novel };
    } // novel이 사라짐!
    // println!("{}", excerpt.text); // 에러! novel은 이미 사라짐
}
```

```
Excerpt 구조체의 수명  ──────────────────>
     ┌──────────────┐
     │ novel의 수명   │
     └──────────────┘
                     ↑
                novel 소멸 → excerpt.text는 댕글링 참조!
```

### 구조체 메서드에서의 라이프타임

```rust
struct Excerpt<'a> {
    text: &'a str,
}

impl<'a> Excerpt<'a> {
    fn level(&self) -> i32 {
        3
    }

    fn announce_and_return(&self, announcement: &str) -> &str {
        println!("알림: {}", announcement);
        self.text
    }
}

fn main() {
    let novel = String::from("Rust는 안전합니다. 그리고 빠릅니다.");
    let first = novel.split('.').next().unwrap();

    let excerpt = Excerpt { text: first };
    println!("레벨: {}", excerpt.level());
    println!("{}", excerpt.announce_and_return("중요!"));
}
```

`impl<'a> Excerpt<'a>` 에서 `<'a>`를 두 번 쓰는 이유:
- 첫 번째 `<'a>`: 라이프타임 매개변수를 선언
- 두 번째 `<'a>`: `Excerpt` 타입에 적용

<details>
<summary><b>구조체에 참조 대신 String을 쓰면 안 되나요? (원리)</b></summary>

### 참조 vs 소유: 상황에 따라 다릅니다

**소유 타입(String)을 쓰면 라이프타임이 필요 없습니다**:

```rust
// 라이프타임 불필요 - String이 데이터를 소유
struct Article {
    title: String,
    content: String,
}
```

**참조(&str)를 쓰면 라이프타임이 필요합니다**:

```rust
// 라이프타임 필요 - 원본 데이터를 빌려쓰는 중
struct Excerpt<'a> {
    text: &'a str,
}
```

| | 소유 (`String`) | 참조 (`&str`) |
|---|---|---|
| 라이프타임 | 불필요 | 필요 |
| 메모리 | 데이터 복사 | 복사 없음 (빌림) |
| 유연성 | 독립적으로 사용 가능 | 원본이 살아있어야 함 |
| 사용 시점 | 구조체가 데이터를 소유해야 할 때 | 잠깐 빌려쓸 때, 성능이 중요할 때 |

**실무 팁**: 라이프타임이 복잡해진다면, `String`을 소유하는 것이 더 단순한 해결책인 경우가 많습니다. 초보자라면 먼저 `String`을 사용하고, 성능 최적화가 필요할 때 참조로 바꾸는 전략을 추천합니다.

</details>

---

## 4. 라이프타임 생략 규칙 (Elision Rules)

사실 대부분의 코드에서는 라이프타임을 직접 쓸 필요가 없습니다. 컴파일러가 **생략 규칙**을 적용해서 자동으로 추론하기 때문입니다.

### 3가지 규칙

**규칙 1**: 각 참조 매개변수는 고유한 라이프타임을 받습니다.

```rust
// 우리가 쓴 코드:
fn first_word(s: &str) -> &str { ... }

// 컴파일러가 해석하는 코드:
fn first_word<'a>(s: &'a str) -> &str { ... }
```

**규칙 2**: 입력 라이프타임이 하나뿐이면, 출력 라이프타임에도 같은 라이프타임이 적용됩니다.

```rust
// 규칙 1 적용 후:
fn first_word<'a>(s: &'a str) -> &str { ... }

// 규칙 2 적용 후 (입력 라이프타임이 'a 하나):
fn first_word<'a>(s: &'a str) -> &'a str { ... }
// → 모든 라이프타임이 결정됨! 완료!
```

**규칙 3**: 매개변수 중 `&self` 또는 `&mut self`가 있으면, `self`의 라이프타임이 모든 출력 라이프타임에 적용됩니다.

```rust
// 우리가 쓴 코드:
impl<'a> Excerpt<'a> {
    fn announce_and_return(&self, announcement: &str) -> &str {
        self.text
    }
}

// 컴파일러가 해석하는 코드:
impl<'a> Excerpt<'a> {
    fn announce_and_return<'b, 'c>(&'b self, announcement: &'c str) -> &'b str {
        self.text
    }
}
// 규칙 3: &self가 있으므로 반환값에 self의 라이프타임 적용 → 완료!
```

### 규칙이 적용되는 과정 예시

```rust
// 상황: 매개변수가 2개이고 &self가 없는 경우
fn longest(x: &str, y: &str) -> &str { ... }

// 규칙 1 적용: 각 매개변수에 고유 라이프타임
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str { ... }

// 규칙 2 적용: 입력 라이프타임이 2개 → 적용 불가!
// 규칙 3 적용: &self 없음 → 적용 불가!
// → 출력 라이프타임을 결정할 수 없음 → 컴파일 에러!
// → 프로그래머가 직접 라이프타임을 명시해야 함
```

이 규칙 덕분에 **대부분의 함수에서 라이프타임을 직접 쓸 필요가 없습니다**.

---

## 5. 'static 라이프타임

`'static`은 **프로그램 전체 실행 시간 동안 유효한** 라이프타임입니다.

```rust
fn main() {
    let s: &'static str = "나는 프로그램이 끝날 때까지 살아있어요";
    println!("{}", s);
}
```

### 문자열 리터럴은 전부 'static

코드에 직접 쓴 문자열(`"hello"`)은 프로그램 바이너리에 포함되므로, 프로그램이 실행되는 동안 항상 유효합니다.

```rust
fn main() {
    // 이 두 줄은 같은 의미입니다
    let s1 = "hello";
    let s2: &'static str = "hello";
}
```

### 'static 남용하지 마세요!

에러 메시지에 `'static` 제안이 나올 때가 있습니다. 하지만 무작정 `'static`을 붙이면 안 됩니다.

```rust
// 이렇게 쓰고 싶은 유혹이 들 수 있지만...
fn bad_example() -> &'static str {
    let s = String::from("hello");
    &s // 에러! s는 함수가 끝나면 사라짐. 'static이 될 수 없음
}

// 대신 String을 반환하세요
fn good_example() -> String {
    String::from("hello")
}
```

`'static`이 적절한 경우:
- 문자열 리터럴 (`"hello"`)
- 프로그램 전체에서 쓰이는 상수
- 에러 메시지 같은 고정 문자열

`'static`이 부적절한 경우:
- 라이프타임 에러를 해결하기 위한 임시방편
- 동적으로 생성되는 데이터에 억지로 붙이는 경우

---

## 6. 실전에서의 라이프타임

### 대부분 안 써도 됩니다

실제 Rust 코드를 작성할 때 라이프타임을 직접 쓰는 일은 생각보다 적습니다.

```rust
// 이런 함수들은 라이프타임을 안 써도 됩니다 (생략 규칙 적용)
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &byte) in bytes.iter().enumerate() {
        if byte == b' ' {
            return &s[..i];
        }
    }
    s
}

fn greet(name: &str) -> String {
    format!("안녕하세요, {}님!", name)  // String을 반환하므로 라이프타임 불필요
}
```

### String을 소유하면 라이프타임 고민이 사라집니다

```rust
// 라이프타임이 복잡해지는 경우
struct Config<'a> {
    host: &'a str,
    port: &'a str,
}

// String을 소유하면 깔끔해짐
struct Config {
    host: String,
    port: String,
}
```

### 에러가 나면 그때 추가하세요

실전에서의 접근법:

1. 라이프타임 없이 코드를 작성합니다
2. 컴파일러가 에러를 내면 에러 메시지를 읽습니다
3. 컴파일러가 제안하는 대로 라이프타임을 추가합니다

```
error[E0106]: missing lifetime specifier
 --> src/main.rs:1:33
  |
1 | fn longest(x: &str, y: &str) -> &str {
  |               ----     ----      ^
  |
  = help: this function's return type contains a borrowed value,
          but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
  |
1 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  |           ++++     ++          ++           ++
```

컴파일러가 정확히 어디에 `'a`를 넣어야 하는지 알려줍니다.

<details>
<summary><b>실무에서 라이프타임 에러가 나면 어떻게 해결하나요? (원리)</b></summary>

### 라이프타임 에러 해결 체크리스트

**1단계: 에러 메시지를 꼼꼼히 읽습니다**

Rust 컴파일러의 에러 메시지는 매우 상세합니다. 대부분 해결 방법까지 제안해줍니다.

**2단계: "정말 참조가 필요한가?" 자문합니다**

```rust
// 참조 대신 소유를 고려하세요
// Before (라이프타임 복잡)
struct User<'a> {
    name: &'a str,
}

// After (라이프타임 불필요)
struct User {
    name: String,
}
```

많은 경우 `.to_string()` 또는 `.clone()`으로 소유권을 가져오면 라이프타임 문제가 사라집니다. 약간의 성능 비용이 있지만, 대부분의 애플리케이션에서는 무시할 수 있는 수준입니다.

**3단계: 참조가 꼭 필요하다면, 관계를 파악합니다**

- 반환값은 어떤 매개변수로부터 오는가?
- 구조체가 참조하는 데이터는 언제까지 살아있는가?

**4단계: 컴파일러의 제안을 따릅니다**

컴파일러가 `help:` 줄에서 제안하는 코드를 그대로 적용해보세요. 대부분 정확합니다.

**5단계: 그래도 안 되면 설계를 재고합니다**

라이프타임이 너무 복잡해진다면, 데이터 구조 설계 자체를 다시 생각해볼 때입니다. 소유권을 적절히 분배하면 라이프타임이 단순해집니다.

</details>

---

## 7. 제네릭 + 트레이트 + 라이프타임 조합

9장에서 배운 제네릭, 트레이트와 라이프타임을 함께 쓸 수 있습니다.

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("알림: {}", ann);
    if x.len() > y.len() {
        return x;
    }
    y
}

fn main() {
    let s1 = String::from("긴 문자열");
    let s2 = "짧음";

    let result = longest_with_announcement(
        s1.as_str(),
        s2,
        "비교를 시작합니다!",
    );
    println!("더 긴 쪽: {}", result);
}
```

읽는 순서:
1. `<'a, T>` - 라이프타임 `'a`와 제네릭 타입 `T`를 사용합니다
2. `x: &'a str, y: &'a str` - 두 문자열 참조의 라이프타임이 같습니다
3. `-> &'a str` - 반환값도 같은 라이프타임입니다
4. `where T: Display` - `T`는 화면에 출력 가능해야 합니다

---

## 8. 실습

### 실습 1: longest 함수 사용하기

`longest` 함수를 작성하고, 다양한 상황에서 호출해보세요.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        return x;
    }
    y
}

fn main() {
    // 1. 두 문자열 리터럴 비교
    let result1 = longest("hello", "hi");
    println!("더 긴 쪽: {}", result1);

    // 2. String과 &str 비교
    let s1 = String::from("Rust는 안전합니다");
    let result2 = longest(s1.as_str(), "짧음");
    println!("더 긴 쪽: {}", result2);

    // 3. 같은 길이일 때
    let result3 = longest("abc", "xyz");
    println!("같은 길이: {}", result3);
}
```

**도전**: `longest` 함수를 수정해서, 길이가 같으면 첫 번째 매개변수(`x`)를 반환하도록 만들어보세요!

### 실습 2: 참조를 가진 구조체

텍스트의 첫 문장을 저장하는 구조체를 만들어보세요.

```rust
struct FirstSentence<'a> {
    text: &'a str,
}

impl<'a> FirstSentence<'a> {
    fn new(full_text: &'a str) -> FirstSentence<'a> {
        let end = full_text.find('.').unwrap_or(full_text.len());
        FirstSentence {
            text: &full_text[..end],
        }
    }

    fn display(&self) {
        println!("첫 문장: {}", self.text);
    }
}

fn main() {
    let article = String::from("Rust는 안전합니다. 그리고 빠릅니다. 배워봅시다.");
    let first = FirstSentence::new(&article);
    first.display();
    // article이 여기까지 살아있으므로 OK
}
```

**도전**: `word_count` 메서드를 추가해서, 첫 문장의 단어 수를 반환하도록 만들어보세요!
(힌트: `.split_whitespace().count()`)

### 실습 3: 라이프타임 에러 고치기

아래 코드에는 라이프타임 관련 에러가 있습니다. 고쳐보세요!

```rust
// 에러가 있는 코드 - 고쳐보세요!
fn first_or_default(input: &str) -> &str {
    if input.is_empty() {
        return "기본값";
    }
    let words: Vec<&str> = input.split_whitespace().collect();
    if words.is_empty() {
        return "기본값";
    }
    words[0]
}

fn main() {
    let text = String::from("Rust 프로그래밍");
    let result = first_or_default(&text);
    println!("첫 단어: {}", result);

    let empty_result = first_or_default("");
    println!("빈 입력: {}", empty_result);
}
```

<details>
<summary><b>힌트</b></summary>

이 함수는 입력 매개변수가 하나뿐이므로 **생략 규칙 2**가 적용됩니다. 즉, 라이프타임 어노테이션을 직접 쓸 필요가 없습니다.

문제는 `words[0]`에 있습니다. `words` 벡터는 함수 안에서 생성되었지만, `words[0]`은 원본 `input`의 슬라이스를 참조하므로 실제로는 안전합니다.

이 코드는 사실 **그대로 컴파일이 됩니다**. 직접 실행해보세요! Rust 컴파일러는 `words[0]`이 `input`의 일부임을 알고 있습니다.

</details>

---

## 9. 확인 문제

### 문제 1

아래 코드가 컴파일되지 않는 이유는?

```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("{}", r);
}
```

### 문제 2

라이프타임 어노테이션 `'a`는 실제로 무엇을 하나요?
- (a) 참조의 수명을 늘린다
- (b) 참조의 수명을 줄인다
- (c) 참조들 사이의 수명 관계를 컴파일러에게 알려준다
- (d) 메모리를 해제하는 시점을 지정한다

### 문제 3

아래 함수에 라이프타임 어노테이션이 필요 없는 이유는?

```rust
fn first_char(s: &str) -> &str {
    &s[..1]
}
```

### 문제 4

`'static` 라이프타임에 대한 설명 중 올바른 것은?
- (a) 모든 참조에 붙이면 안전하다
- (b) 프로그램 전체 실행 시간 동안 유효한 참조를 의미한다
- (c) 힙 메모리에 저장된 데이터에만 적용된다
- (d) 성능을 향상시키는 최적화 기법이다

### 문제 5

아래 코드의 출력 결과는?

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        return x;
    }
    y
}

fn main() {
    let result;
    let s1 = String::from("hi");
    {
        let s2 = String::from("hello world");
        result = longest(s1.as_str(), s2.as_str());
        println!("{}", result);
    }
}
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
`x`는 안쪽 블록이 끝나면 소멸됩니다. `r`은 이미 사라진 `x`를 참조하게 되므로 **댕글링 참조**가 됩니다. Rust 컴파일러는 이를 감지하고 컴파일을 거부합니다.

수정 방법: `x`를 바깥 블록에서 선언하면 됩니다.
```rust
fn main() {
    let x = 5;
    let r = &x;
    println!("{}", r);
}
```

### 문제 2 정답
**(c) 참조들 사이의 수명 관계를 컴파일러에게 알려준다**

라이프타임 어노테이션은 수명을 늘리거나 줄이지 않습니다. "이 참조들은 이런 관계에 있다"고 컴파일러에게 설명하는 것뿐입니다.

### 문제 3 정답
**라이프타임 생략 규칙** 덕분입니다.
- 규칙 1: 입력 매개변수 `s`에 `'a`가 자동 부여됩니다
- 규칙 2: 입력 라이프타임이 하나뿐이므로 출력에도 `'a`가 적용됩니다

컴파일러가 자동으로 `fn first_char<'a>(s: &'a str) -> &'a str`로 해석합니다.

### 문제 4 정답
**(b) 프로그램 전체 실행 시간 동안 유효한 참조를 의미한다**

문자열 리터럴(`"hello"`)이 대표적인 `'static` 참조입니다. 모든 참조에 `'static`을 붙이는 것은 위험하며, 힙 메모리와는 직접적인 관련이 없습니다.

### 문제 5 정답
**`hello world`** 가 출력됩니다.

`longest` 함수는 더 긴 문자열을 반환합니다. `"hi"`(2글자)보다 `"hello world"`(11글자)가 더 기므로 `s2`가 반환됩니다.

`result`를 `println!`에서 사용하는 시점에 `s2`가 아직 살아있으므로 정상 작동합니다. 만약 `println!`이 `s2`의 블록 바깥에 있었다면 컴파일 에러가 발생했을 것입니다.

</details>

---

## 10. 10장 정리

| 배운 것 | 핵심 |
|---------|------|
| 라이프타임 | 참조가 유효한 범위(scope) |
| 어노테이션 `'a` | 참조들 사이의 수명 관계를 컴파일러에게 설명 |
| 함수 라이프타임 | `fn foo<'a>(x: &'a str) -> &'a str` |
| 구조체 라이프타임 | `struct Foo<'a> { field: &'a str }` |
| 생략 규칙 | 3가지 규칙으로 대부분 자동 추론 |
| `'static` | 프로그램 전체 동안 유효, 문자열 리터럴이 대표적 |
| 실전 팁 | 대부분 안 써도 됨, 에러 나면 그때 추가 |

### 라이프타임 판단 흐름

```
참조를 반환하는 함수를 작성
    │
    ├─ 입력 참조가 1개? → 생략 규칙으로 자동 처리 (안 써도 됨)
    │
    ├─ 메서드(&self 있음)? → 생략 규칙으로 자동 처리 (안 써도 됨)
    │
    ├─ 입력 참조가 2개 이상? → 라이프타임 어노테이션 필요
    │
    └─ 라이프타임이 너무 복잡? → String 소유를 고려하세요
```

---

## 다음 장 예고

> **11장. 클로저와 이터레이터**에서는 함수를 값처럼 다루는 방법을 배웁니다.
> 클로저로 간결한 코드를 작성하고, 이터레이터로 컬렉션을 우아하게 처리하는 법을 알아봅니다!
