# 04장. 소유권 (Ownership)

> **목표**: Rust의 핵심 개념인 소유권을 이해하고, 안전한 메모리 관리 방식을 익힌다.
> ⭐ **이 장은 Rust에서 가장 중요한 장입니다. 확실히 이해하고 넘어가세요!**

---

## 1. 소유권이란?

Rust에는 **소유권(Ownership)** 이라는 독특한 규칙이 있습니다.

### 소유권의 3가지 규칙

1. **모든 값에는 주인(owner)이 있다**
2. **주인은 한 번에 하나만 존재한다**
3. **주인이 사라지면 값도 사라진다** (자동 메모리 해제)

### 비유로 이해하기

```
책 한 권이 있습니다.

- 이 책의 주인은 한 명입니다 (규칙 2)
- 주인이 이사를 가면 책도 함께 갑니다 (규칙 1)
- 주인이 방을 나가면 책도 정리됩니다 (규칙 3)

하지만! 복사하거나 빌려줄 수는 있습니다. (뒤에서 배웁니다)
```

### 코드로 보기

```rust
fn main() {
    let s = String::from("hello"); // s가 "hello"의 주인
    println!("{}", s);              // s를 사용
} // ← 여기서 s가 사라지면서 "hello" 메모리도 자동 해제
```

`s`가 `"hello"`라는 값의 주인입니다. `main` 함수가 끝나면 `s`가 사라지고, 메모리도 자동으로 정리됩니다.

<details>
<summary><b>🔍 다른 언어는 메모리를 어떻게 관리하나요? (원리)</b></summary>

### 3가지 메모리 관리 방식

프로그래밍 언어마다 메모리를 관리하는 방법이 다릅니다.

**1. 가비지 컬렉터 (GC) - Java, Python, JavaScript, Go**
```
프로그램 실행 중에 "쓰레기 수거원"이 돌아다니면서
안 쓰는 메모리를 자동으로 정리합니다.

장점: 편합니다. 개발자가 신경 안 써도 됩니다.
단점: 수거원이 일하는 동안 프로그램이 잠깐 멈출 수 있습니다.
      메모리도 더 많이 사용합니다.
```

**2. 수동 관리 - C, C++**
```
개발자가 직접 메모리를 할당하고 해제합니다.

장점: 가장 빠르고 효율적입니다.
단점: 실수하면 프로그램이 죽습니다.
      - 해제를 깜빡하면 → 메모리 누수
      - 두 번 해제하면 → 프로그램 충돌
      - 해제 후 사용하면 → 보안 취약점
```

**3. 소유권 시스템 - Rust**
```
컴파일러가 코드를 분석해서 메모리가 언제 해제되어야 하는지 파악합니다.
프로그램 실행 전에 이미 결정됩니다.

장점: GC 없이도 안전합니다. 실행 속도도 C/C++급입니다.
단점: 처음에 배우기가 어렵습니다. (지금 이 장!)
```

| 방식 | 속도 | 안전성 | 편의성 |
|------|------|--------|--------|
| GC (Java 등) | 보통 | 안전 | 쉬움 |
| 수동 (C/C++) | 빠름 | 위험 | 어려움 |
| **소유권 (Rust)** | **빠름** | **안전** | **처음엔 어려움** |

Rust는 "빠르면서도 안전한" 두 마리 토끼를 잡은 겁니다.

</details>

---

## 2. 이동 (Move)

`String` 같은 힙 데이터를 다른 변수에 대입하면, 값이 **이동(Move)** 합니다.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1의 소유권이 s2로 이동!

    // println!("{}", s1); // ❌ 에러! s1은 더 이상 주인이 아님
    println!("{}", s2);    // ✅ s2가 새 주인
}
```

이동 후에는 원래 변수를 **사용할 수 없습니다**.

```
이동 전:  s1 ──→ "hello" (힙 메모리)

이동 후:  s1 ──✕ (더 이상 사용 불가)
          s2 ──→ "hello" (힙 메모리)
```

### 에러 메시지 읽어보기

위 코드에서 `s1`을 사용하면 컴파일러가 이렇게 알려줍니다:

```
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:20
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!("{}", s1);
  |                    ^^ value borrowed here after move
```

> 컴파일러가 "s1의 값이 s2로 이동했는데, 이동 후에 s1을 쓰려고 했어요"라고 정확히 알려줍니다.

<details>
<summary><b>🔍 왜 이동이 필요한가요? (원리)</b></summary>

### double free 문제

만약 이동 없이 `s1`과 `s2`가 **같은 메모리**를 가리킨다면 어떻게 될까요?

```
s1 ──┐
     ├──→ "hello" (힙 메모리)
s2 ──┘
```

함수가 끝나면 `s1`과 `s2`가 둘 다 사라집니다. 이때 같은 메모리를 **두 번 해제**하게 됩니다.

```
1. s2가 사라짐 → "hello" 메모리 해제 ✅
2. s1이 사라짐 → 이미 해제된 메모리를 또 해제 ❌ 충돌!
```

이것을 **double free** 문제라고 합니다. C/C++에서 실제로 자주 발생하는 심각한 버그입니다.

### Rust의 해결책: 이동

Rust는 대입 시 소유권을 **이동**시킵니다. 그러면 주인이 항상 하나이므로 메모리는 정확히 한 번만 해제됩니다.

```
이동 후:
s1 ──✕ (무효화, 메모리 해제 안 함)
s2 ──→ "hello" (s2가 사라질 때 한 번만 해제) ✅
```

### 메모리 그림으로 보기

```
스택 (Stack)              힙 (Heap)
┌──────────────┐         ┌──────────┐
│ s1           │         │          │
│  ptr ───────────✕      │ "hello"  │
│  len: 5      │         │          │
│  capacity: 5 │         └──────────┘
├──────────────┤              ↑
│ s2           │              │
│  ptr ────────────────────────
│  len: 5      │
│  capacity: 5 │
└──────────────┘
```

`s1`의 포인터가 무효화되고, `s2`의 포인터만 힙의 `"hello"`를 가리킵니다.

</details>

---

## 3. 복사 (Copy)

모든 타입이 이동하는 건 아닙니다. **정수, 실수, 불리언, 문자** 같은 스택 데이터는 **자동으로 복사**됩니다.

```rust
fn main() {
    let x = 5;
    let y = x; // 복사! x도 여전히 사용 가능

    println!("x = {}, y = {}", x, y); // ✅ 둘 다 사용 가능
}
```

### 이동 vs 복사

```
String (힙 데이터) → 이동
let s1 = String::from("hello");
let s2 = s1;  // s1 사용 불가

정수 (스택 데이터) → 복사
let x = 5;
let y = x;    // x, y 둘 다 사용 가능
```

### Copy가 되는 타입들

| 타입 | 예시 | Copy 여부 |
|------|------|-----------|
| 정수 | `i32`, `u64` 등 | ✅ 복사 |
| 실수 | `f32`, `f64` | ✅ 복사 |
| 불리언 | `bool` | ✅ 복사 |
| 문자 | `char` | ✅ 복사 |
| 튜플 (Copy 타입만) | `(i32, f64)` | ✅ 복사 |
| **String** | `String` | ❌ **이동** |
| **Vec** | `Vec<i32>` | ❌ **이동** |

> 규칙: **스택에 고정 크기로 저장되는 단순한 타입**은 복사됩니다. **힙을 사용하는 타입**은 이동됩니다.

### clone()으로 명시적 깊은 복사

힙 데이터도 정말 복사하고 싶다면 `clone()`을 사용합니다:

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // 힙 데이터를 통째로 복사

    println!("s1 = {}, s2 = {}", s1, s2); // ✅ 둘 다 사용 가능
}
```

```
clone() 후:
s1 ──→ "hello" (힙 메모리 A)
s2 ──→ "hello" (힙 메모리 B)  ← 완전히 별도의 복사본
```

> `clone()`은 힙 메모리를 통째로 복사하므로 비용이 큽니다. 꼭 필요할 때만 사용하세요.

---

## 4. 참조와 빌림 (References & Borrowing)

매번 소유권을 이동하면 불편합니다. 값을 **빌려서** 사용하는 방법이 있습니다.

### 불변 참조 (&) - 읽기만

```rust
fn main() {
    let s = String::from("hello");

    let len = calculate_length(&s); // s를 빌려줌 (소유권은 유지!)

    println!("'{}'의 길이는 {}입니다.", s, len); // ✅ s 사용 가능
}

fn calculate_length(s: &String) -> usize {
    s.len()
} // s는 빌린 것이므로 여기서 메모리 해제 안 함
```

`&s`는 `s`의 **참조(reference)** 입니다. 소유권은 이동하지 않고, 값만 읽을 수 있습니다.

```
소유권 이동:  값을 "줌"    → 돌려받을 수 없음
참조 (&):    값을 "빌려줌" → 다 쓰면 자동으로 돌아옴
```

### 가변 참조 (&mut) - 수정도 가능

```rust
fn main() {
    let mut s = String::from("hello");

    add_world(&mut s); // 수정 가능하게 빌려줌

    println!("{}", s); // hello world
}

fn add_world(s: &mut String) {
    s.push_str(" world");
}
```

가변 참조를 사용하려면:
1. 원래 변수가 `mut`이어야 합니다
2. 빌려줄 때 `&mut`을 사용합니다
3. 받는 쪽 매개변수 타입도 `&mut`이어야 합니다

### 비유: 책 빌려주기

```
불변 참조 (&):
  "이 책 읽어도 돼, 근데 낙서하지 마."
  → 여러 명에게 동시에 빌려줄 수 있음

가변 참조 (&mut):
  "이 책 가져가서 필기해도 돼."
  → 한 명에게만 빌려줄 수 있음 (동시에 누가 바꾸면 혼란!)
```

### 빌림 규칙

```rust
fn main() {
    let mut s = String::from("hello");

    // ✅ 불변 참조 여러 개 - OK
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2);

    // ✅ 가변 참조 하나 - OK
    let r3 = &mut s;
    r3.push_str(" world");
    println!("{}", r3);
}
```

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s;        // 불변 참조
    // let r2 = &mut s;  // ❌ 에러! 불변 참조가 있는 동안 가변 참조 불가
    println!("{}", r1);
}
```

**정리**:
| 규칙 | 설명 |
|------|------|
| 불변 참조 여러 개 | ✅ 동시에 가능 |
| 가변 참조 하나만 | ✅ 하나만 가능 |
| 불변 + 가변 동시 | ❌ 불가능 |

<details>
<summary><b>🔍 왜 가변 참조가 하나만 가능한가요? (원리)</b></summary>

### 데이터 레이스(Data Race) 방지

데이터 레이스는 다음 3가지가 **동시에** 일어날 때 발생합니다:

1. 두 개 이상의 포인터가 같은 데이터에 접근
2. 최소 하나가 데이터를 **쓰려고** 함
3. 접근 순서가 동기화되지 않음

```
가변 참조가 2개 허용된다면:

코드 A: s의 길이를 읽는 중... (len = 5)
코드 B: s에 " world"를 추가함! (len = 11)
코드 A: 아까 읽은 길이 5를 기반으로 작업 → 버그!
```

다른 언어에서는 이런 문제가 **실행 중**에 발생해서 찾기 어렵습니다.
Rust는 이것을 **컴파일 단계**에서 원천 차단합니다.

- 불변 참조만 여러 개 → 아무도 안 바꾸니까 안전
- 가변 참조 딱 하나 → 바꾸는 사람이 한 명이니까 안전
- 불변 + 가변 동시 → 누가 읽는 중에 바꿀 수 있으니까 위험!

이 규칙 덕분에 Rust 프로그램은 **데이터 레이스가 발생할 수 없습니다**.

</details>

---

## 5. 함수와 소유권

### 함수에 값을 넘기면 소유권이 이동한다

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s);      // s의 소유권이 함수로 이동

    // println!("{}", s);    // ❌ 에러! s는 이미 이동됨
}

fn takes_ownership(some_string: String) {
    println!("{}", some_string);
} // some_string이 사라지면서 메모리 해제
```

### Copy 타입은 복사된다

```rust
fn main() {
    let x = 5;
    makes_copy(x);        // x는 Copy 타입이므로 복사됨

    println!("{}", x);     // ✅ x 사용 가능
}

fn makes_copy(some_integer: i32) {
    println!("{}", some_integer);
}
```

### 참조로 넘기면 소유권이 유지된다

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s); // 빌려주기만 함

    println!("'{}'의 길이: {}", s, len); // ✅ s 사용 가능
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### 함수에서 값을 반환하면 소유권이 넘어온다

```rust
fn main() {
    let s = create_string(); // 함수에서 만든 값의 소유권을 받음
    println!("{}", s);        // ✅ s가 주인
}

fn create_string() -> String {
    let s = String::from("hello");
    s // 소유권을 호출자에게 반환
}
```

### 소유권 흐름 한눈에 보기

```
함수에 값 넘기기:
  String → 이동 (원래 변수 사용 불가)
  i32    → 복사 (원래 변수 사용 가능)
  &String → 빌림 (원래 변수 사용 가능) ← 가장 많이 쓰는 패턴!

함수에서 반환:
  String → 호출자에게 소유권 이전
```

---

## 6. 라이프타임 기초 (맛보기)

**참조는 원본보다 오래 살 수 없습니다.**

### 댕글링 참조 방지

```rust
fn main() {
    // let r = dangle(); // ❌ 에러!
}

// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s // s는 함수가 끝나면 사라지는데, 사라질 값의 참조를 반환?
// } // s가 사라짐 → &s는 아무것도 가리키지 않음 (댕글링!)
```

이미 사라진 메모리를 가리키는 참조를 **댕글링 참조(dangling reference)** 라고 합니다.

Rust 컴파일러는 이런 코드를 허용하지 않습니다.

### 올바른 방법: 소유권을 반환

```rust
fn main() {
    let s = no_dangle();
    println!("{}", s);
}

fn no_dangle() -> String {
    let s = String::from("hello");
    s // 참조가 아니라 값 자체(소유권)를 반환 ✅
}
```

> 라이프타임에 대한 자세한 내용은 **10장. 라이프타임 심화**에서 다룹니다.
> 지금은 "참조는 원본이 살아있는 동안만 유효하다"는 것만 기억하세요.

---

## 7. 실습

### 실습 1: 소유권 이동 문제를 참조로 해결하기

아래 코드는 소유권 이동 때문에 에러가 발생합니다. **참조**를 사용해서 수정하세요.

```rust
// ❌ 에러가 나는 코드
fn main() {
    let message = String::from("Rust 소유권을 이해했다!");
    print_message(message);
    println!("다시 출력: {}", message); // 에러! message가 이동됨
}

fn print_message(msg: String) {
    println!("{}", msg);
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
fn main() {
    let message = String::from("Rust 소유권을 이해했다!");
    print_message(&message);                  // &로 빌려주기
    println!("다시 출력: {}", message);        // ✅ 사용 가능
}

fn print_message(msg: &String) {              // &String으로 받기
    println!("{}", msg);
}
```

**핵심**: `message`를 함수에 줄 때 `&message`로 빌려주면 소유권이 이동하지 않습니다.

</details>

### 실습 2: 문자열의 길이를 반환하는 함수 (소유권 안 뺏기)

`String`을 받아서 **길이를 반환**하는 함수를 작성하세요. 호출 후에도 원래 변수를 사용할 수 있어야 합니다.

```rust
fn main() {
    let name = String::from("Rustacean");
    let len = get_length(/* 여기를 채우세요 */);

    // 아래 두 줄이 모두 동작해야 합니다
    println!("문자열: {}", name);
    println!("길이: {}", len);
}

// 이 함수를 완성하세요
fn get_length(/* 매개변수 */) -> usize {
    // 구현
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
fn main() {
    let name = String::from("Rustacean");
    let len = get_length(&name);

    println!("문자열: {}", name);  // ✅ 소유권 유지
    println!("길이: {}", len);     // 길이: 9
}

fn get_length(s: &String) -> usize {
    s.len()
}
```

**핵심**: `&String`으로 참조를 받으면 소유권을 가져오지 않으므로, 함수 호출 후에도 `name`을 사용할 수 있습니다.

</details>

### 실습 3: 가변 참조로 벡터에 요소 추가하기

가변 참조(`&mut`)를 사용해서 벡터에 요소를 추가하는 함수를 작성하세요.

```rust
fn main() {
    let mut scores = vec![80, 90, 75];
    println!("추가 전: {:?}", scores);

    add_score(/* 여기를 채우세요 */, 95);
    add_score(/* 여기를 채우세요 */, 88);

    println!("추가 후: {:?}", scores); // [80, 90, 75, 95, 88]
}

// 이 함수를 완성하세요
fn add_score(/* 매개변수 */) {
    // 구현
}
```

<details>
<summary><b>정답 보기</b></summary>

```rust
fn main() {
    let mut scores = vec![80, 90, 75];
    println!("추가 전: {:?}", scores);

    add_score(&mut scores, 95);
    add_score(&mut scores, 88);

    println!("추가 후: {:?}", scores); // [80, 90, 75, 95, 88]
}

fn add_score(scores: &mut Vec<i32>, score: i32) {
    scores.push(score);
}
```

**핵심**:
- `scores`가 `let mut`으로 선언되어 있어야 합니다
- 함수에 `&mut scores`로 가변 참조를 전달합니다
- 함수 매개변수 타입은 `&mut Vec<i32>`입니다
- 가변 참조이므로 `push()`로 수정할 수 있습니다

</details>

---

## 8. 확인 문제

### 문제 1
아래 코드의 실행 결과는?
```rust
fn main() {
    let x = 42;
    let y = x;
    println!("x = {}, y = {}", x, y);
}
```
- (a) 컴파일 에러 (x가 이동됨)
- (b) `x = 42, y = 42`
- (c) `x = 0, y = 42`
- (d) 런타임 에러

### 문제 2
아래 코드가 컴파일 에러가 나는 이유는?
```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    println!("{}", s1);
}
```

### 문제 3
아래 빈칸에 들어갈 코드로 올바른 것은?
```rust
fn main() {
    let s = String::from("hello");
    let len = get_len(______);
    println!("{} 의 길이: {}", s, len);
}

fn get_len(s: &String) -> usize {
    s.len()
}
```
- (a) `s`
- (b) `&s`
- (c) `&mut s`
- (d) `s.clone()`

### 문제 4
가변 참조(`&mut`)의 규칙으로 옳은 것은?
- (a) 동시에 여러 개 만들 수 있다
- (b) 불변 참조와 동시에 존재할 수 있다
- (c) 동시에 하나만 존재할 수 있다
- (d) 원래 변수가 불변이어도 만들 수 있다

### 문제 5
아래 코드에서 에러가 나는 줄 번호와 이유를 설명하세요.
```rust
fn main() {
    let mut s = String::from("hello");  // 1번
    let r1 = &s;                         // 2번
    let r2 = &s;                         // 3번
    let r3 = &mut s;                     // 4번
    println!("{}, {}, {}", r1, r2, r3);  // 5번
}
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답: **(b) `x = 42, y = 42`**
`i32`는 Copy 트레이트가 구현된 타입이므로 대입 시 **복사**됩니다. `x`도 `y`도 모두 사용할 수 있습니다.

### 문제 2 정답
`String`은 힙 데이터이므로 `let s2 = s1;`에서 소유권이 **이동(Move)** 됩니다. 이동 후 `s1`은 더 이상 유효하지 않으므로 `println!`에서 사용할 수 없습니다.

해결 방법:
- `let s2 = s1.clone();` (깊은 복사)
- `let s2 = &s1;` (참조로 빌리기)

### 문제 3 정답: **(b) `&s`**
함수가 `&String` 타입을 받으므로, 호출할 때 `&s`로 참조를 전달해야 합니다. 이렇게 하면 소유권이 이동하지 않아서 다음 줄에서 `s`를 계속 사용할 수 있습니다.

### 문제 4 정답: **(c) 동시에 하나만 존재할 수 있다**
가변 참조는 데이터 레이스를 방지하기 위해 한 번에 하나만 만들 수 있습니다. 또한 불변 참조가 활성화되어 있는 동안에는 가변 참조를 만들 수 없습니다.

### 문제 5 정답
**4번 줄**에서 에러가 발생합니다.

2번과 3번에서 불변 참조 `r1`, `r2`를 만들었고, 5번에서 아직 사용하고 있습니다. 그런데 4번에서 가변 참조 `r3`을 만들려고 하므로 **불변 참조와 가변 참조가 동시에 존재**하게 됩니다. 이것은 Rust의 빌림 규칙 위반입니다.

해결 방법:
```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &s;
    let r2 = &s;
    println!("{}, {}", r1, r2); // r1, r2 사용 끝

    let r3 = &mut s;            // 이제 가변 참조 가능
    println!("{}", r3);
}
```

불변 참조의 마지막 사용 이후에 가변 참조를 만들면 에러가 발생하지 않습니다.

</details>

---

## 9. 4장 정리

| 개념 | 핵심 내용 | 예시 |
|------|-----------|------|
| 소유권 규칙 | 모든 값에 주인 하나, 주인이 사라지면 값도 사라짐 | `let s = String::from("hi");` |
| 이동 (Move) | 힙 데이터 대입 시 소유권 이동, 원래 변수 사용 불가 | `let s2 = s1;` |
| 복사 (Copy) | 스택 데이터(`i32`, `bool` 등)는 자동 복사 | `let y = x;` |
| clone() | 힙 데이터의 명시적 깊은 복사 | `let s2 = s1.clone();` |
| 불변 참조 (&) | 읽기 전용으로 빌려주기, 여러 개 가능 | `let r = &s;` |
| 가변 참조 (&mut) | 수정 가능하게 빌려주기, 하나만 가능 | `let r = &mut s;` |
| 함수와 소유권 | 인자 전달 시 이동/복사, 참조로 빌림 가능 | `fn f(s: &String)` |
| 댕글링 참조 | 사라진 값의 참조는 컴파일러가 차단 | 컴파일 에러로 방지 |

---

## 다음 장 예고

> **05장. 구조체와 열거형**에서는 여러 데이터를 하나로 묶는 방법을 배웁니다.
> 구조체(struct)로 사용자 정의 타입을 만들고, 열거형(enum)으로 상태를 표현합니다.
> 웹서버에서 요청/응답 데이터를 다룰 때 핵심이 되는 내용입니다!
