# 13장. 동시성 프로그래밍

> **목표**: 스레드를 활용한 동시성 프로그래밍의 기초를 이해한다.
> 웹서버는 여러 요청을 동시에 처리해야 합니다. 이 장이 그 기반이 됩니다!

---

## 1. 동시성이란?

### 동시성(Concurrency) vs 병렬성(Parallelism)

이 두 개념은 비슷해 보이지만 다릅니다.

```
동시성 (Concurrency):
  요리사 한 명이 파스타도 끓이고, 샐러드도 만들고, 수프도 저어요.
  한 번에 하나씩 하지만, 번갈아 가며 해서 전부 "동시에 진행"됩니다.

병렬성 (Parallelism):
  요리사 세 명이 각자 파스타, 샐러드, 수프를 맡아서 진짜로 동시에 합니다.
```

| 구분 | 동시성 | 병렬성 |
|------|--------|--------|
| 핵심 | 여러 작업을 **번갈아** 처리 | 여러 작업을 **동시에** 처리 |
| 필요한 것 | CPU 1개로도 가능 | CPU 여러 개(코어)가 필요 |
| 비유 | 요리사 1명, 요리 여러 개 | 요리사 여러 명, 각자 1개씩 |

### 왜 웹서버에 필요한가?

웹서버는 수백, 수천 명의 사용자가 동시에 요청을 보냅니다. 한 요청씩 순서대로 처리하면 나머지 사용자는 계속 기다려야 합니다.

```
❌ 순차 처리:
  사용자A 요청 → [처리 3초] → 응답
                              사용자B 요청 → [처리 3초] → 응답
                                                          사용자C 요청 → ...
  총 9초 이상!

✅ 동시 처리:
  사용자A 요청 → [처리 3초] → 응답
  사용자B 요청 → [처리 3초] → 응답     ← 거의 동시에 시작!
  사용자C 요청 → [처리 3초] → 응답
  총 약 3초!
```

---

## 2. 스레드 생성과 관리

**스레드(Thread)**는 프로그램 안에서 독립적으로 실행되는 작업 단위입니다.

### thread::spawn()으로 스레드 만들기

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 새 스레드 생성
    thread::spawn(|| {
        for i in 1..5 {
            println!("새 스레드: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });

    // 메인 스레드
    for i in 1..3 {
        println!("메인 스레드: {}", i);
        thread::sleep(Duration::from_millis(100));
    }

    println!("메인 종료!");
}
```

```
실행 결과 (순서가 매번 다를 수 있음):
메인 스레드: 1
새 스레드: 1
메인 스레드: 2
새 스레드: 2
메인 종료!
```

> **주의**: 메인 스레드가 끝나면 새 스레드도 강제로 종료됩니다! 위 결과에서 새 스레드의 3, 4는 출력되지 않았습니다.

### join()으로 스레드 기다리기

`join()`을 호출하면 해당 스레드가 끝날 때까지 기다립니다.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("새 스레드: {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });

    for i in 1..3 {
        println!("메인 스레드: {}", i);
        thread::sleep(Duration::from_millis(100));
    }

    // 새 스레드가 끝날 때까지 기다림
    handle.join().unwrap();

    println!("모든 작업 완료!");
}
```

```
실행 결과:
메인 스레드: 1
새 스레드: 1
메인 스레드: 2
새 스레드: 2
새 스레드: 3
새 스레드: 4
모든 작업 완료!
```

이제 새 스레드의 모든 출력이 나온 뒤에야 "모든 작업 완료!"가 출력됩니다.

### move 클로저로 소유권 이동

스레드에서 외부 데이터를 사용하려면 `move` 키워드가 필요합니다.

```rust
use std::thread;

fn main() {
    let name = String::from("Rust");

    // ❌ 이렇게 하면 에러!
    // thread::spawn(|| {
    //     println!("안녕, {}!", name);  // name을 빌리려 하지만...
    // });
    // 새 스레드가 name보다 오래 살 수 있으므로 컴파일러가 거부

    // ✅ move로 소유권을 스레드에 넘김
    let handle = thread::spawn(move || {
        println!("안녕, {}!", name);
    });

    // println!("{}", name);  // ❌ 소유권이 이동되어 사용 불가

    handle.join().unwrap();
}
```

`move`를 붙이면 클로저가 사용하는 변수의 소유권이 스레드로 이동합니다. 스레드가 언제 끝날지 모르기 때문에, Rust는 소유권을 확실히 넘기도록 강제합니다.

<details>
<summary><b>🔍 스레드가 OS 수준에서 어떻게 동작하나? (원리)</b></summary>

### OS 스레드와 Rust 스레드

Rust의 `thread::spawn()`은 **운영체제(OS) 스레드**를 직접 생성합니다. 이것을 1:1 스레딩 모델이라고 합니다.

```
Rust 프로그램
├── 메인 스레드 ─────→ OS 스레드 1 ─────→ CPU 코어 A
├── spawn 스레드 1 ──→ OS 스레드 2 ─────→ CPU 코어 B
└── spawn 스레드 2 ──→ OS 스레드 3 ─────→ CPU 코어 A (번갈아 사용)
```

**OS 스레드의 특징**:
- 각 스레드는 **독립적인 스택 메모리**를 가집니다 (보통 2~8MB)
- OS의 **스케줄러**가 어떤 스레드를 언제 실행할지 결정합니다
- CPU 코어가 여러 개이면 **진짜 병렬로** 실행될 수 있습니다
- 스레드 생성/전환에 비용이 들어, 수천 개를 만들면 느려집니다

**다른 모델과 비교**:

| 모델 | 언어 | 스레드 수 | 비용 |
|------|------|-----------|------|
| 1:1 (OS 스레드) | Rust, Java, C++ | 수백~수천 | 무거움 |
| M:N (그린 스레드) | Go (goroutine) | 수십만 | 가벼움 |
| 비동기 태스크 | Rust (tokio), JS | 수십만 | 가벼움 |

Rust는 OS 스레드를 기본으로 제공하고, 가벼운 동시성이 필요하면 **14장의 async/await**를 사용합니다. 웹서버에서는 주로 async를 쓰게 됩니다.

</details>

---

## 3. 메시지 패싱 (Channel)

스레드 간에 데이터를 주고받는 안전한 방법입니다.

### mpsc::channel()

`mpsc`는 **Multiple Producer, Single Consumer**의 약자입니다. "보내는 쪽은 여러 개, 받는 쪽은 하나"라는 뜻입니다.

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    // 채널 생성: tx(보내기), rx(받기)
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let msg = String::from("안녕하세요!");
        tx.send(msg).unwrap();
        // println!("{}", msg);  // ❌ send()로 소유권이 이동됨!
    });

    // 메인 스레드에서 메시지 수신
    let received = rx.recv().unwrap();
    println!("받은 메시지: {}", received);
    // 받은 메시지: 안녕하세요!
}
```

- `tx.send(값)`: 값을 채널로 보냅니다 (소유권이 이동!)
- `rx.recv()`: 메시지가 올 때까지 **기다렸다가** 받습니다
- `rx.try_recv()`: 기다리지 않고, 메시지가 있으면 받고 없으면 에러 반환

### 여러 메시지 보내고 for로 수신

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let messages = vec![
            String::from("첫 번째"),
            String::from("두 번째"),
            String::from("세 번째"),
        ];

        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(200));
        }
        // tx가 여기서 drop됨 → 채널이 닫힘
    });

    // rx를 이터레이터처럼 사용: 채널이 닫힐 때까지 반복
    for received in rx {
        println!("수신: {}", received);
    }
}
```

```
실행 결과 (0.2초 간격으로 출력):
수신: 첫 번째
수신: 두 번째
수신: 세 번째
```

`for received in rx`는 채널에서 메시지가 올 때마다 받고, 송신자(`tx`)가 사라져서 채널이 닫히면 반복이 끝납니다.

### 여러 생산자: tx.clone()

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx1 = tx.clone(); // tx를 복제해서 다른 스레드에게 줌
    thread::spawn(move || {
        tx1.send(String::from("스레드1: 안녕!")).unwrap();
    });

    thread::spawn(move || {
        tx.send(String::from("스레드2: 반가워!")).unwrap();
    });

    // 두 스레드의 메시지를 모두 수신
    for received in rx {
        println!("{}", received);
    }
}
```

```
실행 결과 (순서는 달라질 수 있음):
스레드1: 안녕!
스레드2: 반가워!
```

`tx.clone()`으로 송신자를 복제하면 여러 스레드가 같은 채널로 메시지를 보낼 수 있습니다.

<details>
<summary><b>🔍 "메모리를 공유하지 말고, 통신으로 메모리를 공유하라" 철학 (원리)</b></summary>

### Go 언어에서 온 유명한 격언

> "Do not communicate by sharing memory; instead, share memory by communicating."

이 말의 의미를 코드로 비교해보겠습니다.

**메모리를 공유하는 방식 (위험할 수 있음)**:
```
스레드A ──┐
          ├──→ [공유 데이터] ← 누가 먼저? 충돌 위험!
스레드B ──┘
```

여러 스레드가 같은 데이터에 직접 접근합니다. 동시에 읽고 쓰면 데이터가 꼬일 수 있어서, 잠금(Mutex) 등으로 보호해야 합니다.

**통신으로 공유하는 방식 (채널)**:
```
스레드A → [메시지] → 채널 → [메시지] → 스레드B
```

데이터의 소유권이 메시지와 함께 이동합니다. 한 번에 하나의 스레드만 데이터를 소유하므로, 충돌이 원천적으로 불가능합니다.

Rust의 채널은 `send()`할 때 소유권이 이동하므로 이 철학을 자연스럽게 구현합니다:

```rust
tx.send(data).unwrap();
// data는 이제 이 스레드에서 사용 불가!
// 받는 쪽 스레드만 data를 사용할 수 있음
```

물론 현실에서는 공유 상태(Mutex)가 필요한 경우도 있습니다. 다음 절에서 배웁니다.

</details>

---

## 4. 공유 상태 - Mutex

채널은 "데이터를 보내는" 방식이지만, 때로는 여러 스레드가 **같은 데이터를 공유**해야 할 때가 있습니다.

### Mutex\<T>로 상호 배제

`Mutex`는 **Mut**ual **Ex**clusion의 줄임말로, "한 번에 하나만 접근"이라는 뜻입니다.

```rust
use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        // lock()으로 잠금 획득 → 값에 접근 가능
        let mut num = m.lock().unwrap();
        *num = 6;
        println!("값: {}", num); // 값: 6
    } // 여기서 잠금이 자동으로 해제됨

    println!("최종 값: {:?}", m); // 최종 값: Mutex { data: 6, .. }
}
```

- `m.lock()`: 잠금을 획득합니다. 다른 스레드가 잠금을 가지고 있으면 **기다립니다**
- 반환된 값(`MutexGuard`)이 스코프를 벗어나면 자동으로 잠금이 해제됩니다
- `*num = 6`: `MutexGuard`는 `Deref`를 구현하므로 `*`로 내부 값에 접근합니다

### 비유: 화장실 잠금장치

```
Mutex는 화장실 잠금장치와 같습니다.

1. lock() 호출 = 문을 잠그고 들어감
2. 데이터 사용 = 화장실 사용
3. 스코프 끝 = 나오면서 자동으로 문 열림
4. 다른 사람이 기다리고 있으면 그 사람이 들어감

핵심: 한 번에 한 명만 사용 가능!
```

### Arc\<Mutex\<T>>로 스레드 간 공유

여러 스레드에서 Mutex를 공유하려면 `Arc` (Atomic Reference Counting)이 필요합니다. 12장에서 배운 `Rc<T>`의 스레드 안전 버전입니다.

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter); // Arc를 복제 (데이터는 공유)
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    // 모든 스레드가 끝날 때까지 기다림
    for handle in handles {
        handle.join().unwrap();
    }

    println!("결과: {}", *counter.lock().unwrap());
    // 결과: 10
}
```

**왜 `Rc<T>` 대신 `Arc<T>`를 써야 하나?**

`Rc<T>`는 참조 카운트를 증가/감소할 때 원자적(atomic) 연산을 사용하지 않아서, 여러 스레드가 동시에 조작하면 카운트가 꼬일 수 있습니다. `Arc<T>`는 원자적 연산을 사용해서 스레드 안전합니다.

```
Rc<T>  → 단일 스레드에서만 사용 (빠름)
Arc<T> → 여러 스레드에서 공유 가능 (약간 느리지만 안전)
```

<details>
<summary><b>🔍 데드락(Deadlock)이란? 어떻게 방지하나? (원리)</b></summary>

### 데드락: 서로 기다리며 영원히 멈추는 상태

```
스레드A: Mutex1을 잠금 → Mutex2를 잠그려고 기다림...
스레드B: Mutex2를 잠금 → Mutex1을 잠그려고 기다림...
→ 둘 다 영원히 기다림! (데드락)
```

비유로 이해하면:

```
좁은 복도에서 두 사람이 마주침:
사람A: "상대가 비켜줄 때까지 안 비킬 거야"
사람B: "상대가 비켜줄 때까지 안 비킬 거야"
→ 둘 다 영원히 서 있음
```

### 데드락 발생 코드 예시

```rust
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let lock1 = Arc::new(Mutex::new(0));
    let lock2 = Arc::new(Mutex::new(0));

    let l1 = Arc::clone(&lock1);
    let l2 = Arc::clone(&lock2);

    let handle1 = thread::spawn(move || {
        let _a = l1.lock().unwrap();    // lock1 획득
        // 여기서 시간이 좀 걸린다면...
        let _b = l2.lock().unwrap();    // lock2를 기다림
    });

    let l1 = Arc::clone(&lock1);
    let l2 = Arc::clone(&lock2);

    let handle2 = thread::spawn(move || {
        let _b = l2.lock().unwrap();    // lock2 획득
        // 여기서 시간이 좀 걸린다면...
        let _a = l1.lock().unwrap();    // lock1을 기다림
    });

    handle1.join().unwrap();
    handle2.join().unwrap();
    // 데드락 발생 가능!
}
```

### 방지 방법

1. **잠금 순서 고정**: 모든 스레드가 항상 같은 순서로 Mutex를 잠급니다
2. **잠금 범위 최소화**: `lock()`을 가능한 짧은 범위에서만 사용합니다
3. **채널 사용**: 가능하면 Mutex 대신 채널로 통신합니다
4. **try_lock()**: 잠금을 시도하고, 실패하면 기다리지 않고 다른 처리를 합니다

```rust
// 방지법 1: 항상 같은 순서로 잠금
let _a = lock1.lock().unwrap(); // 항상 lock1을 먼저!
let _b = lock2.lock().unwrap(); // 그 다음 lock2

// 방지법 2: 잠금 범위 최소화
{
    let mut data = mutex.lock().unwrap();
    *data += 1;
} // 여기서 바로 해제!
// 이후에 다른 무거운 작업 수행
```

Rust 컴파일러는 데이터 레이스는 방지하지만, **데드락은 방지하지 못합니다**. 설계 단계에서 주의해야 합니다.

</details>

---

## 5. Send와 Sync 트레이트

Rust가 스레드 안전성을 **컴파일 타임에** 보장할 수 있는 비밀은 이 두 트레이트에 있습니다.

### Send: 스레드 간 소유권 이동 가능

`Send` 트레이트가 구현된 타입은 소유권을 다른 스레드로 보낼 수 있습니다.

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3]; // Vec<i32>는 Send

    // move로 data의 소유권을 새 스레드로 이동 → OK!
    let handle = thread::spawn(move || {
        println!("{:?}", data);
    });

    handle.join().unwrap();
}
```

### Sync: 스레드 간 참조 공유 가능

`Sync` 트레이트가 구현된 타입은 여러 스레드에서 **참조(&T)**로 동시에 접근할 수 있습니다.

```
T가 Sync이면 → &T를 여러 스레드에서 안전하게 사용 가능
```

### 대부분의 타입은 자동으로 구현됨

| 타입 | Send | Sync | 설명 |
|------|------|------|------|
| `i32`, `String`, `Vec<T>` 등 | O | O | 대부분의 타입 |
| `Mutex<T>` | O | O | 스레드 간 공유 가능 |
| `Arc<T>` | O | O | 스레드 안전한 참조 카운팅 |
| `Rc<T>` | **X** | **X** | 단일 스레드 전용! |
| `Cell<T>`, `RefCell<T>` | O | **X** | 단일 스레드 내부 가변성 |

### Rc\<T>는 Send가 아님

```rust
use std::rc::Rc;
use std::thread;

fn main() {
    let data = Rc::new(5);

    // ❌ 컴파일 에러! Rc<i32>는 Send가 아님
    // thread::spawn(move || {
    //     println!("{}", data);
    // });
}
```

`Rc<T>`는 스레드 안전하지 않으므로, 스레드 간 공유가 필요하면 반드시 `Arc<T>`를 사용해야 합니다.

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(5);
    let data_clone = Arc::clone(&data);

    // ✅ Arc<i32>는 Send!
    let handle = thread::spawn(move || {
        println!("{}", data_clone);
    });

    handle.join().unwrap();
    println!("{}", data);
}
```

> **핵심 정리**: 스레드로 데이터를 보내려면 `Send`, 여러 스레드에서 참조를 공유하려면 `Sync`가 필요합니다. 대부분의 타입은 자동으로 둘 다 구현되지만, `Rc<T>`처럼 예외가 있으므로 컴파일러 에러를 잘 읽으세요.

---

## 6. 실습

### 실습 1: 두 스레드에서 각각 1~5, 6~10 출력하기

두 개의 스레드를 만들어서, 하나는 1~5를, 다른 하나는 6~10을 출력하세요. 두 스레드가 모두 끝난 뒤에 "완료!"를 출력해야 합니다.

```rust
use std::thread;

fn main() {
    let handle1 = thread::spawn(|| {
        for i in 1..=5 {
            println!("스레드1: {}", i);
        }
    });

    let handle2 = thread::spawn(|| {
        for i in 6..=10 {
            println!("스레드2: {}", i);
        }
    });

    handle1.join().unwrap();
    handle2.join().unwrap();

    println!("완료!");
}
```

```
실행 결과 (순서는 매번 달라질 수 있음):
스레드1: 1
스레드2: 6
스레드1: 2
스레드2: 7
스레드1: 3
스레드2: 8
스레드1: 4
스레드2: 9
스레드1: 5
스레드2: 10
완료!
```

**도전**: `thread::sleep()`을 추가해서 번갈아 출력되는 것을 더 명확하게 확인해보세요!

### 실습 2: 채널로 메시지 주고받기

작업자(worker) 스레드가 계산 결과를 채널을 통해 메인 스레드로 보내는 프로그램을 작성하세요.

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 작업자 스레드: 1~5의 제곱을 계산해서 보냄
    thread::spawn(move || {
        for i in 1..=5 {
            let result = i * i;
            println!("[작업자] {}의 제곱 = {} 전송!", i, result);
            tx.send((i, result)).unwrap();
        }
    });

    // 메인 스레드: 결과를 수신
    let mut total = 0;
    for (num, square) in rx {
        println!("[메인] 수신: {}의 제곱 = {}", num, square);
        total += square;
    }

    println!("합계: {}", total);
    // 합계: 55 (1 + 4 + 9 + 16 + 25)
}
```

**도전**: 작업자 스레드를 2개로 늘려서, 하나는 1~5의 제곱을, 다른 하나는 6~10의 제곱을 보내도록 만들어보세요! (`tx.clone()` 활용)

### 실습 3: Arc\<Mutex>로 카운터 만들기

5개의 스레드가 공유 카운터를 각각 100씩 증가시키는 프로그램을 작성하세요.

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for thread_id in 0..5 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                let mut num = counter.lock().unwrap();
                *num += 1;
            }
            println!("스레드 {} 작업 완료!", thread_id);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let final_count = *counter.lock().unwrap();
    println!("최종 카운터: {}", final_count);
    // 최종 카운터: 500 (5 스레드 x 100)
}
```

**도전**: 카운터 대신 `Vec<String>`을 공유해서, 각 스레드가 자신의 이름을 벡터에 추가하도록 바꿔보세요!

---

## 7. 확인 문제

### 문제 1
동시성(Concurrency)과 병렬성(Parallelism)의 차이로 올바른 것은?
- (a) 동시성은 여러 작업을 동시에 실행하고, 병렬성은 번갈아 실행한다
- (b) 동시성은 여러 작업을 번갈아 처리하고, 병렬성은 진짜 동시에 실행한다
- (c) 동시성과 병렬성은 같은 의미이다
- (d) 동시성은 CPU가 여러 개 필요하고, 병렬성은 하나로 충분하다

### 문제 2
아래 코드에서 에러가 나는 이유는?
```rust
use std::thread;

fn main() {
    let name = String::from("Rust");

    thread::spawn(|| {
        println!("{}", name);
    });
}
```

### 문제 3
`mpsc::channel()`에서 `mpsc`는 무엇의 약자이고, 어떤 의미인가?

### 문제 4
아래 빈칸을 채워서 스레드 안전한 공유 카운터를 만드세요:
```rust
use std::sync::{___, ___};
use std::thread;

fn main() {
    let counter = ___::new(___::new(0));

    let counter_clone = ___::clone(&counter);
    let handle = thread::spawn(move || {
        let mut num = counter_clone.___().unwrap();
        *num += 1;
    });

    handle.join().unwrap();
    println!("{}", *counter.lock().unwrap());
}
```

### 문제 5
다음 중 `Rc<T>` 대신 `Arc<T>`를 써야 하는 이유로 올바른 것은?
- (a) `Arc<T>`가 메모리를 더 적게 사용해서
- (b) `Rc<T>`는 `Send` 트레이트를 구현하지 않아 스레드 간 전송이 불가능해서
- (c) `Arc<T>`가 더 빠르기 때문에
- (d) `Rc<T>`는 값을 변경할 수 없어서

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답: **(b)**
동시성은 여러 작업을 번갈아 처리하는 것이고, 병렬성은 여러 CPU 코어를 사용해서 진짜 동시에 실행하는 것입니다.

### 문제 2 정답
클로저가 `name`의 참조를 캡처하려 하지만, 새 스레드가 `name`보다 오래 살 수 있어서 컴파일러가 거부합니다. `move` 키워드를 추가해서 소유권을 스레드로 이동시켜야 합니다.

```rust
thread::spawn(move || {
    println!("{}", name);
});
```

### 문제 3 정답
`mpsc`는 **Multiple Producer, Single Consumer**의 약자입니다. "다중 생산자, 단일 소비자"라는 뜻으로, 여러 스레드(생산자)가 메시지를 보낼 수 있지만 받는 쪽(소비자)은 하나라는 의미입니다. `tx.clone()`으로 송신자를 복제하면 여러 생산자를 만들 수 있습니다.

### 문제 4 정답

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));

    let counter_clone = Arc::clone(&counter);
    let handle = thread::spawn(move || {
        let mut num = counter_clone.lock().unwrap();
        *num += 1;
    });

    handle.join().unwrap();
    println!("{}", *counter.lock().unwrap()); // 1
}
```

`Arc`로 여러 스레드 간 공유를, `Mutex`로 상호 배제를 보장합니다.

### 문제 5 정답: **(b)**
`Rc<T>`는 참조 카운트를 원자적(atomic)으로 조작하지 않기 때문에 `Send` 트레이트를 구현하지 않습니다. 따라서 스레드 간 전송이 불가능합니다. `Arc<T>`는 원자적 연산을 사용해서 스레드 안전하게 참조 카운트를 관리합니다. 대신 원자적 연산의 오버헤드로 `Rc<T>`보다 약간 느립니다.

</details>

---

## 8. 13장 정리

| 개념 | 핵심 내용 | 사용 예 |
|------|-----------|---------|
| 스레드 생성 | `thread::spawn(move \|\| { })` | 독립적인 작업 실행 |
| 스레드 대기 | `handle.join().unwrap()` | 스레드 완료 보장 |
| 채널 (Channel) | `mpsc::channel()`, `tx.send()`, `rx.recv()` | 스레드 간 데이터 전달 |
| 여러 생산자 | `tx.clone()` | 다중 스레드에서 같은 채널로 전송 |
| Mutex | `Mutex::new(값)`, `lock().unwrap()` | 한 번에 하나만 접근 |
| Arc | `Arc::new()`, `Arc::clone()` | 스레드 간 안전한 소유권 공유 |
| Send | 소유권을 다른 스레드로 이동 가능 | 대부분의 타입 (Rc 제외) |
| Sync | 참조를 다른 스레드와 공유 가능 | 대부분의 타입 (Rc, RefCell 제외) |

### 언제 뭘 쓸까?

| 패턴 | 언제 쓰나 | 코드 |
|------|----------|------|
| Channel | 스레드 간 데이터 **전달** | `mpsc::channel()` |
| Arc\<Mutex\<T>> | 스레드 간 데이터 **공유** | `Arc::new(Mutex::new(값))` |
| 14장의 async | 웹서버 등 **I/O 중심** 동시성 | 다음 장에서! |

---

## 다음 장 예고

> **14장. 비동기 기초**에서는 `async`/`await`를 배웁니다.
> 이 장에서 배운 OS 스레드는 무겁고 수천 개를 만들기 어렵습니다. 웹서버처럼 수만 개의 연결을 처리하려면 **비동기 프로그래밍**이 필요합니다.
> Tokio 런타임과 함께 가볍고 효율적인 동시성을 구현하는 방법을 알아봅니다!
