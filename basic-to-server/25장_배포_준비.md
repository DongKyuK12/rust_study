# 25장. 배포 준비

> **목표**: Docker로 서버를 컨테이너화하고, 프로덕션 배포를 준비할 수 있다.

> 마지막 장입니다! 지금까지 만든 서버를 세상에 내보낼 준비를 합니다.

---

## 1. 릴리스 빌드

지금까지는 `cargo run`으로 개발 빌드를 사용했습니다. 프로덕션에서는 **릴리스 빌드**를 사용해야 합니다.

### cargo build --release

```bash
# 개발 빌드 (기본)
cargo build
# 결과: target/debug/my-api

# 릴리스 빌드
cargo build --release
# 결과: target/release/my-api
```

### 개발 빌드 vs 릴리스 빌드

| 구분 | 개발 빌드 (debug) | 릴리스 빌드 (release) |
|------|-------------------|----------------------|
| 컴파일 속도 | 빠름 | 느림 |
| 실행 속도 | 느림 | **빠름** (10~100배 차이) |
| 최적화 수준 | 0 (없음) | 3 (최대) |
| 디버그 정보 | 포함 | 제거 |
| 바이너리 크기 | 큼 | 작음 |
| 용도 | 개발, 테스트 | **프로덕션 배포** |

```bash
# 릴리스 모드로 직접 실행도 가능
cargo run --release
```

> 프로덕션에서 `cargo build` (debug)로 서버를 돌리면 성능이 크게 떨어집니다. 반드시 `--release`를 사용하세요.

<details>
<summary><b>🔍 최적화가 실제로 뭘 하는가? (원리)</b></summary>

### 컴파일러 최적화

릴리스 빌드에서 Rust 컴파일러(LLVM)가 수행하는 최적화의 예시입니다.

**인라이닝 (Inlining)**
```rust
// 원래 코드
fn add(a: i32, b: i32) -> i32 { a + b }
fn main() { let x = add(1, 2); }

// 최적화 후 (컴파일러가 자동으로)
fn main() { let x = 3; }  // 함수 호출 자체가 사라짐
```

**루프 최적화**
```rust
// 원래 코드
let mut sum = 0;
for i in 0..100 {
    sum += i;
}

// 최적화 후
let sum = 4950;  // 컴파일 시점에 계산 완료
```

**불필요한 검사 제거**

디버그 빌드에서는 정수 오버플로우 검사, 배열 범위 검사 등이 매 연산마다 수행됩니다. 릴리스 빌드에서는 안전하다고 판단되는 검사를 제거하여 속도를 높입니다.

`Cargo.toml`에서 프로필별 설정을 확인할 수 있습니다.

```toml
# 기본값 (직접 명시할 필요는 없음)
[profile.dev]
opt-level = 0    # 최적화 없음
debug = true     # 디버그 정보 포함

[profile.release]
opt-level = 3    # 최대 최적화
debug = false    # 디버그 정보 제거
```

</details>

---

## 2. 환경 변수 관리

### 개발 vs 프로덕션 환경 변수

| 환경 | 방법 | 예시 |
|------|------|------|
| 개발 | `.env` 파일 + dotenv | `DATABASE_URL=postgres://localhost/dev_db` |
| 프로덕션 | **시스템 환경 변수** | Docker, 클라우드 서비스에서 설정 |

`.env` 파일은 **개발 편의용**입니다. 프로덕션에서는 `.env` 파일을 사용하지 않고, 시스템 환경 변수나 컨테이너 설정으로 관리합니다.

```
# .env (개발용)
DATABASE_URL=postgres://localhost/my_app_dev
JWT_SECRET=dev-secret-key-not-for-production
SERVER_PORT=3000
```

> `.env` 파일을 Git에 올리면 안 됩니다! `.gitignore`에 반드시 추가하세요.

### 필수 환경 변수 검증 패턴

서버가 시작할 때 **필요한 환경 변수가 모두 있는지** 미리 확인합니다. 나중에 요청 처리 중 에러가 나는 것보다, 시작 시점에 실패하는 게 훨씬 낫습니다.

```rust
struct Config {
    database_url: String,
    jwt_secret: String,
    server_port: u16,
}

fn load_config() -> Result<Config, String> {
    // 각 환경 변수를 얼리 리턴으로 검증
    let database_url = std::env::var("DATABASE_URL")
        .map_err(|_| "DATABASE_URL이 설정되지 않았습니다".to_string())?;

    let jwt_secret = std::env::var("JWT_SECRET")
        .map_err(|_| "JWT_SECRET이 설정되지 않았습니다".to_string())?;

    let port_str = std::env::var("SERVER_PORT")
        .unwrap_or_else(|_| "3000".to_string());

    let server_port = port_str.parse::<u16>()
        .map_err(|_| format!("SERVER_PORT가 유효한 포트 번호가 아닙니다: {}", port_str))?;

    Ok(Config {
        database_url,
        jwt_secret,
        server_port,
    })
}

#[tokio::main]
async fn main() {
    // 서버 시작 전에 설정을 먼저 검증
    let config = match load_config() {
        Ok(config) => config,
        Err(err) => {
            eprintln!("설정 오류: {}", err);
            std::process::exit(1);
        }
    };

    println!("서버 시작: port={}", config.server_port);
    // 서버 실행...
}
```

```
# DATABASE_URL을 설정하지 않고 실행하면:
설정 오류: DATABASE_URL이 설정되지 않았습니다
```

> 필수 환경 변수는 서버 시작 시점에 **한 번에 모두 검증**하세요. "Fail Fast" 원칙입니다. 나중에 런타임 중간에 환경 변수가 없어서 에러가 나면 디버깅이 어렵습니다.

---

## 3. Docker로 컨테이너화

### Docker란?

비유로 설명하면, Docker는 **앱을 택배 상자에 포장**하는 기술입니다.

```
일반 배포:
"내 컴퓨터에서는 되는데..." → 서버에서는 안 됨 (환경 차이)

Docker 배포:
앱 + 필요한 모든 것 → 상자(컨테이너)에 포장 → 어디서든 똑같이 실행
```

| 개념 | 비유 | 설명 |
|------|------|------|
| Dockerfile | 포장 설명서 | 컨테이너를 만드는 레시피 |
| 이미지 (Image) | 포장된 상자 | 실행 가능한 패키지 |
| 컨테이너 (Container) | 상자를 열어 실행 | 이미지를 기반으로 실행 중인 인스턴스 |

### Dockerfile 작성

프로젝트 루트에 `Dockerfile`을 만듭니다.

```dockerfile
# ===== 1단계: 빌드 =====
FROM rust:1.75 AS builder
WORKDIR /app

# 의존성 캐싱을 위해 Cargo 파일만 먼저 복사
COPY Cargo.toml Cargo.lock ./
# 빈 소스 파일로 의존성만 먼저 빌드 (캐싱)
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -rf src

# 실제 소스 코드 복사 후 빌드
COPY src ./src
RUN touch src/main.rs
RUN cargo build --release

# ===== 2단계: 실행 =====
FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/my-api /usr/local/bin/my-api

EXPOSE 3000
CMD ["my-api"]
```

### 이미지 빌드 및 실행

```bash
# 이미지 빌드
docker build -t my-api .

# 컨테이너 실행
docker run -p 3000:3000 my-api

# 환경 변수를 전달하며 실행
docker run -p 3000:3000 \
  -e DATABASE_URL=postgres://db:5432/myapp \
  -e JWT_SECRET=super-secret-key \
  my-api
```

### docker-compose로 서버 + DB 함께 실행

실제 서비스에서는 서버와 데이터베이스를 **함께** 실행해야 합니다. `docker-compose.yml`을 사용하면 한 번에 관리할 수 있습니다.

```yaml
# docker-compose.yml
version: "3.8"

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypassword
      POSTGRES_DB: myapp
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgres://myuser:mypassword@db:5432/myapp
      JWT_SECRET: production-secret-key
    depends_on:
      - db

volumes:
  db_data:
```

```bash
# 서버 + DB 한 번에 시작
docker compose up

# 백그라운드에서 실행
docker compose up -d

# 중지
docker compose down
```

> `depends_on`은 **시작 순서만** 보장합니다. DB가 완전히 준비될 때까지 기다리지는 않습니다. 서버 코드에서 DB 연결 재시도 로직을 넣어야 합니다.

<details>
<summary><b>🔍 멀티스테이지 빌드가 왜 중요한가? (원리)</b></summary>

### 이미지 크기 비교

Rust 컴파일에는 많은 도구가 필요하지만, **실행**에는 바이너리 하나면 됩니다.

```
싱글 스테이지 (rust:1.75 이미지 그대로):
┌──────────────────────────────────┐
│ Rust 컴파일러 (수백 MB)            │
│ Cargo, 빌드 도구 (수백 MB)         │
│ 소스 코드                          │
│ 빌드 중간 산출물 (target/)          │
│ 최종 바이너리 (수 MB)              │
│                                   │
│ 총 이미지 크기: ~1.5GB             │
└──────────────────────────────────┘

멀티 스테이지:
빌드 단계 (임시)              실행 단계 (최종 이미지)
┌────────────────────┐       ┌──────────────────┐
│ Rust 컴파일러        │       │ 최소 OS (slim)     │
│ 소스 코드            │ ──→   │ 최종 바이너리만     │
│ 빌드 도구            │ 복사   │                   │
│ 최종 바이너리        │       │ 총 크기: ~80MB     │
└────────────────────┘       └──────────────────┘
    (삭제됨)
```

| 방식 | 이미지 크기 |
|------|------------|
| 싱글 스테이지 (`FROM rust:1.75`) | ~1.5GB |
| 멀티 스테이지 (`FROM debian:bookworm-slim`) | ~80MB |

1.5GB vs 80MB라면, 배포 시간과 저장 비용에서 큰 차이가 납니다.

### 의존성 캐싱 트릭

Dockerfile에서 `Cargo.toml`만 먼저 복사하고 빌드하는 이유가 있습니다.

```dockerfile
# 1. Cargo 파일만 먼저 복사
COPY Cargo.toml Cargo.lock ./
RUN cargo build --release  # 의존성만 빌드 (캐싱됨)

# 2. 소스 코드 복사 후 빌드
COPY src ./src
RUN cargo build --release  # 내 코드만 다시 빌드
```

Docker는 각 단계(레이어)를 **캐싱**합니다. 소스 코드만 바뀌고 의존성이 바뀌지 않았다면, 의존성 빌드 단계는 캐시에서 가져옵니다. 의존성 빌드에 수 분이 걸릴 수 있으므로, 이 캐싱 트릭은 반복 빌드 시간을 크게 줄여줍니다.

</details>

---

## 4. 로깅

### println!은 프로덕션용이 아닙니다

개발할 때 `println!`으로 디버깅했지만, 프로덕션에서는 **구조화된 로깅**이 필요합니다.

| 구분 | println! | tracing (로깅 크레이트) |
|------|----------|----------------------|
| 로그 레벨 | 없음 | ERROR, WARN, INFO, DEBUG, TRACE |
| 필터링 | 불가능 | 레벨별 필터링 가능 |
| 구조화 | 단순 텍스트 | 키-값 쌍으로 구조화 |
| 성능 | 항상 출력 | 레벨에 따라 건너뛰기 가능 |

### tracing 크레이트 설정

```toml
# Cargo.toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
```

```rust
use tracing::{info, warn, error, debug};

fn init_logging() {
    tracing_subscriber::fmt()
        .with_target(false)       // 모듈 경로 숨기기
        .with_max_level(tracing::Level::INFO)  // INFO 이상만 출력
        .init();
}

#[tokio::main]
async fn main() {
    init_logging();

    info!("서버 시작: port={}", 3000);
    // 2025-02-16T10:30:00.000Z  INFO 서버 시작: port=3000
}
```

### 로그 레벨

로그 레벨은 메시지의 **중요도**를 나타냅니다. 프로덕션에서는 보통 INFO 이상만 출력합니다.

```rust
use tracing::{trace, debug, info, warn, error};

fn example_logging() {
    error!("DB 연결 실패: 즉시 확인 필요!");     // 심각한 에러
    warn!("메모리 사용량 85% 초과");              // 주의가 필요한 상황
    info!("사용자 로그인: user_id={}", 42);      // 일반적인 이벤트
    debug!("쿼리 실행 시간: {}ms", 15);          // 디버깅용 정보
    trace!("요청 헤더: {:?}", headers);          // 매우 상세한 정보
}
```

| 레벨 | 용도 | 프로덕션 출력 |
|------|------|-------------|
| `error!` | 즉시 대응이 필요한 에러 | O |
| `warn!` | 주의가 필요하지만 동작은 계속 | O |
| `info!` | 일반적인 운영 이벤트 | O |
| `debug!` | 개발/디버깅 시 필요한 정보 | X (보통) |
| `trace!` | 매우 상세한 추적 정보 | X |

### 구조화된 로깅

단순 문자열보다 **키-값 쌍**으로 기록하면, 나중에 로그를 검색하고 분석하기 쉽습니다.

```rust
use tracing::info;

// 나쁜 예: 문자열만
info!("사용자 42가 주문 123을 생성했습니다");

// 좋은 예: 구조화된 로깅
info!(user_id = 42, order_id = 123, "주문 생성");
// 출력: 2025-02-16T10:30:00.000Z  INFO 주문 생성 user_id=42 order_id=123
```

> 구조화된 로그는 Elasticsearch, Datadog 같은 로그 분석 도구에서 `user_id=42`로 검색하거나, 특정 사용자의 모든 로그만 필터링할 수 있게 해줍니다.

---

## 5. 모니터링 기초

### 헬스체크 엔드포인트

서버가 정상적으로 동작하는지 확인하는 엔드포인트입니다. 로드밸런서, Docker, 쿠버네티스 등이 이 엔드포인트를 주기적으로 호출해서 서버 상태를 확인합니다.

```rust
use axum::{Router, Json, routing::get};
use serde::Serialize;

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    version: String,
}

async fn health_check() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}

fn create_router() -> Router {
    Router::new()
        .route("/health", get(health_check))
        // ... 다른 라우트들
}
```

```bash
# 헬스체크 확인
curl http://localhost:3000/health
# {"status":"ok","version":"0.1.0"}
```

Docker에서도 헬스체크를 설정할 수 있습니다.

```dockerfile
# Dockerfile에 추가
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1
```

### Graceful Shutdown (우아한 종료)

서버를 종료할 때, 처리 중인 요청을 마무리한 뒤 종료하는 것이 중요합니다. 갑자기 종료하면 사용자가 에러 응답을 받습니다.

```rust
use axum::Router;
use tokio::net::TcpListener;
use tracing::info;

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Ctrl+C 시그널 핸들러 설정 실패");
    info!("종료 신호 수신, 서버를 종료합니다...");
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt().init();

    let app = Router::new()
        .route("/health", axum::routing::get(|| async { "ok" }));

    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    info!("서버 시작: http://0.0.0.0:3000");

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .unwrap();

    info!("서버가 정상적으로 종료되었습니다.");
}
```

```
서버 시작: http://0.0.0.0:3000
^C
종료 신호 수신, 서버를 종료합니다...
서버가 정상적으로 종료되었습니다.
```

Graceful Shutdown이 하는 일:

```
1. 종료 신호 수신 (Ctrl+C 또는 SIGTERM)
2. 새로운 연결 받기 중지
3. 진행 중인 요청이 완료될 때까지 대기
4. 모든 요청이 완료되면 서버 종료
```

> Docker나 쿠버네티스는 컨테이너를 종료할 때 SIGTERM 신호를 보냅니다. Graceful Shutdown을 구현하지 않으면, 처리 중인 요청이 강제로 끊어져 사용자가 에러를 경험합니다.

---

## 6. 성능 최적화 팁

프로덕션 배포 전에 확인할 성능 관련 체크리스트입니다.

### 릴리스 빌드 사용

가장 기본이지만 가장 중요합니다.

```bash
# 반드시 --release!
cargo build --release
```

### 커넥션 풀 크기 조정

DB 연결을 매 요청마다 새로 만들면 느립니다. 커넥션 풀을 사용하되, 크기를 적절히 설정해야 합니다.

```rust
use sqlx::postgres::PgPoolOptions;

let pool = PgPoolOptions::new()
    .max_connections(20)        // 최대 연결 수
    .min_connections(5)         // 최소 유지 연결 수
    .acquire_timeout(std::time::Duration::from_secs(3))  // 연결 대기 타임아웃
    .connect(&database_url)
    .await
    .expect("DB 연결 실패");
```

| 설정 | 권장값 | 설명 |
|------|--------|------|
| max_connections | CPU 코어 수 * 2~4 | 너무 많으면 DB에 부담 |
| min_connections | 2~5 | 최소 연결을 유지하여 응답 속도 확보 |
| acquire_timeout | 3~5초 | 풀이 가득 찼을 때 대기 시간 |

### 캐싱 기초

자주 바뀌지 않는 데이터는 메모리에 캐싱하면 DB 쿼리를 줄일 수 있습니다.

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;

// 간단한 인메모리 캐시
type Cache = Arc<RwLock<HashMap<String, String>>>;

async fn get_setting(cache: &Cache, key: &str) -> Option<String> {
    // 먼저 캐시에서 찾기
    let read_lock = cache.read().await;
    if let Some(value) = read_lock.get(key) {
        return Some(value.clone());
    }
    drop(read_lock);

    // 캐시에 없으면 DB에서 조회 후 캐시에 저장
    // let value = db_query(key).await?;
    // let mut write_lock = cache.write().await;
    // write_lock.insert(key.to_string(), value.clone());
    // Some(value)
    None
}
```

### DB 인덱스 활용

자주 검색하는 컬럼에 인덱스를 추가하면 쿼리 속도가 크게 향상됩니다.

```sql
-- 자주 조회하는 컬럼에 인덱스 추가
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

| 상황 | 인덱스 없음 | 인덱스 있음 |
|------|------------|------------|
| 100만 건에서 1건 조회 | 전체 스캔 (느림) | 인덱스 탐색 (빠름) |
| WHERE email = '...' | O(n) | O(log n) |

### 성능 체크리스트

```
[ ] cargo build --release 사용
[ ] 커넥션 풀 크기 적절히 설정
[ ] 자주 조회하는 컬럼에 DB 인덱스 추가
[ ] 불필요한 쿼리 제거 (N+1 문제 확인)
[ ] 정적 파일 캐싱 설정
[ ] 로그 레벨을 INFO 이상으로 설정
```

---

## 7. 배포 옵션 소개

서버를 실제로 인터넷에 올리는 방법은 여러 가지가 있습니다.

### 간단한 배포 (초보자 추천)

| 서비스 | 특징 | 무료 티어 |
|--------|------|----------|
| Railway | Git push만으로 배포, Rust 지원 | 월 $5 크레딧 |
| Fly.io | Docker 기반, 전 세계 엣지 배포 | 소규모 무료 |
| Shuttle | Rust 전용 클라우드, 매우 간단 | 무료 티어 있음 |

```bash
# Fly.io 예시
fly launch        # 프로젝트 초기 설정
fly deploy        # 배포
fly logs          # 로그 확인
```

### 직접 관리 (중급 이상)

| 서비스 | 특징 | 비용 |
|--------|------|------|
| AWS EC2 | 가상 서버, 완전한 통제 | 인스턴스 타입별 |
| GCP Compute Engine | Google 클라우드 가상 서버 | 인스턴스 타입별 |
| DigitalOcean Droplet | 간단한 가상 서버 | 월 $4~ |

### 컨테이너 서비스 (Docker 활용)

| 서비스 | 특징 |
|--------|------|
| AWS ECS / Fargate | Docker 컨테이너 관리 서비스 |
| GCP Cloud Run | 요청 기반 컨테이너 실행 (사용한 만큼 지불) |
| Azure Container Apps | Microsoft 클라우드 컨테이너 서비스 |

### 초보자를 위한 추천 경로

```
1단계: Railway 또는 Fly.io로 첫 배포 경험
       → Git push만으로 배포, 무료로 시작

2단계: Docker + VPS (DigitalOcean 등)
       → 서버 직접 관리 경험

3단계: AWS/GCP 컨테이너 서비스
       → 프로덕션 수준 배포
```

---

## 8. 실습

### 실습 1: Dockerfile 작성하고 이미지 빌드

Axum 서버를 위한 멀티스테이지 Dockerfile을 작성하고 이미지를 빌드하세요.

```dockerfile
# 여기에 Dockerfile을 작성하세요!
# 1. rust:1.75를 빌드 스테이지로 사용하세요
# 2. cargo build --release로 빌드하세요
# 3. debian:bookworm-slim을 실행 스테이지로 사용하세요
# 4. 빌드된 바이너리만 복사하세요
# 5. EXPOSE 3000으로 포트를 노출하세요
# 6. CMD로 바이너리를 실행하세요
```

```bash
# 빌드 후 실행해보세요
# docker build -t my-api .
# docker run -p 3000:3000 my-api
# curl http://localhost:3000/health 로 확인
```

<details>
<summary><b>정답 보기</b></summary>

```dockerfile
# 빌드 단계
FROM rust:1.75 AS builder
WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs
RUN cargo build --release
RUN rm -rf src
COPY src ./src
RUN touch src/main.rs
RUN cargo build --release

# 실행 단계
FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/my-api /usr/local/bin/my-api
EXPOSE 3000
CMD ["my-api"]
```

```bash
docker build -t my-api .
docker run -p 3000:3000 my-api
```

멀티스테이지 빌드로 최종 이미지에는 Rust 컴파일러 없이 바이너리만 포함됩니다. 이미지 크기가 ~1.5GB에서 ~80MB로 줄어듭니다.

</details>

---

### 실습 2: docker-compose로 서버 + DB 실행

`docker-compose.yml`을 작성하여 Axum 서버와 PostgreSQL을 함께 실행하세요.

```yaml
# docker-compose.yml을 작성하세요!
# 1. postgres:16 이미지로 DB 서비스를 만드세요
#    - POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB 설정
#    - 포트 5432 매핑
#    - 볼륨으로 데이터 영속화
# 2. api 서비스를 만드세요 (현재 디렉토리의 Dockerfile 빌드)
#    - 포트 3000 매핑
#    - DATABASE_URL 환경 변수 설정
#    - depends_on으로 db 의존성 설정
```

```bash
# 실행해보세요
# docker compose up
# curl http://localhost:3000/health 로 확인
```

<details>
<summary><b>정답 보기</b></summary>

```yaml
version: "3.8"

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: apppassword
      POSTGRES_DB: myapp
    ports:
      - "5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgres://appuser:apppassword@db:5432/myapp
      JWT_SECRET: my-secret-key
      SERVER_PORT: "3000"
    depends_on:
      - db

volumes:
  db_data:
```

```bash
# 시작
docker compose up -d

# 로그 확인
docker compose logs -f api

# 헬스체크
curl http://localhost:3000/health

# 중지 및 정리
docker compose down
```

`db`라는 서비스 이름이 Docker 네트워크 안에서 호스트네임으로 사용됩니다. 그래서 `DATABASE_URL`에 `@db:5432`로 접속할 수 있습니다.

</details>

---

### 실습 3: 헬스체크 + Graceful Shutdown 구현

`/health` 엔드포인트와 Graceful Shutdown을 구현한 Axum 서버를 만드세요.

```rust
use axum::{Router, Json, routing::get};
use serde::Serialize;
use tokio::net::TcpListener;

// 여기에 코드를 작성하세요!
// 1. HealthResponse 구조체를 정의하세요 (status, version 필드)
// 2. health_check 핸들러를 작성하세요
// 3. shutdown_signal 함수를 작성하세요 (Ctrl+C 감지)
// 4. main에서 서버를 시작하되, with_graceful_shutdown을 적용하세요
// 5. tracing으로 시작/종료 로그를 남기세요

// 예상 동작:
// 서버 시작 → curl /health → {"status":"ok","version":"0.1.0"}
// Ctrl+C → "종료 신호 수신..." → "서버 정상 종료"
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use axum::{Router, Json, routing::get};
use serde::Serialize;
use tokio::net::TcpListener;
use tracing::info;

#[derive(Serialize)]
struct HealthResponse {
    status: String,
    version: String,
}

async fn health_check() -> Json<HealthResponse> {
    Json(HealthResponse {
        status: "ok".to_string(),
        version: env!("CARGO_PKG_VERSION").to_string(),
    })
}

async fn shutdown_signal() {
    tokio::signal::ctrl_c()
        .await
        .expect("Ctrl+C 핸들러 설정 실패");
    info!("종료 신호 수신, 서버를 종료합니다...");
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_target(false)
        .with_max_level(tracing::Level::INFO)
        .init();

    let app = Router::new()
        .route("/health", get(health_check));

    let listener = TcpListener::bind("0.0.0.0:3000").await.unwrap();
    info!("서버 시작: http://0.0.0.0:3000");

    axum::serve(listener, app)
        .with_graceful_shutdown(shutdown_signal())
        .await
        .unwrap();

    info!("서버가 정상적으로 종료되었습니다.");
}
```

`Cargo.toml`에 필요한 의존성:

```toml
[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
tracing = "0.1"
tracing-subscriber = "0.3"
```

</details>

---

## 9. 확인 문제

### 문제 1
`cargo build`와 `cargo build --release`의 차이점은 무엇인가요?

### 문제 2
`.env` 파일을 프로덕션 환경에서 사용하지 않는 이유는?

### 문제 3
Docker 멀티스테이지 빌드를 사용하는 가장 큰 이유는?

### 문제 4
다음 로그 레벨을 심각도 순서대로 나열하세요: `DEBUG`, `ERROR`, `INFO`, `WARN`, `TRACE`

### 문제 5
Graceful Shutdown을 구현하지 않으면 서버 종료 시 어떤 문제가 발생하나요?

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
`cargo build`는 **디버그 빌드**로, 컴파일은 빠르지만 실행 속도가 느립니다. `cargo build --release`는 **릴리스 빌드**로, 컴파일은 느리지만 실행 속도가 10~100배 빠릅니다. 프로덕션에서는 반드시 `--release`를 사용해야 합니다.

### 문제 2 정답
`.env` 파일은 개발 편의용입니다. 프로덕션에서 사용하지 않는 이유는:
1. **보안**: 비밀번호, 키 등이 파일에 평문으로 저장되어 유출 위험이 있습니다.
2. **Git 사고**: 실수로 커밋되면 비밀 정보가 저장소에 노출됩니다.
3. **유연성**: 시스템 환경 변수나 클라우드 설정을 사용하면, 코드 변경 없이 환경별로 다른 값을 적용할 수 있습니다.

### 문제 3 정답
**이미지 크기를 줄이기 위해서**입니다. Rust 컴파일에는 컴파일러, Cargo 등 수백 MB의 도구가 필요하지만, 실행에는 바이너리 하나면 됩니다. 멀티스테이지 빌드로 빌드 단계의 도구를 제거하면, 이미지 크기가 ~1.5GB에서 ~80MB로 줄어듭니다.

### 문제 4 정답
심각도 높은 순서: **ERROR > WARN > INFO > DEBUG > TRACE**

- `ERROR`: 즉시 대응이 필요한 에러
- `WARN`: 주의가 필요하지만 동작은 계속
- `INFO`: 일반적인 운영 이벤트
- `DEBUG`: 디버깅용 정보
- `TRACE`: 매우 상세한 추적 정보

프로덕션에서는 보통 INFO 이상만 출력합니다.

### 문제 5 정답
Graceful Shutdown 없이 서버를 강제 종료하면, **처리 중인 요청이 중간에 끊어집니다**. 사용자는 에러 응답을 받거나 응답을 아예 받지 못합니다. 특히 DB에 데이터를 쓰는 중이었다면, 데이터가 불완전하게 저장될 수 있습니다. Graceful Shutdown은 새 요청 수락을 중단하고, 진행 중인 요청이 완료된 후에 서버를 종료합니다.

</details>

---

## 10. 25장 정리

| 배운 것 | 핵심 |
|---------|------|
| 릴리스 빌드 | `cargo build --release`로 프로덕션 성능 확보 |
| 환경 변수 | 시작 시 필수 변수 검증, 프로덕션은 시스템 환경 변수 사용 |
| Dockerfile | 멀티스테이지 빌드로 경량 이미지 생성 |
| docker-compose | 서버 + DB를 함께 관리 |
| tracing | 구조화된 로깅으로 운영 가시성 확보 |
| 로그 레벨 | ERROR > WARN > INFO > DEBUG > TRACE |
| 헬스체크 | `/health` 엔드포인트로 서버 상태 확인 |
| Graceful Shutdown | 진행 중인 요청을 마무리한 후 안전하게 종료 |
| 커넥션 풀 | 적절한 크기 설정으로 DB 성능 최적화 |
| 배포 옵션 | Railway/Fly.io (간단) ~ AWS/GCP (고급) |

---

## 학습 여정을 마치며

### 지금까지 걸어온 길

```
Part 1: Rust 기초 문법        (01~08장)
  변수, 함수, 소유권, 구조체, 에러 처리, 모듈

Part 2: Rust 중급             (09~13장)
  제네릭, 트레이트, 라이프타임, 스마트 포인터, 동시성

Part 3: 비동기 프로그래밍      (14~15장)
  async/await, Tokio, 태스크, 채널

Part 4: 웹 개발 기초          (16~18장)
  HTTP 이론, Axum, 라우팅, 미들웨어

Part 5: 데이터베이스 연동      (19~20장)
  SQL, PostgreSQL, SQLx, 커넥션 풀

Part 6: 실전 API 서버         (21~25장)
  아키텍처, 인증, API 설계, 테스트, 배포
```

1장에서 "Hello, World!"를 출력하던 것이, 이제 Docker로 컨테이너화하여 세상에 배포할 수 있는 API 서버가 되었습니다.

### 앞으로의 학습 방향

| 방향 | 주제 | 추천 자료 |
|------|------|----------|
| 심화 | WebSocket, gRPC, GraphQL | tokio-tungstenite, tonic, async-graphql |
| 인프라 | Kubernetes, CI/CD | GitHub Actions, Docker Compose |
| 성능 | 프로파일링, 벤치마크 | criterion, flamegraph |
| 보안 | OWASP Top 10, Rate Limiting | tower-http, 보안 가이드 |
| 프론트엔드 | HTMX, Leptos, Yew | Rust 풀스택 개발 |

### 추천 프로젝트 아이디어

**입문**: 개인 블로그 API

- 게시글 CRUD + 태그 + 검색
- JWT 인증
- 마크다운 렌더링

**중급**: 실시간 채팅 서버

- WebSocket 활용
- 채팅방 생성/참여
- 메시지 저장

**도전**: URL 단축 서비스

- 짧은 URL 생성 및 리다이렉트
- 클릭 통계
- Rate Limiting

---

## 축하합니다!

25장까지 모두 완주했습니다.

Rust는 쉽지 않은 언어입니다. 소유권, 라이프타임, 비동기 프로그래밍까지 넘어야 할 산이 많았습니다. 그 모든 과정을 끝까지 해냈다는 것은 대단한 일입니다.

이제 여러분은 Rust로 안전하고 빠른 백엔드 서버를 만들 수 있는 개발자입니다. 배운 것을 바탕으로 직접 프로젝트를 만들어 보세요. 코드를 작성하고, 에러를 마주하고, 해결하는 과정이 가장 좋은 학습입니다.

**지금까지 수고하셨습니다. 앞으로의 개발 여정을 응원합니다!**
