# 21장. 프로젝트 구조 설계

> **목표**: 실전 웹 API 프로젝트의 구조를 설계하고 기반 코드를 작성한다.
> 이제부터 실전 프로젝트를 만듭니다!

---

## 1. 레이어드 아키텍처

웹 API 프로젝트는 코드를 **역할별로 분리**합니다. 이를 **레이어드 아키텍처**라고 합니다.

### 세 개의 레이어

```
HTTP 요청
    │
    ▼
┌──────────────┐
│   Handler    │  ← HTTP 요청/응답 처리 (웨이터)
│  (컨트롤러)   │     "손님 주문을 받고, 음식을 전달한다"
└──────┬───────┘
       │
       ▼
┌──────────────┐
│   Service    │  ← 비즈니스 로직 (주방장)
│ (비즈니스)    │     "레시피대로 요리한다"
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  Repository  │  ← 데이터 접근 (냉장고)
│  (데이터)     │     "재료를 꺼내고 보관한다"
└──────────────┘
       │
       ▼
   데이터베이스
```

### 각 레이어의 역할

| 레이어 | 비유 | 하는 일 |
|--------|------|---------|
| Handler | 웨이터 | HTTP 요청을 받아 파싱하고, 응답을 JSON으로 반환 |
| Service | 주방장 | 비즈니스 규칙 적용 (유효성 검사, 계산, 판단) |
| Repository | 냉장고 | DB에서 데이터 조회, 저장, 수정, 삭제 |

### 데이터 흐름 예시: "회원 가입"

```
1. Handler: POST /users 요청을 받아 JSON 파싱
       ↓
2. Service: 이메일 중복 확인, 비밀번호 검증
       ↓
3. Repository: DB에 새 유저 INSERT
       ↓
4. Service: 결과를 Handler에 반환
       ↓
5. Handler: 201 Created + JSON 응답
```

<details>
<summary><b>왜 레이어를 나누나? (원리)</b></summary>

### 관심사 분리 (Separation of Concerns)

각 레이어는 **하나의 관심사**만 담당합니다:
- Handler는 HTTP만 알면 됩니다. DB를 몰라도 됩니다.
- Service는 비즈니스 로직만 담당합니다. HTTP 헤더를 몰라도 됩니다.
- Repository는 SQL만 알면 됩니다. 비즈니스 규칙을 몰라도 됩니다.

### 테스트 용이성

레이어가 분리되면 **각 레이어를 독립적으로 테스트**할 수 있습니다:

```rust
// Service 테스트: 가짜 Repository를 주입하면 DB 없이 테스트 가능
#[test]
fn test_create_user_duplicate_email() {
    let fake_repo = FakeUserRepository::new();
    let service = UserService::new(fake_repo);

    let result = service.create_user("중복@email.com", "password");
    assert!(result.is_err());
}
```

### 유지보수 편의성

- DB를 PostgreSQL에서 MySQL로 바꿔도 Repository만 수정하면 됩니다.
- HTTP 프레임워크를 Axum에서 Actix로 바꿔도 Handler만 수정하면 됩니다.
- 비즈니스 규칙이 바뀌어도 Service만 수정하면 됩니다.

### 레이어 간 의존 방향

```
Handler → Service → Repository
  (O)       (O)       (O)

Handler ← Service ← Repository
  (X)       (X)       (X)
```

화살표 방향은 **의존 방향**입니다. Handler는 Service를 알지만, Service는 Handler를 모릅니다. 이 단방향 의존이 코드를 깔끔하게 유지하는 핵심입니다.

</details>

---

## 2. 프로젝트 디렉토리 구조

실전 프로젝트의 파일 구조입니다. 이 구조를 기반으로 앞으로의 장에서 코드를 채워나갑니다.

```
my-api/
├── Cargo.toml               # 의존성 관리
├── .env                      # 환경 변수 (DB URL, 포트 등)
├── migrations/               # DB 마이그레이션 SQL
│   └── 001_create_users.sql
└── src/
    ├── main.rs               # 서버 시작점
    ├── config.rs             # 설정 관리
    ├── error.rs              # 에러 타입 정의
    ├── handlers/             # HTTP 핸들러 (웨이터)
    │   ├── mod.rs
    │   └── user.rs
    ├── services/             # 비즈니스 로직 (주방장)
    │   ├── mod.rs
    │   └── user.rs
    ├── repositories/         # DB 접근 (냉장고)
    │   ├── mod.rs
    │   └── user.rs
    └── models/               # 데이터 모델
        ├── mod.rs
        └── user.rs
```

### 각 파일의 역할

| 파일 | 역할 |
|------|------|
| `Cargo.toml` | 프로젝트 이름, 버전, 의존 크레이트 목록 |
| `.env` | 환경 변수 (DB URL, 서버 포트 등 민감 정보) |
| `migrations/` | DB 테이블 생성/수정 SQL 파일 |
| `main.rs` | 서버 초기화, 라우터 설정, 서버 시작 |
| `config.rs` | `.env` 파일에서 설정값을 읽어 구조체로 관리 |
| `error.rs` | 프로젝트 전용 에러 타입 정의 |
| `handlers/` | HTTP 요청을 받아 Service를 호출하고 응답 반환 |
| `services/` | 핵심 비즈니스 로직 (유효성 검사, 판단, 계산) |
| `repositories/` | SQL 쿼리 실행, DB와 직접 통신 |
| `models/` | 요청/응답/DB 데이터 구조체 정의 |

### mod.rs의 역할

각 디렉토리의 `mod.rs`는 해당 모듈의 **입구** 역할을 합니다:

```rust
// src/handlers/mod.rs
pub mod user;  // handlers/user.rs를 공개 모듈로 등록

// 필요하면 다른 핸들러도 추가
// pub mod post;
// pub mod comment;
```

8장에서 배운 모듈 시스템을 실전에서 이렇게 활용합니다.

---

## 3. 설정 관리

### Cargo.toml 의존성

먼저 필요한 크레이트를 추가합니다:

```toml
[package]
name = "my-api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
sqlx = { version = "0.7", features = ["runtime-tokio", "postgres", "chrono"] }
dotenvy = "0.15"
chrono = { version = "0.4", features = ["serde"] }
tower-http = { version = "0.5", features = ["cors", "trace"] }
tracing = "0.1"
tracing-subscriber = "0.3"
```

### .env 파일

프로젝트 루트에 `.env` 파일을 만듭니다:

```env
DATABASE_URL=postgres://postgres:password@localhost:5432/my_api
SERVER_HOST=127.0.0.1
SERVER_PORT=3000
```

> `.env` 파일은 `.gitignore`에 반드시 추가하세요! 비밀번호가 GitHub에 올라가면 안 됩니다.

### Config 구조체

```rust
// src/config.rs
use std::env;

pub struct Config {
    pub database_url: String,
    pub server_host: String,
    pub server_port: u16,
}

impl Config {
    pub fn from_env() -> Result<Self, env::VarError> {
        Ok(Self {
            database_url: env::var("DATABASE_URL")?,
            server_host: env::var("SERVER_HOST")
                .unwrap_or_else(|_| "127.0.0.1".to_string()),
            server_port: env::var("SERVER_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse()
                .expect("SERVER_PORT는 숫자여야 합니다"),
        })
    }
}
```

**핵심 포인트:**
- `DATABASE_URL`은 필수값이므로 `?`로 에러를 전파합니다.
- `SERVER_HOST`와 `SERVER_PORT`는 기본값이 있으므로 `unwrap_or_else`로 처리합니다.
- `from_env()`는 환경 변수를 읽어 `Config` 구조체를 만드는 **연관 함수**입니다.

<details>
<summary><b>환경별 설정 분리 (원리)</b></summary>

### 개발 환경 vs 프로덕션 환경

실무에서는 환경마다 설정이 다릅니다:

| 설정 | 개발 (dev) | 프로덕션 (prod) |
|------|-----------|----------------|
| DB URL | localhost:5432 | rds.amazonaws.com:5432 |
| 로그 레벨 | DEBUG | WARN |
| 서버 포트 | 3000 | 80 |

### .env 파일로 분리

```
# .env.development
DATABASE_URL=postgres://postgres:password@localhost:5432/my_api_dev
SERVER_PORT=3000
RUST_LOG=debug

# .env.production
DATABASE_URL=postgres://user:pass@prod-db.example.com:5432/my_api
SERVER_PORT=80
RUST_LOG=warn
```

### 로드 순서

```rust
// main.rs에서 환경에 따라 다른 .env 파일을 로드
fn load_env() {
    let env = env::var("APP_ENV").unwrap_or_else(|_| "development".to_string());

    let env_file = format!(".env.{}", env);

    // 환경별 파일이 있으면 먼저 로드
    if dotenvy::from_filename(&env_file).is_ok() {
        tracing::info!("{} 환경 설정을 로드했습니다", env);
        return;
    }

    // 없으면 기본 .env 로드
    dotenvy::dotenv().ok();
}
```

프로덕션 환경에서는 `.env` 파일 대신 **시스템 환경 변수**를 직접 설정하는 것이 더 안전합니다. Docker나 클라우드 서비스에서는 환경 변수를 별도로 관리합니다.

</details>

---

## 4. 기반 코드 작성

### AppState 정의

여러 핸들러가 공유해야 하는 데이터를 `AppState`에 모읍니다:

```rust
// main.rs (상단 부분)
use sqlx::PgPool;
use std::sync::Arc;

pub struct AppState {
    pub db: PgPool,
    pub config: Config,
}
```

12장에서 배운 `Arc<T>`를 기억하시나요? `AppState`를 `Arc`로 감싸면 여러 핸들러 스레드가 안전하게 공유할 수 있습니다.

### 에러 타입 정의

프로젝트 전용 에러 타입을 만들어 에러 처리를 통일합니다:

```rust
// src/error.rs
use axum::http::StatusCode;
use axum::response::{IntoResponse, Response};
use axum::Json;
use serde_json::json;

#[derive(Debug)]
pub enum AppError {
    NotFound(String),
    BadRequest(String),
    Internal(String),
    Database(sqlx::Error),
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::NotFound(msg) => (StatusCode::NOT_FOUND, msg),
            AppError::BadRequest(msg) => (StatusCode::BAD_REQUEST, msg),
            AppError::Internal(msg) => {
                (StatusCode::INTERNAL_SERVER_ERROR, msg)
            }
            AppError::Database(err) => {
                tracing::error!("DB 에러: {:?}", err);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "내부 서버 오류".to_string(),
                )
            }
        };

        let body = Json(json!({
            "error": message
        }));

        (status, body).into_response()
    }
}

// sqlx::Error를 AppError로 자동 변환
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        AppError::Database(err)
    }
}
```

**핵심 포인트:**
- `IntoResponse`를 구현하면 Axum이 에러를 자동으로 HTTP 응답으로 변환합니다.
- `From<sqlx::Error>`를 구현하면 `?` 연산자로 DB 에러를 자동 변환할 수 있습니다.
- DB 에러는 내부 정보를 클라이언트에 노출하지 않고, 로그에만 기록합니다.

### main.rs 전체 구조

```rust
// src/main.rs
mod config;
mod error;
mod handlers;
mod models;
mod repositories;
mod services;

use axum::{routing::get, Router};
use config::Config;
use sqlx::postgres::PgPoolOptions;
use std::sync::Arc;
use tower_http::trace::TraceLayer;

pub struct AppState {
    pub db: sqlx::PgPool,
    pub config: Config,
}

#[tokio::main]
async fn main() {
    // 1. 환경 변수 로드
    dotenvy::dotenv().ok();
    tracing_subscriber::fmt::init();

    // 2. 설정 읽기
    let config = Config::from_env()
        .expect("환경 변수 설정이 필요합니다");

    // 3. DB 연결
    let db_pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&config.database_url)
        .await
        .expect("DB 연결에 실패했습니다");

    // 4. 마이그레이션 실행
    sqlx::migrate!("./migrations")
        .run(&db_pool)
        .await
        .expect("마이그레이션 실패");

    // 5. 공유 상태 생성
    let state = Arc::new(AppState {
        db: db_pool,
        config,
    });

    // 6. 라우터 설정
    let app = Router::new()
        .route("/health", get(|| async { "OK" }))
        .nest("/api/users", handlers::user::router())
        .with_state(state)
        .layer(TraceLayer::new_for_http());

    // 7. 서버 시작
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .expect("포트 3000 바인딩 실패");

    tracing::info!("서버 시작: http://127.0.0.1:3000");

    axum::serve(listener, app)
        .await
        .expect("서버 실행 실패");
}
```

### 각 레이어 연결하기

레이어가 어떻게 연결되는지 User CRUD를 기준으로 보겠습니다.

**Repository (냉장고 - DB 접근)**

```rust
// src/repositories/user.rs
use sqlx::PgPool;

use crate::models::user::{CreateUserRequest, User};

pub struct UserRepository;

impl UserRepository {
    pub async fn find_all(pool: &PgPool) -> Result<Vec<User>, sqlx::Error> {
        sqlx::query_as::<_, User>("SELECT id, name, email, created_at FROM users")
            .fetch_all(pool)
            .await
    }

    pub async fn find_by_id(pool: &PgPool, id: i32) -> Result<Option<User>, sqlx::Error> {
        sqlx::query_as::<_, User>(
            "SELECT id, name, email, created_at FROM users WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(pool)
        .await
    }

    pub async fn create(
        pool: &PgPool,
        req: &CreateUserRequest,
    ) -> Result<User, sqlx::Error> {
        sqlx::query_as::<_, User>(
            "INSERT INTO users (name, email) VALUES ($1, $2)
             RETURNING id, name, email, created_at"
        )
        .bind(&req.name)
        .bind(&req.email)
        .fetch_one(pool)
        .await
    }
}
```

**Service (주방장 - 비즈니스 로직)**

```rust
// src/services/user.rs
use sqlx::PgPool;

use crate::error::AppError;
use crate::models::user::{CreateUserRequest, User, UserResponse};
use crate::repositories::user::UserRepository;

pub struct UserService;

impl UserService {
    pub async fn get_all_users(pool: &PgPool) -> Result<Vec<UserResponse>, AppError> {
        let users = UserRepository::find_all(pool).await?;
        let responses = users.into_iter().map(UserResponse::from).collect();
        Ok(responses)
    }

    pub async fn get_user_by_id(pool: &PgPool, id: i32) -> Result<UserResponse, AppError> {
        let user = UserRepository::find_by_id(pool, id).await?;

        // 얼리 리턴: 유저가 없으면 즉시 에러 반환
        let Some(user) = user else {
            return Err(AppError::NotFound(
                format!("ID {}인 유저를 찾을 수 없습니다", id)
            ));
        };

        Ok(UserResponse::from(user))
    }

    pub async fn create_user(
        pool: &PgPool,
        req: CreateUserRequest,
    ) -> Result<UserResponse, AppError> {
        // 얼리 리턴: 이름이 비어있으면 즉시 에러 반환
        if req.name.trim().is_empty() {
            return Err(AppError::BadRequest(
                "이름은 비어있을 수 없습니다".to_string()
            ));
        }

        // 얼리 리턴: 이메일이 비어있으면 즉시 에러 반환
        if req.email.trim().is_empty() {
            return Err(AppError::BadRequest(
                "이메일은 비어있을 수 없습니다".to_string()
            ));
        }

        let user = UserRepository::create(pool, &req).await?;
        Ok(UserResponse::from(user))
    }
}
```

**Handler (웨이터 - HTTP 처리)**

```rust
// src/handlers/user.rs
use axum::{
    extract::{Path, State},
    routing::{get, post},
    Json, Router,
};
use std::sync::Arc;

use crate::error::AppError;
use crate::models::user::{CreateUserRequest, UserResponse};
use crate::services::user::UserService;
use crate::AppState;

pub fn router() -> Router<Arc<AppState>> {
    Router::new()
        .route("/", get(list_users).post(create_user))
        .route("/:id", get(get_user))
}

async fn list_users(
    State(state): State<Arc<AppState>>,
) -> Result<Json<Vec<UserResponse>>, AppError> {
    let users = UserService::get_all_users(&state.db).await?;
    Ok(Json(users))
}

async fn get_user(
    State(state): State<Arc<AppState>>,
    Path(id): Path<i32>,
) -> Result<Json<UserResponse>, AppError> {
    let user = UserService::get_user_by_id(&state.db, id).await?;
    Ok(Json(user))
}

async fn create_user(
    State(state): State<Arc<AppState>>,
    Json(req): Json<CreateUserRequest>,
) -> Result<(axum::http::StatusCode, Json<UserResponse>), AppError> {
    let user = UserService::create_user(&state.db, req).await?;
    Ok((axum::http::StatusCode::CREATED, Json(user)))
}
```

**핵심 포인트:**
- Handler는 Service만 호출합니다. 직접 SQL을 쓰지 않습니다.
- Service는 Repository만 호출합니다. HTTP 관련 코드가 없습니다.
- Repository는 DB만 다룹니다. 비즈니스 판단을 하지 않습니다.
- `?` 연산자 덕분에 에러가 자연스럽게 위로 전파됩니다.

<details>
<summary><b>?로 에러가 전파되는 흐름 (원리)</b></summary>

### 에러 전파 경로

```
Repository: sqlx::Error 발생
    ↓ (? 연산자)
Service: sqlx::Error → From 트레이트 → AppError::Database 변환
    ↓ (? 연산자)
Handler: AppError 반환
    ↓ (IntoResponse 트레이트)
Axum: HTTP 응답으로 변환 → 클라이언트에게 전송
```

`error.rs`에서 구현한 `From<sqlx::Error>`와 `IntoResponse`가 이 자동 변환을 가능하게 합니다.

### 코드로 보는 흐름

```rust
// 1. Repository에서 DB 에러 발생
pub async fn find_by_id(pool: &PgPool, id: i32) -> Result<Option<User>, sqlx::Error> {
    sqlx::query_as::<_, User>(...)
        .fetch_optional(pool)
        .await   // ← 여기서 sqlx::Error 발생 가능
}

// 2. Service에서 ? 사용 → From<sqlx::Error> for AppError 자동 호출
pub async fn get_user_by_id(pool: &PgPool, id: i32) -> Result<UserResponse, AppError> {
    let user = UserRepository::find_by_id(pool, id).await?;
    //                                                   ^
    //                              sqlx::Error → AppError::Database 자동 변환
    ...
}

// 3. Handler에서 ? 사용 → AppError가 그대로 반환
async fn get_user(...) -> Result<Json<UserResponse>, AppError> {
    let user = UserService::get_user_by_id(&state.db, id).await?;
    //                                                        ^
    //                                   AppError가 그대로 반환됨
    Ok(Json(user))
}

// 4. Axum이 AppError의 IntoResponse를 호출 → HTTP 응답 생성
```

이 패턴 덕분에 매 함수에서 `match`로 에러를 처리할 필요 없이, `?` 한 글자로 에러를 전파할 수 있습니다.

</details>

---

## 5. 모델 정의

데이터 모델은 **목적에 따라 분리**합니다. 같은 "유저"라도 상황에 따라 필요한 필드가 다릅니다.

### 세 종류의 모델

```rust
// src/models/user.rs
use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};

// 1. 요청 모델: 클라이언트 → 서버
#[derive(Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

// 2. 응답 모델: 서버 → 클라이언트
#[derive(Serialize)]
pub struct UserResponse {
    pub id: i32,
    pub name: String,
    pub email: String,
}

// 3. DB 모델: 서버 ↔ 데이터베이스
#[derive(sqlx::FromRow)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: NaiveDateTime,
}

// DB 모델 → 응답 모델 변환
impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            name: user.name,
            email: user.email,
        }
    }
}
```

### 왜 모델을 분리하나?

```
클라이언트가 보내는 것     서버가 저장하는 것     클라이언트가 받는 것
┌─────────────────┐   ┌──────────────────┐   ┌─────────────────┐
│ CreateUserRequest│   │      User        │   │  UserResponse   │
│                  │   │                  │   │                 │
│ name: String     │   │ id: i32          │   │ id: i32         │
│ email: String    │   │ name: String     │   │ name: String    │
│                  │   │ email: String    │   │ email: String   │
│                  │   │ created_at: ...  │   │                 │
│                  │   │ password_hash: ..│   │                 │
└─────────────────┘   └──────────────────┘   └─────────────────┘

  id는 서버가 생성       비밀번호 해시는          비밀번호 해시는
  클라이언트가 모름       DB에만 저장              절대 노출 안 됨
```

| 모델 | 목적 | derive |
|------|------|--------|
| `CreateUserRequest` | 클라이언트 요청 파싱 | `Deserialize` |
| `UserResponse` | 클라이언트 응답 직렬화 | `Serialize` |
| `User` | DB 행을 Rust 구조체로 변환 | `sqlx::FromRow` |

### mod.rs 연결

```rust
// src/models/mod.rs
pub mod user;
```

```rust
// src/handlers/mod.rs
pub mod user;
```

```rust
// src/services/mod.rs
pub mod user;
```

```rust
// src/repositories/mod.rs
pub mod user;
```

<details>
<summary><b>From 트레이트를 활용한 모델 변환 (원리)</b></summary>

### From 트레이트 복습

9장에서 배운 `From` 트레이트를 활용하면 모델 변환이 깔끔해집니다:

```rust
// DB 모델 → 응답 모델
impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            name: user.name,
            email: user.email,
            // created_at은 응답에 포함하지 않음
            // password_hash는 절대 포함하지 않음
        }
    }
}
```

사용할 때:

```rust
// 방법 1: From 직접 호출
let response = UserResponse::from(user);

// 방법 2: Into 자동 변환 (From을 구현하면 Into는 자동)
let response: UserResponse = user.into();

// 방법 3: 이터레이터에서 사용
let responses: Vec<UserResponse> = users
    .into_iter()
    .map(UserResponse::from)
    .collect();
```

### 왜 수동 변환인가?

"필드가 같으면 자동으로 변환하면 안 되나?"라고 생각할 수 있습니다. 하지만 **의도적으로** 어떤 필드를 포함하고 제외할지 결정하는 것이 중요합니다. 특히 `password_hash` 같은 민감한 필드를 실수로 응답에 포함하는 것을 방지합니다.

</details>

---

## 6. 마이그레이션

DB 테이블을 코드로 관리합니다:

```sql
-- migrations/001_create_users.sql
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

`main.rs`에서 서버 시작 시 자동으로 마이그레이션을 실행합니다:

```rust
sqlx::migrate!("./migrations")
    .run(&db_pool)
    .await
    .expect("마이그레이션 실패");
```

이렇게 하면 서버를 시작할 때마다 아직 적용되지 않은 마이그레이션만 자동으로 실행됩니다.

---

## 7. 전체 흐름 정리

서버가 시작부터 요청을 처리하기까지의 전체 흐름입니다:

```
[서버 시작]
  1. .env 파일 로드
  2. Config 구조체 생성
  3. DB 커넥션 풀 생성
  4. 마이그레이션 실행
  5. AppState 생성 (Arc로 감싸기)
  6. 라우터 설정
  7. 서버 시작, 요청 대기

[요청 처리: GET /api/users/1]
  1. Axum이 라우터에서 핸들러를 찾음
  2. Handler: Path에서 id=1 추출
  3. Handler → Service: get_user_by_id(pool, 1) 호출
  4. Service → Repository: find_by_id(pool, 1) 호출
  5. Repository: SQL 실행, User 구조체 반환
  6. Service: User → UserResponse 변환
  7. Handler: Json(UserResponse) 반환
  8. Axum: HTTP 200 + JSON 응답 전송
```

---

## 8. 실습

### 실습 1: 프로젝트 디렉토리 구조 만들기

터미널에서 아래 명령어를 실행하여 프로젝트 뼈대를 만드세요.

```bash
# 프로젝트 생성
cargo new my-api
cd my-api

# 디렉토리 생성
mkdir -p src/handlers
mkdir -p src/services
mkdir -p src/repositories
mkdir -p src/models
mkdir -p migrations
```

각 디렉토리에 `mod.rs`와 `user.rs`를 만드세요:

```bash
# mod.rs 파일 생성
touch src/handlers/mod.rs
touch src/services/mod.rs
touch src/repositories/mod.rs
touch src/models/mod.rs

# user.rs 파일 생성
touch src/handlers/user.rs
touch src/services/user.rs
touch src/repositories/user.rs
touch src/models/user.rs

# 기타 파일
touch src/config.rs
touch src/error.rs
touch .env
```

각 `mod.rs`에 `pub mod user;`를 작성하세요.

<details>
<summary><b>정답 확인</b></summary>

완성된 디렉토리 구조:

```
my-api/
├── Cargo.toml
├── .env
├── migrations/
└── src/
    ├── main.rs
    ├── config.rs
    ├── error.rs
    ├── handlers/
    │   ├── mod.rs       → pub mod user;
    │   └── user.rs
    ├── services/
    │   ├── mod.rs       → pub mod user;
    │   └── user.rs
    ├── repositories/
    │   ├── mod.rs       → pub mod user;
    │   └── user.rs
    └── models/
        ├── mod.rs       → pub mod user;
        └── user.rs
```

`main.rs`에 모듈 선언을 추가하세요:

```rust
mod config;
mod error;
mod handlers;
mod models;
mod repositories;
mod services;

fn main() {
    println!("프로젝트 구조 완성!");
}
```

`cargo build`로 컴파일이 되는지 확인하세요. 각 파일이 비어있어도 모듈 구조가 올바르면 컴파일됩니다.

</details>

### 실습 2: Config 구조체와 .env 파일 설정

`.env` 파일과 `Config` 구조체를 만들고, 환경 변수를 읽어서 출력하세요.

**Cargo.toml에 추가:**

```toml
[dependencies]
dotenvy = "0.15"
```

**.env 파일:**

```env
DATABASE_URL=postgres://postgres:password@localhost:5432/my_api
SERVER_HOST=127.0.0.1
SERVER_PORT=3000
```

**config.rs를 작성하세요:**

```rust
// 힌트: env::var()로 환경 변수를 읽고
// Config 구조체에 담아 반환하는 from_env() 함수를 만드세요
```

<details>
<summary><b>정답 확인</b></summary>

```rust
// src/config.rs
use std::env;

pub struct Config {
    pub database_url: String,
    pub server_host: String,
    pub server_port: u16,
}

impl Config {
    pub fn from_env() -> Result<Self, env::VarError> {
        Ok(Self {
            database_url: env::var("DATABASE_URL")?,
            server_host: env::var("SERVER_HOST")
                .unwrap_or_else(|_| "127.0.0.1".to_string()),
            server_port: env::var("SERVER_PORT")
                .unwrap_or_else(|_| "3000".to_string())
                .parse()
                .expect("SERVER_PORT는 숫자여야 합니다"),
        })
    }
}
```

```rust
// src/main.rs
mod config;

use config::Config;

fn main() {
    dotenvy::dotenv().ok();

    let config = Config::from_env()
        .expect("환경 변수 설정이 필요합니다");

    println!("DB URL: {}", config.database_url);
    println!("서버: {}:{}", config.server_host, config.server_port);
}
```

실행 결과:
```
DB URL: postgres://postgres:password@localhost:5432/my_api
서버: 127.0.0.1:3000
```

</details>

### 실습 3: User 모델 정의 (요청/응답/DB 모델)

`models/user.rs`에 세 가지 모델을 정의하고, `From` 트레이트로 DB 모델을 응답 모델로 변환하세요.

**Cargo.toml에 추가:**

```toml
[dependencies]
serde = { version = "1", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
```

**요구사항:**
1. `CreateUserRequest`: name, email 필드 (Deserialize)
2. `UserResponse`: id, name, email 필드 (Serialize)
3. `User`: id, name, email, created_at 필드
4. `From<User> for UserResponse` 구현

<details>
<summary><b>정답 확인</b></summary>

```rust
// src/models/user.rs
use chrono::NaiveDateTime;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
pub struct CreateUserRequest {
    pub name: String,
    pub email: String,
}

#[derive(Serialize)]
pub struct UserResponse {
    pub id: i32,
    pub name: String,
    pub email: String,
}

pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
    pub created_at: NaiveDateTime,
}

impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        Self {
            id: user.id,
            name: user.name,
            email: user.email,
        }
    }
}
```

테스트 코드 (main.rs에서 확인):

```rust
mod models;

use chrono::NaiveDateTime;
use models::user::{User, UserResponse};

fn main() {
    let user = User {
        id: 1,
        name: "홍길동".to_string(),
        email: "hong@example.com".to_string(),
        created_at: NaiveDateTime::default(),
    };

    let response = UserResponse::from(user);
    println!("id: {}, name: {}, email: {}", response.id, response.name, response.email);
    // id: 1, name: 홍길동, email: hong@example.com
}
```

**포인트**: `User`에는 `created_at`이 있지만, `UserResponse`에는 없습니다. `From` 구현에서 의도적으로 제외했습니다. 나중에 `password_hash` 같은 민감 필드도 같은 방식으로 제외합니다.

</details>

---

## 9. 확인 문제

### 문제 1

레이어드 아키텍처에서 Handler, Service, Repository 각각의 역할은?

<details>
<summary>정답 보기</summary>

- **Handler**: HTTP 요청을 받아 파싱하고, Service를 호출한 뒤 HTTP 응답을 반환합니다.
- **Service**: 비즈니스 로직을 담당합니다. 유효성 검사, 계산, 판단 등을 수행합니다.
- **Repository**: DB와 직접 통신합니다. SQL 쿼리 실행, 데이터 조회/저장/수정/삭제를 담당합니다.

식당에 비유하면: Handler = 웨이터, Service = 주방장, Repository = 냉장고

</details>

### 문제 2

요청 모델과 응답 모델을 분리하는 이유는?

<details>
<summary>정답 보기</summary>

**상황에 따라 필요한 필드가 다르기 때문입니다.**

- 요청 모델(`CreateUserRequest`): 클라이언트가 보내는 데이터만 포함 (name, email). id는 서버가 생성하므로 포함하지 않습니다.
- 응답 모델(`UserResponse`): 클라이언트에게 보여줄 데이터만 포함 (id, name, email). password_hash 같은 민감 정보를 실수로 노출하는 것을 방지합니다.
- DB 모델(`User`): DB 테이블의 모든 컬럼에 대응 (id, name, email, created_at, password_hash 등).

</details>

### 문제 3

다음 코드에서 `?` 연산자가 에러를 전파할 수 있는 이유는?

```rust
pub async fn get_user_by_id(pool: &PgPool, id: i32) -> Result<UserResponse, AppError> {
    let user = UserRepository::find_by_id(pool, id).await?;
    // ...
}
```

<details>
<summary>정답 보기</summary>

`UserRepository::find_by_id()`는 `Result<Option<User>, sqlx::Error>`를 반환합니다. `?` 연산자는 에러가 발생하면 `sqlx::Error`를 반환하려 합니다.

함수의 반환 타입은 `Result<..., AppError>`인데, `error.rs`에서 `From<sqlx::Error> for AppError`를 구현했기 때문에 `?`가 자동으로 `sqlx::Error`를 `AppError::Database`로 변환합니다.

```rust
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        AppError::Database(err)
    }
}
```

이 `From` 구현이 없으면 `?` 연산자를 사용할 수 없고 컴파일 에러가 발생합니다.

</details>

### 문제 4

`AppState`를 `Arc`로 감싸는 이유는?

<details>
<summary>정답 보기</summary>

웹서버는 여러 요청을 **동시에**(멀티 스레드로) 처리합니다. 각 핸들러 스레드가 DB 커넥션 풀과 설정값에 접근해야 하므로, `AppState`를 여러 스레드가 **안전하게 공유**해야 합니다.

12장에서 배운 것처럼:
- `Arc<T>`는 멀티 스레드 환경에서 데이터를 안전하게 공유하는 스마트 포인터입니다.
- `Arc::clone()`은 데이터를 복사하지 않고 참조 카운트만 증가시킵니다.
- 모든 핸들러가 같은 `AppState`(같은 DB 풀)를 공유하되, 각자 독립적으로 접근할 수 있습니다.

</details>

### 문제 5

`.env` 파일을 `.gitignore`에 추가해야 하는 이유는?

<details>
<summary>정답 보기</summary>

`.env` 파일에는 **민감한 정보**가 포함되어 있기 때문입니다:
- 데이터베이스 비밀번호 (`DATABASE_URL`)
- API 키, 시크릿 키 등

이 파일이 Git에 커밋되어 GitHub에 올라가면:
- 누구나 DB 비밀번호를 볼 수 있습니다.
- 악의적인 사용자가 DB에 접근할 수 있습니다.
- 한번 올라간 커밋은 삭제해도 히스토리에 남습니다.

`.gitignore`에 `.env`를 추가하고, 대신 `.env.example` 파일에 키 이름만 적어 공유합니다:

```env
# .env.example (이 파일은 Git에 커밋해도 됩니다)
DATABASE_URL=postgres://user:password@localhost:5432/dbname
SERVER_HOST=127.0.0.1
SERVER_PORT=3000
```

</details>

---

## 10. 21장 정리

| 배운 것 | 핵심 |
|---------|------|
| 레이어드 아키텍처 | Handler(웨이터) -> Service(주방장) -> Repository(냉장고) |
| 디렉토리 구조 | handlers/, services/, repositories/, models/ 분리 |
| Config 관리 | `.env` + `dotenvy` + Config 구조체 |
| AppState | DB 풀, 설정 등 공유 데이터를 Arc로 감싸기 |
| 에러 타입 | AppError enum + IntoResponse + From 구현 |
| 모델 분리 | 요청(Deserialize) / 응답(Serialize) / DB(FromRow) |
| From 트레이트 | DB 모델 -> 응답 모델 변환에 활용 |
| 마이그레이션 | SQL 파일로 DB 스키마 관리 |
| 얼리 리턴 | 유효성 검사 실패 시 즉시 에러 반환 |

---

## 다음 장 예고

> **22장. 인증과 인가**에서는 사용자 인증 시스템을 구현합니다.
> 비밀번호를 안전하게 저장하는 해싱(argon2), 로그인 시 JWT 토큰 발급과 검증,
> 인증 미들웨어로 보호된 API 만들기, 권한 기반 접근 제어까지 다룹니다.
> 이 장에서 만든 프로젝트 구조 위에 인증 레이어를 추가합니다!
