# 11장. 클로저와 이터레이터

> **목표**: 클로저와 이터레이터를 활용하여 데이터를 함수형 스타일로 처리할 수 있다.

---

## 1. 클로저 (Closure)

클로저는 **이름 없는 함수**입니다. `|매개변수|` 로 정의하고, 변수에 저장할 수 있습니다:

```rust
fn main() {
    let add = |a, b| a + b;
    println!("{}", add(3, 5)); // 8

    let square = |x| x * x;
    println!("{}", square(4)); // 16
}
```

일반 함수와 비교하면 이렇습니다:

```rust
// 일반 함수
fn add_fn(a: i32, b: i32) -> i32 {
    a + b
}

// 클로저 (같은 기능)
let add_cl = |a: i32, b: i32| -> i32 { a + b };

// 클로저는 타입 추론이 되므로 생략 가능
let add_cl = |a, b| a + b;
```

### 주변 변수 캡처

클로저가 일반 함수와 다른 가장 큰 특징은 **주변 변수를 사용할 수 있다**는 것입니다:

```rust
fn main() {
    let name = "Rust";
    let greet = || println!("Hello, {}!", name); // name을 캡처
    greet(); // Hello, Rust!

    let threshold = 10;
    let is_big = |x| x > threshold; // threshold를 캡처
    println!("{}", is_big(15)); // true
    println!("{}", is_big(5));  // false
}
```

> 일반 함수(`fn`)는 주변 변수를 사용할 수 없습니다. 클로저만 가능합니다.

### 여러 줄 클로저

본문이 길면 중괄호로 감쌉니다:

```rust
fn main() {
    let calculate = |price: i32, quantity: i32| {
        let subtotal = price * quantity;
        let tax = subtotal / 10;
        subtotal + tax
    };

    println!("총액: {}원", calculate(1000, 3)); // 총액: 3300원
}
```

---

## 2. 클로저의 캡처 방식

클로저가 주변 변수를 캡처하는 방식은 **3가지**입니다. 컴파일러가 자동으로 가장 적은 권한을 선택합니다.

### 불변 빌림 (Fn)

변수를 **읽기만** 할 때:

```rust
fn main() {
    let name = String::from("Rust");

    let greet = || println!("Hello, {}!", name); // name을 불변 빌림

    greet();
    greet(); // 여러 번 호출 가능
    println!("{}", name); // name 여전히 사용 가능
}
```

### 가변 빌림 (FnMut)

변수를 **수정**할 때:

```rust
fn main() {
    let mut count = 0;

    let mut increment = || {
        count += 1; // count를 가변 빌림
        println!("count = {}", count);
    };

    increment(); // count = 1
    increment(); // count = 2
    increment(); // count = 3
}
```

> 클로저 자체도 `mut`으로 선언해야 합니다. 내부 상태가 바뀌니까요.

### 소유권 이동 (FnOnce)

변수의 **소유권을 가져갈** 때:

```rust
fn main() {
    let name = String::from("Rust");

    let consume = || {
        let moved = name; // name의 소유권을 가져감
        println!("소비됨: {}", moved);
    };

    consume();
    // consume(); // 에러! 이미 name의 소유권이 이동됨
    // println!("{}", name); // 에러! name은 이미 이동됨
}
```

### move 키워드

`move`를 붙이면 캡처하는 모든 변수의 **소유권을 강제로 이동**합니다:

```rust
fn main() {
    let name = String::from("Rust");

    let greet = move || println!("Hello, {}!", name);
    // name의 소유권이 클로저 안으로 이동됨

    greet();
    // println!("{}", name); // 에러! name은 이동됨
}
```

> `move`는 나중에 배울 스레드에서 자주 사용됩니다. 클로저가 다른 스레드로 넘어갈 때 변수의 소유권도 함께 넘겨야 하기 때문입니다.

### 캡처 방식 정리

| 캡처 방식 | 트레이트 | 변수에 하는 일 | 호출 횟수 |
|-----------|---------|--------------|----------|
| 불변 빌림 | `Fn` | 읽기만 | 여러 번 |
| 가변 빌림 | `FnMut` | 수정 | 여러 번 |
| 소유권 이동 | `FnOnce` | 소유권 가져감 | **1번만** |

<details>
<summary><b>Fn, FnMut, FnOnce 트레이트의 관계와 컴파일러의 자동 선택 (원리)</b></summary>

### 세 트레이트의 상속 관계

```
FnOnce (가장 넓음)
  └── FnMut (FnOnce를 포함)
        └── Fn (FnMut를 포함, 가장 좁음)
```

**모든 클로저는 `FnOnce`입니다.** 최소 한 번은 호출할 수 있으니까요.

그 중에서 소유권을 소비하지 않는 클로저는 `FnMut`도 됩니다. 여러 번 호출할 수 있으니까요.

그 중에서 가변 빌림도 하지 않는 클로저는 `Fn`도 됩니다. 가장 제한이 적습니다.

### 컴파일러의 자동 선택

컴파일러는 클로저 본문을 분석해서 **가장 적은 권한**을 자동으로 선택합니다:

```rust
let name = String::from("Rust");

// 1. 읽기만 → Fn 선택
let a = || println!("{}", name);

// 2. 수정 → FnMut 선택
let mut count = 0;
let mut b = || count += 1;

// 3. 소유권 이동 → FnOnce 선택
let c = || drop(name);
```

### 함수 매개변수에서의 의미

함수가 클로저를 받을 때 이 트레이트를 사용합니다:

```rust
// Fn: 클로저가 아무것도 소비하지 않음 → 여러 번 호출 가능
fn call_twice(f: impl Fn()) {
    f();
    f();
}

// FnMut: 클로저가 내부 상태를 변경할 수 있음
fn call_with_mut(mut f: impl FnMut()) {
    f();
    f();
}

// FnOnce: 클로저가 소유권을 소비할 수 있음 → 1번만 호출
fn call_once(f: impl FnOnce()) {
    f();
}
```

**실전 팁**: 함수 매개변수로 클로저를 받을 때는 **가장 넓은 트레이트(`FnOnce`)**부터 시도하고, 여러 번 호출해야 하면 `FnMut`이나 `Fn`으로 좁히세요.

</details>

---

## 3. 이터레이터 기초

이터레이터는 **컬렉션의 요소를 하나씩 꺼내는** 도구입니다.

### iter(), into_iter(), iter_mut() 차이

```rust
fn main() {
    let names = vec!["Alice", "Bob", "Charlie"];

    // iter(): 불변 참조 (&T)
    for name in names.iter() {
        println!("{}", name); // name은 &&str
    }
    println!("{:?}", names); // names 여전히 사용 가능

    // into_iter(): 소유권 이동 (T)
    let names2 = vec!["Alice", "Bob", "Charlie"];
    for name in names2.into_iter() {
        println!("{}", name); // name은 &str (소유권 이동)
    }
    // println!("{:?}", names2); // 에러! 소유권 이동됨

    // iter_mut(): 가변 참조 (&mut T)
    let mut scores = vec![80, 90, 70];
    for score in scores.iter_mut() {
        *score += 10; // 각 요소에 10점 추가
    }
    println!("{:?}", scores); // [90, 100, 80]
}
```

| 메서드 | 반환 타입 | 원본 사용 | 용도 |
|--------|----------|----------|------|
| `.iter()` | `&T` | 가능 | 읽기만 할 때 |
| `.into_iter()` | `T` | 불가능 | 소유권이 필요할 때 |
| `.iter_mut()` | `&mut T` | 가능 (수정됨) | 요소를 수정할 때 |

### next() 메서드

이터레이터의 핵심은 `next()`입니다. 호출할 때마다 다음 요소를 반환합니다:

```rust
fn main() {
    let numbers = vec![10, 20, 30];
    let mut iter = numbers.iter();

    println!("{:?}", iter.next()); // Some(10)
    println!("{:?}", iter.next()); // Some(20)
    println!("{:?}", iter.next()); // Some(30)
    println!("{:?}", iter.next()); // None (더 이상 없음)
}
```

> `Some`과 `None`은 5장에서 배운 `Option<T>`입니다. 요소가 있으면 `Some(값)`, 없으면 `None`을 반환합니다.

### for 루프와의 관계

`for` 루프는 사실 이터레이터의 문법 설탕(syntactic sugar)입니다:

```rust
let numbers = vec![1, 2, 3];

// 이 코드와
for n in &numbers {
    println!("{}", n);
}

// 이 코드는 같은 의미
let mut iter = numbers.iter();
loop {
    match iter.next() {
        Some(n) => println!("{}", n),
        None => break,
    }
}
```

---

## 4. 이터레이터 어댑터 (핵심!)

이터레이터 어댑터는 이터레이터를 **변환**하는 메서드입니다. 체이닝(연결)해서 사용합니다.

### map: 변환

각 요소를 변환합니다:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    let doubled: Vec<i32> = numbers.iter()
        .map(|&x| x * 2)
        .collect();

    println!("{:?}", doubled); // [2, 4, 6, 8, 10]
}
```

### filter: 조건으로 걸러내기

조건에 맞는 요소만 남깁니다:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let evens: Vec<&i32> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .collect();

    println!("{:?}", evens); // [2, 4, 6, 8, 10]
}
```

> `filter`의 클로저는 **참조의 참조**(`&&x`)를 받습니다. `iter()`가 `&i32`를 만들고, `filter`가 다시 `&`를 붙이기 때문입니다.

### enumerate: 인덱스 포함

각 요소에 인덱스를 붙여줍니다:

```rust
fn main() {
    let fruits = vec!["사과", "바나나", "딸기"];

    for (index, fruit) in fruits.iter().enumerate() {
        println!("{}번: {}", index, fruit);
    }
    // 0번: 사과
    // 1번: 바나나
    // 2번: 딸기
}
```

### zip: 두 이터레이터 합치기

두 이터레이터를 짝지어 합칩니다:

```rust
fn main() {
    let names = vec!["Alice", "Bob", "Charlie"];
    let scores = vec![90, 85, 95];

    let result: Vec<(&&str, &i32)> = names.iter()
        .zip(scores.iter())
        .collect();

    println!("{:?}", result);
    // [("Alice", 90), ("Bob", 85), ("Charlie", 95)]

    // 실전에서는 이렇게 바로 사용
    for (name, score) in names.iter().zip(scores.iter()) {
        println!("{}: {}점", name, score);
    }
}
```

### take, skip: 일부만 가져오기

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // take: 앞에서 n개만
    let first_three: Vec<&i32> = numbers.iter().take(3).collect();
    println!("{:?}", first_three); // [1, 2, 3]

    // skip: 앞에서 n개를 건너뜀
    let after_three: Vec<&i32> = numbers.iter().skip(3).collect();
    println!("{:?}", after_three); // [4, 5, 6, 7, 8, 9, 10]

    // 조합: 4번째부터 3개
    let middle: Vec<&i32> = numbers.iter().skip(3).take(3).collect();
    println!("{:?}", middle); // [4, 5, 6]
}
```

### chain: 이터레이터 연결

두 이터레이터를 이어붙입니다:

```rust
fn main() {
    let first = vec![1, 2, 3];
    let second = vec![4, 5, 6];

    let combined: Vec<&i32> = first.iter()
        .chain(second.iter())
        .collect();

    println!("{:?}", combined); // [1, 2, 3, 4, 5, 6]
}
```

### 게으른 평가 (Lazy Evaluation)

이터레이터 어댑터는 **게으릅니다**. `collect()` 같은 소비 어댑터를 호출해야 비로소 실행됩니다:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // 이 시점에서는 아무것도 실행되지 않음!
    let lazy = numbers.iter()
        .map(|&x| {
            println!("처리 중: {}", x); // 이 줄은 아직 실행 안 됨
            x * 2
        })
        .filter(|&x| x > 4);

    println!("--- collect 호출 ---");

    // collect()를 호출해야 비로소 실행됨
    let result: Vec<i32> = lazy.collect();
    println!("{:?}", result);
}
```

실행 결과:
```
--- collect 호출 ---
처리 중: 1
처리 중: 2
처리 중: 3
처리 중: 4
처리 중: 5
[6, 8, 10]
```

> `collect()`를 호출하기 전까지 `map`과 `filter`는 실행되지 않습니다. 이것이 **게으른 평가**입니다.

---

## 5. 소비 어댑터

소비 어댑터는 이터레이터를 **소비**하여 최종 결과를 만듭니다.

### collect(): 결과를 컬렉션으로

이터레이터를 `Vec`, `HashMap` 등으로 변환합니다:

```rust
use std::collections::HashMap;

fn main() {
    // Vec으로 수집
    let numbers: Vec<i32> = (1..=5).collect();
    println!("{:?}", numbers); // [1, 2, 3, 4, 5]

    // HashMap으로 수집
    let pairs: HashMap<&str, i32> = vec![("Alice", 90), ("Bob", 85)]
        .into_iter()
        .collect();
    println!("{:?}", pairs); // {"Alice": 90, "Bob": 85}

    // String으로 수집
    let chars = vec!['R', 'u', 's', 't'];
    let word: String = chars.into_iter().collect();
    println!("{}", word); // Rust
}
```

### sum(), count(), min(), max()

```rust
fn main() {
    let numbers = vec![10, 20, 30, 40, 50];

    let total: i32 = numbers.iter().sum();
    println!("합계: {}", total); // 합계: 150

    let count = numbers.iter().count();
    println!("개수: {}", count); // 개수: 5

    let min = numbers.iter().min();
    println!("최솟값: {:?}", min); // 최솟값: Some(10)

    let max = numbers.iter().max();
    println!("최댓값: {:?}", max); // 최댓값: Some(50)
}
```

> `min()`과 `max()`는 빈 이터레이터일 수 있으므로 `Option`을 반환합니다.

### any(), all()

조건을 만족하는 요소가 있는지 확인합니다:

```rust
fn main() {
    let numbers = vec![1, 3, 5, 7, 8, 9];

    // any: 하나라도 조건을 만족하면 true
    let has_even = numbers.iter().any(|&x| x % 2 == 0);
    println!("짝수가 있나요? {}", has_even); // true (8이 있음)

    // all: 모든 요소가 조건을 만족하면 true
    let all_positive = numbers.iter().all(|&x| x > 0);
    println!("모두 양수인가요? {}", all_positive); // true
}
```

### find(), position()

조건에 맞는 첫 번째 요소를 찾습니다:

```rust
fn main() {
    let numbers = vec![1, 3, 5, 8, 10, 12];

    // find: 조건에 맞는 첫 번째 요소 반환
    let first_even = numbers.iter().find(|&&x| x % 2 == 0);
    println!("첫 짝수: {:?}", first_even); // Some(8)

    // position: 조건에 맞는 첫 번째 인덱스 반환
    let pos = numbers.iter().position(|&x| x % 2 == 0);
    println!("첫 짝수 위치: {:?}", pos); // Some(3)
}
```

### fold(): 누적 연산

모든 요소를 하나의 값으로 접어(fold) 합칩니다:

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5];

    // 합계 (sum과 동일한 효과)
    let sum = numbers.iter().fold(0, |acc, &x| acc + x);
    println!("합계: {}", sum); // 합계: 15

    // 곱 (1 * 1 * 2 * 3 * 4 * 5)
    let product = numbers.iter().fold(1, |acc, &x| acc * x);
    println!("곱: {}", product); // 곱: 120

    // 문자열 합치기
    let words = vec!["Rust", "는", "최고"];
    let sentence = words.iter().fold(String::new(), |acc, &w| acc + w);
    println!("{}", sentence); // Rust는최고
}
```

`fold`의 구조:

```
fold(초깃값, |누적값, 현재요소| 다음_누적값)

[1, 2, 3, 4, 5].fold(0, |acc, x| acc + x)

단계별 진행:
  acc=0,  x=1 → 0 + 1 = 1
  acc=1,  x=2 → 1 + 2 = 3
  acc=3,  x=3 → 3 + 3 = 6
  acc=6,  x=4 → 6 + 4 = 10
  acc=10, x=5 → 10 + 5 = 15  ← 최종 결과
```

<details>
<summary><b>for 루프 vs 이터레이터 체인 성능 비교 - 제로 코스트 추상화 (원리)</b></summary>

### 제로 코스트 추상화 (Zero-Cost Abstractions)

Rust의 이터레이터는 **제로 코스트 추상화**입니다. 추상적이고 읽기 쉬운 코드를 작성해도, 컴파일러가 직접 for 루프를 작성한 것과 **동일한 성능의 기계어 코드**를 만들어냅니다.

### 비교 예시

```rust
// 방법 1: for 루프
fn sum_of_doubled_evens_loop(numbers: &[i32]) -> i32 {
    let mut sum = 0;
    for &n in numbers {
        if n % 2 == 0 {
            sum += n * 2;
        }
    }
    sum
}

// 방법 2: 이터레이터 체인
fn sum_of_doubled_evens_iter(numbers: &[i32]) -> i32 {
    numbers.iter()
        .filter(|&&n| n % 2 == 0)
        .map(|&n| n * 2)
        .sum()
}
```

이 두 함수는 컴파일 후 **거의 동일한 어셈블리 코드**를 생성합니다. 경우에 따라 이터레이터 버전이 더 빠를 수도 있습니다.

### 왜 가능한가?

Rust 컴파일러는 **인라이닝(inlining)**과 **단일화(monomorphization)**를 수행합니다:

1. **인라이닝**: `map`, `filter` 등의 함수 호출을 제거하고, 본문 코드를 직접 삽입
2. **단일화**: 제네릭 코드를 구체 타입에 맞게 특수화된 코드로 변환
3. **최적화**: 중간 컬렉션 없이 요소를 하나씩 파이프라인처럼 처리

결과적으로, 이터레이터 체인은 수동 for 루프만큼 빠르면서도 더 읽기 쉬운 코드를 작성할 수 있게 해줍니다.

### 실전 결론

```
이터레이터 체인을 쓰세요!
- 성능 손해 없음 (제로 코스트)
- 코드가 더 읽기 쉬움
- 의도가 더 명확함
```

</details>

---

## 6. 실전 패턴

### 필터 + 변환 조합

가장 자주 사용하는 패턴입니다:

```rust
fn main() {
    let numbers = vec![-3, -1, 0, 2, 5, -4, 8, 3];

    // 양수만 골라서 2배로 만들기
    let result: Vec<i32> = numbers.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect();

    println!("{:?}", result); // [4, 10, 16, 6]
}
```

### 구조체와 함께 사용

```rust
struct User {
    name: String,
    age: u32,
    active: bool,
}

fn main() {
    let users = vec![
        User { name: String::from("Alice"), age: 25, active: true },
        User { name: String::from("Bob"), age: 17, active: true },
        User { name: String::from("Charlie"), age: 30, active: false },
        User { name: String::from("Diana"), age: 22, active: true },
    ];

    // 활성 상태이면서 성인인 사용자의 이름만 추출
    let adult_active_names: Vec<&String> = users.iter()
        .filter(|u| u.active)
        .filter(|u| u.age >= 18)
        .map(|u| &u.name)
        .collect();

    println!("{:?}", adult_active_names); // ["Alice", "Diana"]
}
```

### 웹 개발에서 자주 쓰는 패턴 미리보기

나중에 웹 서버를 만들 때 이런 식으로 사용하게 됩니다:

```rust
// 요청 파라미터에서 유효한 값만 추출
fn parse_ids(params: &[&str]) -> Vec<u32> {
    params.iter()
        .filter_map(|s| s.parse::<u32>().ok()) // 파싱 성공한 것만
        .collect()
}

fn main() {
    let raw = vec!["1", "abc", "3", "", "5", "xyz"];
    let ids = parse_ids(&raw);
    println!("{:?}", ids); // [1, 3, 5]
}
```

```rust
// JSON 응답용 데이터 변환
struct DbUser {
    id: u32,
    name: String,
    email: String,
    password_hash: String, // 이건 응답에 포함하면 안 됨!
}

struct UserResponse {
    id: u32,
    name: String,
    email: String,
}

fn to_response(users: Vec<DbUser>) -> Vec<UserResponse> {
    users.into_iter()
        .map(|u| UserResponse {
            id: u.id,
            name: u.name,
            email: u.email,
        })
        .collect()
}
```

> `filter_map`은 `filter`와 `map`을 합친 것입니다. `Some`을 반환하면 포함, `None`을 반환하면 제외합니다.

---

## 7. 실습

### 실습 1: 숫자 리스트에서 짝수만 골라 제곱하기

주어진 숫자 리스트에서 짝수만 골라 제곱한 결과를 만드세요.

```rust
fn even_squares(numbers: &[i32]) -> Vec<i32> {
    numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .map(|&x| x * x)
        .collect()
}

fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let result = even_squares(&numbers);
    println!("{:?}", result);
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
[4, 16, 36, 64, 100]
```

**포인트**: `filter`로 짝수(`x % 2 == 0`)만 남기고, `map`으로 제곱(`x * x`)합니다. 이터레이터 어댑터는 순서대로 적용됩니다.

</details>

### 실습 2: 문자열 리스트를 대문자로 변환

문자열 벡터의 각 요소를 대문자로 변환하세요.

```rust
fn to_uppercase_list(words: &[String]) -> Vec<String> {
    words.iter()
        .map(|w| w.to_uppercase())
        .collect()
}

fn main() {
    let words = vec![
        String::from("hello"),
        String::from("rust"),
        String::from("world"),
    ];

    let upper = to_uppercase_list(&words);
    println!("{:?}", upper);
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
["HELLO", "RUST", "WORLD"]
```

**포인트**: `to_uppercase()`는 `String`의 메서드로, 새로운 `String`을 반환합니다. `map`으로 각 요소에 적용하면 됩니다.

</details>

### 실습 3: fold로 구조체 리스트의 합계 구하기

주문 목록에서 `fold`를 사용하여 총 금액을 계산하세요.

```rust
struct Order {
    item: String,
    price: i32,
    quantity: i32,
}

fn total_amount(orders: &[Order]) -> i32 {
    orders.iter()
        .fold(0, |acc, order| acc + order.price * order.quantity)
}

fn main() {
    let orders = vec![
        Order { item: String::from("커피"), price: 4500, quantity: 2 },
        Order { item: String::from("케이크"), price: 6000, quantity: 1 },
        Order { item: String::from("쿠키"), price: 2000, quantity: 3 },
    ];

    let total = total_amount(&orders);
    println!("총 주문 금액: {}원", total);
}
```

<details>
<summary><b>실행 결과 확인</b></summary>

```
총 주문 금액: 21000원
```

**계산 과정**:
```
acc=0,     커피:  0 + 4500 * 2 = 9000
acc=9000,  케이크: 9000 + 6000 * 1 = 15000
acc=15000, 쿠키:  15000 + 2000 * 3 = 21000
```

**포인트**: `fold`의 초깃값을 `0`으로 두고, 각 주문의 `price * quantity`를 누적합니다. `sum()`은 단순 합계만 가능하지만, `fold`는 구조체 필드를 조합한 계산도 할 수 있습니다.

</details>

---

## 8. 확인 문제

### 문제 1

아래 코드의 출력 결과는?

```rust
let numbers = vec![1, 2, 3, 4, 5];
let result: Vec<i32> = numbers.iter()
    .map(|&x| x * 3)
    .filter(|&x| x > 6)
    .collect();
println!("{:?}", result);
```

<details>
<summary>정답 보기</summary>

**`[9, 12, 15]`**

```
map 후: [3, 6, 9, 12, 15]
filter(x > 6) 후: [9, 12, 15]
```

`map`이 먼저 실행되어 모든 요소를 3배로 만든 뒤, `filter`가 6보다 큰 값만 남깁니다.

</details>

### 문제 2

`iter()`와 `into_iter()`의 차이점은?

<details>
<summary>정답 보기</summary>

- `iter()`: 요소의 **불변 참조(`&T`)**를 반환합니다. 원본 컬렉션을 **계속 사용할 수 있습니다**.
- `into_iter()`: 요소의 **소유권(`T`)**을 반환합니다. 원본 컬렉션은 **더 이상 사용할 수 없습니다**.

```rust
let v = vec![1, 2, 3];
for x in v.iter() { }     // v 사용 가능
println!("{:?}", v);       // OK

let v2 = vec![1, 2, 3];
for x in v2.into_iter() { } // v2 소유권 이동
// println!("{:?}", v2);    // 에러!
```

</details>

### 문제 3

이터레이터 어댑터(map, filter 등)가 "게으르다(lazy)"는 것은 무슨 뜻인가요?

<details>
<summary>정답 보기</summary>

이터레이터 어댑터는 호출한 시점에 바로 실행되지 않습니다. `collect()`, `sum()`, `for` 루프 같은 **소비 어댑터를 호출해야 비로소 실행**됩니다.

```rust
let v = vec![1, 2, 3];

// 이 시점에서는 아무것도 실행되지 않음
let lazy = v.iter().map(|&x| x * 2);

// collect()를 호출해야 실행됨
let result: Vec<i32> = lazy.collect();
```

이 덕분에 불필요한 중간 컬렉션을 만들지 않아 **메모리와 성능이 효율적**입니다.

</details>

### 문제 4

다음 빈칸을 채워 숫자 리스트의 합계를 구하세요:

```rust
let numbers = vec![10, 20, 30, 40];
let total: i32 = numbers.iter().___();
println!("{}", total); // 100
```

<details>
<summary>정답 보기</summary>

**`sum`**

```rust
let numbers = vec![10, 20, 30, 40];
let total: i32 = numbers.iter().sum();
println!("{}", total); // 100
```

`sum()`은 이터레이터의 모든 요소를 더하는 소비 어댑터입니다. 반환 타입(`i32`)을 명시해야 합니다.

</details>

### 문제 5

`Fn`, `FnMut`, `FnOnce` 중 아래 클로저의 캡처 방식은?

```rust
let mut total = 0;
let mut add_to_total = |x: i32| {
    total += x;
};
add_to_total(10);
add_to_total(20);
```

<details>
<summary>정답 보기</summary>

**`FnMut`**

클로저가 `total`을 **수정(가변 빌림)**하고 있으므로 `FnMut`입니다.

- `Fn`이 아닌 이유: `total` 값을 변경하고 있으므로 불변 빌림이 아닙니다.
- `FnOnce`가 아닌 이유: 소유권을 이동하지 않고, 여러 번 호출할 수 있습니다.

</details>

---

## 9. 11장 정리

| 배운 것 | 핵심 |
|---------|------|
| 클로저 정의 | `\|매개변수\| 본문` 또는 `\|매개변수\| { 본문 }` |
| 변수 캡처 | 클로저는 주변 변수를 자동으로 캡처 |
| Fn | 불변 빌림, 여러 번 호출 가능 |
| FnMut | 가변 빌림, 여러 번 호출 가능 |
| FnOnce | 소유권 이동, 1번만 호출 가능 |
| move | 소유권을 강제로 이동 |
| iter() / into_iter() / iter_mut() | 불변 참조 / 소유권 이동 / 가변 참조 |
| map | 각 요소를 변환 |
| filter | 조건에 맞는 요소만 남김 |
| fold | 초깃값부터 누적 연산 |
| collect() | 이터레이터를 컬렉션으로 변환 |
| 게으른 평가 | 소비 어댑터를 호출해야 실행됨 |
| 제로 코스트 추상화 | for 루프와 동일한 성능 |

---

## 다음 장 예고

> **12장. 스마트 포인터**에서는 `Box<T>`, `Rc<T>`, `RefCell<T>` 등 Rust의 스마트 포인터를 배웁니다.
> 힙 메모리에 데이터를 저장하고, 여러 곳에서 소유권을 공유하며, 내부 가변성을 활용하는 방법을 다룹니다!
