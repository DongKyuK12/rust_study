# 07장. 에러 처리

> **목표**: Rust의 에러 처리 방식을 이해하고, 안전하게 에러를 다룰 수 있다.

---

## 1. panic!과 복구 불가능한 에러

프로그램이 **더 이상 진행할 수 없는 상황**에서는 `panic!`이 발생합니다.

### 직접 panic! 일으키기

```rust
fn main() {
    panic!("심각한 에러 발생!");
}
```

실행 결과:
```
thread 'main' panicked at '심각한 에러 발생!', src/main.rs:2:5
```

### 자동으로 panic이 발생하는 경우

```rust
fn main() {
    let numbers = vec![1, 2, 3];
    println!("{}", numbers[10]); // 범위 초과 -> 자동 panic!
}
```

배열 범위를 벗어나면 Rust가 자동으로 `panic!`을 일으킵니다. C/C++처럼 이상한 메모리를 읽는 게 아니라, **즉시 멈춥니다**.

### panic은 언제 쓰나?

| 상황 | panic 사용 |
|------|-----------|
| 프로토타입, 예제 코드 | O |
| 진짜 복구 불가능한 버그 | O |
| 파일 열기 실패 | X (복구 가능) |
| 사용자 입력 오류 | X (복구 가능) |
| 네트워크 에러 | X (복구 가능) |

> 실제 서버 코드에서는 `panic!`을 거의 쓰지 않습니다. 서버가 죽으면 안 되니까요!

---

## 2. Result<T, E>로 에러 처리

Rust에서 **복구 가능한 에러**는 `Result`로 처리합니다.

### Result란?

```rust
enum Result<T, E> {
    Ok(T),    // 성공: 값 T를 담고 있음
    Err(E),   // 실패: 에러 E를 담고 있음
}
```

- `Ok(값)` : 성공했을 때의 결과
- `Err(에러)` : 실패했을 때의 에러 정보

### match로 Result 처리

```rust
use std::fs;

fn main() {
    let result = fs::read_to_string("hello.txt");

    match result {
        Ok(content) => println!("파일 내용: {}", content),
        Err(error) => println!("파일 읽기 실패: {}", error),
    }
}
```

`match`를 쓰면 성공과 실패를 **반드시** 모두 처리해야 합니다. 빼먹으면 컴파일 에러!

### unwrap()과 expect() - 간단하지만 위험

```rust
use std::fs;

fn main() {
    // unwrap: 성공하면 값 반환, 실패하면 panic!
    let content = fs::read_to_string("hello.txt").unwrap();

    // expect: unwrap과 같지만 에러 메시지를 지정할 수 있음
    let content = fs::read_to_string("hello.txt")
        .expect("hello.txt를 열 수 없습니다");
}
```

| 메서드 | 성공 시 | 실패 시 |
|--------|---------|---------|
| `unwrap()` | 값 반환 | panic! (메시지 없음) |
| `expect("메시지")` | 값 반환 | panic! (메시지 있음) |

> `unwrap()`과 `expect()`는 실패하면 프로그램이 죽습니다! 프로토타입에서만 쓰세요.

<details>
<summary><b>왜 Rust는 예외(exception)가 없나? (원리)</b></summary>

### 예외 vs Result

다른 언어들은 **예외(exception)** 를 씁니다:

```python
# Python의 예외 처리
try:
    file = open("hello.txt")
    content = file.read()
except FileNotFoundError:
    print("파일 없음")
```

이 방식의 문제점:
- 함수 시그니처만 봐서는 **어떤 예외가 발생하는지 알 수 없습니다**
- 예외를 안 잡으면 프로그램이 조용히 터집니다
- "이 함수가 실패할 수 있다"는 사실을 쉽게 잊습니다

Rust의 `Result` 방식:

```rust
// 함수 시그니처만 봐도 "이 함수는 실패할 수 있구나"를 알 수 있음
fn read_file(path: &str) -> Result<String, std::io::Error> {
    std::fs::read_to_string(path)
}
```

장점:
- **함수 시그니처에 에러 가능성이 드러남** -> 실수를 방지
- **컴파일러가 에러 처리를 강제함** -> 빠뜨릴 수 없음
- **성능 오버헤드가 없음** -> 예외는 내부적으로 비용이 큼

</details>

---

## 3. ? 연산자

`?` 연산자는 Rust 에러 처리의 **핵심**입니다. 가장 많이 쓰는 패턴이니 확실히 익혀두세요!

### match가 반복되면 코드가 길어진다

파일을 읽고, 내용을 숫자로 변환하는 함수를 봅시다:

```rust
use std::fs;
use std::num::ParseIntError;
use std::io;

fn read_number_from_file() -> Result<i32, String> {
    // 1단계: 파일 읽기
    let content = match fs::read_to_string("number.txt") {
        Ok(c) => c,
        Err(e) => return Err(format!("파일 읽기 실패: {}", e)),
    };

    // 2단계: 숫자로 변환
    let number = match content.trim().parse::<i32>() {
        Ok(n) => n,
        Err(e) => return Err(format!("숫자 변환 실패: {}", e)),
    };

    Ok(number)
}
```

같은 `match` 패턴이 반복됩니다. 성공하면 값을 꺼내고, 실패하면 `return Err(...)` 하는 것뿐인데 코드가 깁니다.

### ? 연산자로 깔끔하게

```rust
use std::fs;

fn read_number_from_file() -> Result<i32, Box<dyn std::error::Error>> {
    let content = fs::read_to_string("number.txt")?;
    let number = content.trim().parse::<i32>()?;
    Ok(number)
}
```

`?`를 붙이면:
- **성공(Ok)** -> 값을 꺼내서 계속 진행
- **실패(Err)** -> 즉시 `return Err(에러)` (얼리 리턴!)

### ?는 얼리 리턴의 축약형!

`?` 연산자가 하는 일을 풀어쓰면 이렇습니다:

```rust
// 이 한 줄이:
let content = fs::read_to_string("number.txt")?;

// 이것과 같습니다:
let content = match fs::read_to_string("number.txt") {
    Ok(val) => val,
    Err(e) => return Err(e.into()),  // 얼리 리턴!
};
```

에러가 나면 함수를 **바로 빠져나갑니다**. 이것이 바로 얼리 리턴 패턴입니다!

### 체이닝: ?를 연결해서 쓰기

```rust
use std::fs;

fn read_number() -> Result<i32, Box<dyn std::error::Error>> {
    // 파일 읽기 -> 공백 제거 -> 숫자 변환을 한 줄로
    let number = fs::read_to_string("number.txt")?.trim().parse::<i32>()?;
    Ok(number)
}
```

하지만 너무 길면 나눠 쓰는 게 읽기 좋습니다. 가독성이 우선!

### ? 연산자 사용 조건

`?`는 아무 데서나 쓸 수 없습니다. **Result를 반환하는 함수 안에서만** 사용할 수 있습니다.

```rust
// OK: 반환 타입이 Result
fn do_something() -> Result<(), String> {
    let value = some_function()?;  // 사용 가능
    Ok(())
}

// 에러: main()은 기본적으로 Result를 반환하지 않음
fn main() {
    let value = some_function()?;  // 컴파일 에러!
}
```

`main`에서도 쓰고 싶다면:

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string("hello.txt")?;
    println!("{}", content);
    Ok(())
}
```

<details>
<summary><b>? 연산자가 내부적으로 하는 일 (원리)</b></summary>

### ? 연산자의 동작 과정

`?`는 단순한 문법 설탕(syntax sugar)이 아닙니다. 내부적으로 **From 트레이트**를 사용해서 에러를 변환합니다.

```rust
// ? 연산자를 풀어쓰면:
let content = match fs::read_to_string("number.txt") {
    Ok(val) => val,
    Err(e) => return Err(From::from(e)),  // From 트레이트로 에러 변환!
};
```

`From::from(e)`는 에러 타입을 **자동으로 변환**합니다.

예를 들어, `io::Error`를 `Box<dyn Error>`로 변환할 수 있는 이유는 `From` 트레이트가 구현되어 있기 때문입니다.

```
함수 반환 타입: Result<T, MyError>

? 사용 시 동작:
1. Result가 Ok(val)이면 -> val 반환
2. Result가 Err(e)이면 ->
   a. From::from(e)로 에러 타입 변환
   b. 변환된 에러를 Err()로 감쌈
   c. 즉시 return (얼리 리턴)
```

이 덕분에 **서로 다른 에러 타입**을 가진 함수들을 `?`로 자연스럽게 연결할 수 있습니다.

</details>

---

## 4. 커스텀 에러 타입

실제 프로젝트에서는 여러 종류의 에러가 발생합니다. 이때 **자신만의 에러 타입**을 만들면 편리합니다.

### enum으로 에러 타입 정의

```rust
use std::fmt;
use std::num::ParseIntError;

#[derive(Debug)]
enum AppError {
    FileNotFound(String),
    ParseError(ParseIntError),
    InvalidAge(String),
}
```

### Display 트레이트 구현

에러를 `println!`으로 출력하려면 `Display` 트레이트를 구현해야 합니다:

```rust
impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::FileNotFound(path) => write!(f, "파일을 찾을 수 없음: {}", path),
            AppError::ParseError(e) => write!(f, "숫자 변환 실패: {}", e),
            AppError::InvalidAge(msg) => write!(f, "잘못된 나이: {}", msg),
        }
    }
}
```

### From 트레이트로 에러 자동 변환

`From`을 구현하면 `?` 연산자가 에러를 자동으로 변환합니다:

```rust
impl From<std::io::Error> for AppError {
    fn from(e: std::io::Error) -> Self {
        AppError::FileNotFound(e.to_string())
    }
}

impl From<ParseIntError> for AppError {
    fn from(e: ParseIntError) -> Self {
        AppError::ParseError(e)
    }
}

// 이제 ? 연산자로 자동 변환 가능!
fn read_age_from_file(path: &str) -> Result<i32, AppError> {
    let content = std::fs::read_to_string(path)?;  // io::Error -> AppError 자동 변환
    let age = content.trim().parse::<i32>()?;       // ParseIntError -> AppError 자동 변환

    if age < 0 {
        return Err(AppError::InvalidAge("음수는 안 됩니다".to_string()));
    }
    if age > 150 {
        return Err(AppError::InvalidAge("너무 큰 수입니다".to_string()));
    }

    Ok(age)
}
```

### thiserror 크레이트로 간편하게

위의 `Display`, `From` 구현을 직접 쓰면 반복이 많습니다. **thiserror** 크레이트를 쓰면 간편합니다:

```toml
# Cargo.toml
[dependencies]
thiserror = "2"
```

```rust
use thiserror::Error;

#[derive(Debug, Error)]
enum AppError {
    #[error("파일을 찾을 수 없음: {0}")]
    FileNotFound(#[from] std::io::Error),

    #[error("숫자 변환 실패: {0}")]
    ParseError(#[from] std::num::ParseIntError),

    #[error("잘못된 나이: {0}")]
    InvalidAge(String),
}
```

이것만으로 `Display`, `Error`, `From` 트레이트가 자동 구현됩니다!

<details>
<summary><b>thiserror vs anyhow, 언제 뭘 쓰나? (원리)</b></summary>

### thiserror와 anyhow 비교

Rust 에러 처리 크레이트는 크게 두 가지가 있습니다:

**thiserror** - 라이브러리 코드에서 사용
- 커스텀 에러 타입을 **쉽게 정의**하는 용도
- 에러의 종류를 구분할 수 있음
- API 사용자에게 명확한 에러 타입을 제공

```rust
// thiserror: 에러의 종류가 명확
match do_something() {
    Err(AppError::FileNotFound(_)) => println!("파일 없음"),
    Err(AppError::ParseError(_)) => println!("파싱 실패"),
    _ => {}
}
```

**anyhow** - 애플리케이션 코드에서 사용
- 에러 타입을 하나로 통합
- 에러 종류를 구분할 필요 없을 때 편리
- 빠르게 프로토타이핑할 때 좋음

```rust
use anyhow::Result;

// anyhow: 모든 에러를 하나로
fn do_something() -> Result<()> {
    let content = std::fs::read_to_string("file.txt")?;
    let number: i32 = content.trim().parse()?;
    Ok(())
}
```

**정리**:
| | thiserror | anyhow |
|---|---|---|
| 용도 | 라이브러리 | 애플리케이션 |
| 에러 구분 | 가능 | 어려움 |
| 보일러플레이트 | 적음 | 거의 없음 |
| 추천 상황 | API 설계, 공유 코드 | 바이너리, 서버 앱 |

웹서버 프로젝트에서는 보통 **thiserror로 에러를 정의**하고, 필요하면 **anyhow로 간편하게 처리**합니다.

</details>

---

## 5. 얼리 리턴을 활용한 에러 처리 패턴

에러 처리에서 가장 중요한 패턴입니다. **검증을 먼저 하고, 성공 로직은 뒤에** 두세요.

### 나쁜 예: 중첩이 깊은 코드

```rust
fn process_age(input: &str) -> Result<String, String> {
    match input.parse::<i32>() {
        Ok(age) => {
            if age >= 0 {
                if age <= 150 {
                    Ok(format!("나이: {}세", age))
                } else {
                    Err("너무 큰 수입니다".to_string())
                }
            } else {
                Err("음수는 안 됩니다".to_string())
            }
        }
        Err(_) => Err("숫자가 아닙니다".to_string()),
    }
}
```

중첩이 깊고, 성공 로직이 어디 있는지 찾기 어렵습니다.

### 좋은 예: 얼리 리턴 패턴

```rust
fn process_age(input: &str) -> Result<String, String> {
    let age: i32 = input.parse().map_err(|_| "숫자가 아닙니다".to_string())?;

    if age < 0 {
        return Err("음수는 안 됩니다".to_string());
    }
    if age > 150 {
        return Err("너무 큰 수입니다".to_string());
    }

    // 모든 검증을 통과한 후, 성공 로직
    Ok(format!("나이: {}세", age))
}
```

**패턴 정리**:
1. `?`로 변환 에러를 얼리 리턴
2. `if 잘못된조건 { return Err(...); }`로 검증 에러를 얼리 리턴
3. 마지막에 성공 로직만 남김

### 실전 예시: 회원가입 검증

```rust
fn validate_signup(
    username: &str,
    email: &str,
    password: &str,
) -> Result<String, String> {
    // 1. 빈 값 검증 - 잘못되면 즉시 반환
    if username.is_empty() {
        return Err("사용자 이름을 입력하세요".to_string());
    }
    if email.is_empty() {
        return Err("이메일을 입력하세요".to_string());
    }
    if password.is_empty() {
        return Err("비밀번호를 입력하세요".to_string());
    }

    // 2. 형식 검증
    if username.len() < 3 {
        return Err("사용자 이름은 3글자 이상이어야 합니다".to_string());
    }
    if !email.contains('@') {
        return Err("올바른 이메일 형식이 아닙니다".to_string());
    }
    if password.len() < 8 {
        return Err("비밀번호는 8글자 이상이어야 합니다".to_string());
    }

    // 3. 모든 검증 통과 -> 성공 로직
    Ok(format!("{}님, 가입을 환영합니다!", username))
}

fn main() {
    match validate_signup("kim", "kim@email.com", "12345678") {
        Ok(msg) => println!("{}", msg),
        Err(e) => println!("가입 실패: {}", e),
    }
}
```

이 패턴은 웹서버에서 **요청 검증**할 때 매우 자주 사용됩니다.

---

## 6. 실용 패턴 정리

### 상황별 에러 처리 방법

```rust
use std::fs;

fn main() {
    // 1. unwrap(): 프로토타입에서만 (실패하면 panic)
    let content = fs::read_to_string("test.txt").unwrap();

    // 2. expect(): 메시지 있는 unwrap (디버깅에 도움)
    let content = fs::read_to_string("test.txt")
        .expect("test.txt 읽기 실패");

    // 3. match: 에러별로 다른 처리가 필요할 때
    match fs::read_to_string("test.txt") {
        Ok(content) => println!("내용: {}", content),
        Err(ref e) if e.kind() == std::io::ErrorKind::NotFound => {
            println!("파일이 없습니다. 새로 만들게요.");
        }
        Err(e) => println!("알 수 없는 에러: {}", e),
    }
}

// 4. ?: 실제 코드에서 가장 많이 사용
fn read_config() -> Result<String, std::io::Error> {
    let content = fs::read_to_string("config.txt")?;
    Ok(content)
}
```

### 추천 사용 가이드

| 상황 | 추천 방법 | 이유 |
|------|----------|------|
| 빠른 프로토타입 | `unwrap()` | 짧고 빠름 |
| 디버깅용 프로토타입 | `expect("메시지")` | 어디서 터졌는지 알 수 있음 |
| 실제 프로덕션 코드 | `?` 연산자 | 깔끔하고 안전함 |
| 에러별 분기 처리 | `match` | 세밀한 제어 가능 |
| 기본값으로 대체 | `unwrap_or()` | 실패 시 대안 제공 |

### unwrap_or 시리즈

```rust
fn main() {
    // 실패하면 기본값 사용
    let port: u16 = "abc".parse().unwrap_or(8080);
    println!("포트: {}", port); // 포트: 8080

    // 실패하면 클로저 실행
    let port: u16 = "abc".parse().unwrap_or_else(|_| {
        println!("파싱 실패, 기본 포트 사용");
        8080
    });

    // 실패하면 기본값 (Default 트레이트)
    let port: u16 = "abc".parse().unwrap_or_default();
    println!("포트: {}", port); // 포트: 0 (u16의 기본값)
}
```

---

## 7. 실습

### 실습 1: 숫자 파싱 함수 만들기

문자열을 받아서 양수인 정수로 변환하는 함수를 만드세요. 얼리 리턴 패턴을 사용하세요.

```rust
fn parse_positive_number(input: &str) -> Result<u32, String> {
    // 여기에 구현하세요!
    // 조건 1: 빈 문자열이면 Err
    // 조건 2: 숫자가 아니면 Err
    // 조건 3: 0이면 Err ("0보다 커야 합니다")
    // 조건 4: 성공하면 Ok(숫자)
    todo!()
}

fn main() {
    println!("{:?}", parse_positive_number("42"));    // Ok(42)
    println!("{:?}", parse_positive_number(""));      // Err(...)
    println!("{:?}", parse_positive_number("abc"));   // Err(...)
    println!("{:?}", parse_positive_number("0"));     // Err(...)
    println!("{:?}", parse_positive_number("-5"));    // Err(...)
}
```

<details>
<summary>정답 보기</summary>

```rust
fn parse_positive_number(input: &str) -> Result<u32, String> {
    if input.is_empty() {
        return Err("빈 문자열입니다".to_string());
    }

    let number: i64 = input.parse()
        .map_err(|_| format!("'{}'는 숫자가 아닙니다", input))?;

    if number <= 0 {
        return Err("0보다 커야 합니다".to_string());
    }

    Ok(number as u32)
}

fn main() {
    println!("{:?}", parse_positive_number("42"));
    println!("{:?}", parse_positive_number(""));
    println!("{:?}", parse_positive_number("abc"));
    println!("{:?}", parse_positive_number("0"));
    println!("{:?}", parse_positive_number("-5"));
}
```

</details>

### 실습 2: 설정 파일 파서

key=value 형식의 설정 문자열을 파싱하는 함수를 만드세요.

```rust
fn parse_config_line(line: &str) -> Result<(String, String), String> {
    // 여기에 구현하세요!
    // 조건 1: 빈 줄이면 Err
    // 조건 2: '='가 없으면 Err
    // 조건 3: key가 비어있으면 Err
    // 조건 4: 성공하면 Ok((key, value))
    // 힌트: split_once('=')를 사용하세요
    todo!()
}

fn main() {
    println!("{:?}", parse_config_line("host=localhost")); // Ok(("host", "localhost"))
    println!("{:?}", parse_config_line("port=8080"));      // Ok(("port", "8080"))
    println!("{:?}", parse_config_line(""));                // Err(...)
    println!("{:?}", parse_config_line("no_equals"));      // Err(...)
    println!("{:?}", parse_config_line("=value"));         // Err(...)
}
```

<details>
<summary>정답 보기</summary>

```rust
fn parse_config_line(line: &str) -> Result<(String, String), String> {
    if line.is_empty() {
        return Err("빈 줄입니다".to_string());
    }

    let (key, value) = line.split_once('=')
        .ok_or_else(|| format!("'='를 찾을 수 없습니다: {}", line))?;

    let key = key.trim();
    if key.is_empty() {
        return Err("key가 비어있습니다".to_string());
    }

    Ok((key.to_string(), value.trim().to_string()))
}

fn main() {
    println!("{:?}", parse_config_line("host=localhost"));
    println!("{:?}", parse_config_line("port=8080"));
    println!("{:?}", parse_config_line(""));
    println!("{:?}", parse_config_line("no_equals"));
    println!("{:?}", parse_config_line("=value"));
}
```

</details>

### 실습 3: 점수 등급 계산기

여러 단계의 에러 처리를 연결하는 함수를 만드세요.

```rust
fn calculate_grade(scores: &[&str]) -> Result<String, String> {
    // 여기에 구현하세요!
    // 조건 1: scores가 비어있으면 Err
    // 조건 2: 각 점수를 f64로 파싱 (실패하면 Err)
    // 조건 3: 점수가 0.0~100.0 범위 밖이면 Err
    // 조건 4: 평균 계산 후 등급 반환
    //   90 이상: "A", 80 이상: "B", 70 이상: "C", 60 이상: "D", 나머지: "F"
    todo!()
}

fn main() {
    println!("{:?}", calculate_grade(&["90", "85", "92"]));  // Ok("A")
    println!("{:?}", calculate_grade(&["70", "65", "80"]));  // Ok("C")
    println!("{:?}", calculate_grade(&[]));                   // Err(...)
    println!("{:?}", calculate_grade(&["90", "abc"]));        // Err(...)
    println!("{:?}", calculate_grade(&["90", "150"]));        // Err(...)
}
```

<details>
<summary>정답 보기</summary>

```rust
fn calculate_grade(scores: &[&str]) -> Result<String, String> {
    if scores.is_empty() {
        return Err("점수가 없습니다".to_string());
    }

    let mut total = 0.0_f64;

    for (i, score_str) in scores.iter().enumerate() {
        let score: f64 = score_str.parse()
            .map_err(|_| format!("{}번째 값 '{}'는 숫자가 아닙니다", i + 1, score_str))?;

        if score < 0.0 || score > 100.0 {
            return Err(format!("점수는 0~100 범위여야 합니다: {}", score));
        }

        total += score;
    }

    let average = total / scores.len() as f64;

    let grade = if average >= 90.0 {
        "A"
    } else if average >= 80.0 {
        "B"
    } else if average >= 70.0 {
        "C"
    } else if average >= 60.0 {
        "D"
    } else {
        "F"
    };

    Ok(format!("{} (평균: {:.1})", grade, average))
}

fn main() {
    println!("{:?}", calculate_grade(&["90", "85", "92"]));
    println!("{:?}", calculate_grade(&["70", "65", "80"]));
    println!("{:?}", calculate_grade(&[]));
    println!("{:?}", calculate_grade(&["90", "abc"]));
    println!("{:?}", calculate_grade(&["90", "150"]));
}
```

</details>

---

## 8. 확인 문제

### 문제 1

다음 중 `panic!`을 사용하기에 적절한 상황은?
- (a) 사용자가 잘못된 이메일을 입력했을 때
- (b) 데이터베이스 연결이 실패했을 때
- (c) 프로그래머가 절대 일어나면 안 되는 버그를 발견했을 때
- (d) 파일을 찾을 수 없을 때

### 문제 2

아래 코드에서 `?` 연산자가 하는 일을 설명하세요:
```rust
fn read_file(path: &str) -> Result<String, std::io::Error> {
    let content = std::fs::read_to_string(path)?;
    Ok(content)
}
```

### 문제 3

다음 코드가 컴파일되지 않는 이유는?
```rust
fn main() {
    let content = std::fs::read_to_string("hello.txt")?;
    println!("{}", content);
}
```
- (a) `read_to_string` 함수가 존재하지 않아서
- (b) `main` 함수가 `Result`를 반환하지 않아서
- (c) `?` 연산자 문법이 틀려서
- (d) `std::fs`를 import하지 않아서

### 문제 4

`unwrap()`과 `?` 연산자의 차이점을 한 문장으로 설명하세요.

### 문제 5

아래 코드의 빈칸을 채워서, 얼리 리턴 패턴으로 에러를 처리하세요:
```rust
fn divide(a: &str, b: &str) -> Result<f64, String> {
    let a: f64 = a.parse().map_err(|_| "첫 번째 값이 숫자가 아닙니다".to_string())_____;
    let b: f64 = b.parse().map_err(|_| "두 번째 값이 숫자가 아닙니다".to_string())_____;

    if b == 0.0 {
        ____________________________________
    }

    Ok(a / b)
}
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답: **(c) 프로그래머가 절대 일어나면 안 되는 버그를 발견했을 때**
`panic!`은 프로그램 논리상 절대 발생하면 안 되는 상황에서 사용합니다. (a), (b), (d)는 모두 실행 중 충분히 발생할 수 있는 상황이므로 `Result`로 처리해야 합니다.

### 문제 2 정답
`?` 연산자는 `read_to_string`의 결과가 `Ok`이면 내부 값(`String`)을 꺼내고, `Err`이면 해당 에러를 즉시 `return Err(에러)`로 함수를 빠져나갑니다. 즉, 에러 발생 시 **얼리 리턴**합니다.

### 문제 3 정답: **(b) main 함수가 Result를 반환하지 않아서**
`?` 연산자는 `Result`를 반환하는 함수 안에서만 사용할 수 있습니다. `main`에서 쓰려면 `fn main() -> Result<(), Box<dyn std::error::Error>>`로 바꿔야 합니다.

### 문제 4 정답
`unwrap()`은 에러 시 프로그램을 panic으로 종료시키고, `?`는 에러를 호출자에게 전파(반환)합니다.

### 문제 5 정답
```rust
fn divide(a: &str, b: &str) -> Result<f64, String> {
    let a: f64 = a.parse().map_err(|_| "첫 번째 값이 숫자가 아닙니다".to_string())?;
    let b: f64 = b.parse().map_err(|_| "두 번째 값이 숫자가 아닙니다".to_string())?;

    if b == 0.0 {
        return Err("0으로 나눌 수 없습니다".to_string());
    }

    Ok(a / b)
}
```
각 `parse()` 뒤에 `?`를 붙이고, `b == 0.0`이면 `return Err(...)`로 얼리 리턴합니다.

</details>

---

## 9. 7장 정리

| 배운 것 | 핵심 |
|---------|------|
| `panic!` | 복구 불가능한 에러. 프로그램 즉시 종료 |
| `Result<T, E>` | 복구 가능한 에러. `Ok(값)` 또는 `Err(에러)` |
| `match` | Result를 패턴 매칭으로 처리 |
| `unwrap()` / `expect()` | 간편하지만 실패 시 panic. 프로토타입용 |
| `?` 연산자 | 에러 시 얼리 리턴. 실전에서 가장 많이 사용 |
| 커스텀 에러 | `enum`으로 정의, `thiserror`로 간편하게 |
| 얼리 리턴 패턴 | 검증 먼저, 성공 로직은 맨 뒤에 |
| `unwrap_or()` 시리즈 | 에러 시 기본값으로 대체 |

---

## 다음 장 예고

> **08장. 모듈과 패키지**에서는 코드를 체계적으로 정리하는 방법을 배웁니다.
> 파일을 나누고, 모듈로 구조화하고, 외부 크레이트를 가져와서 사용하는 방법을 알아봅니다!
