# 22장. 인증과 인가

> **목표**: 비밀번호 해싱, JWT 토큰 기반 인증 시스템을 구현할 수 있다.

> 로그인 시스템을 만듭니다! 웹서버에서 "누가 요청했는지" 확인하고, "이 사람이 할 수 있는 일인지" 판단하는 방법을 배웁니다.

---

## 1. 인증 vs 인가

### 인증(Authentication): "너 누구야?"

사용자가 **본인이 맞는지** 확인하는 과정입니다. 로그인이 대표적인 인증입니다.

### 인가(Authorization): "너 이거 할 수 있어?"

인증된 사용자가 **특정 작업을 할 권한이 있는지** 확인하는 과정입니다.

```
건물 출입 비유:

1. 사원증을 보여준다           → 인증 (Authentication)
   "이 사람이 우리 회사 직원인가?"

2. 층별 접근 권한을 확인한다    → 인가 (Authorization)
   "이 직원이 서버실에 들어갈 수 있는가?"
```

### 웹서버에서의 흐름

```
클라이언트 → POST /auth/login (이메일, 비밀번호)
서버       → 비밀번호 확인 (인증) → JWT 토큰 발급

클라이언트 → GET /admin/users (Authorization: Bearer <토큰>)
서버       → 토큰 검증 (인증) → 관리자 권한 확인 (인가) → 응답
```

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
|------|----------------------|---------------------|
| 질문 | "너 누구야?" | "너 이거 할 수 있어?" |
| 시점 | 먼저 | 인증 후에 |
| 방법 | 비밀번호, 토큰 | 역할(Role), 권한(Permission) |
| 실패 시 | 401 Unauthorized | 403 Forbidden |

---

## 2. 비밀번호 해싱

### 왜 비밀번호를 그대로 저장하면 안 되나?

데이터베이스가 해킹당하면 **모든 사용자의 비밀번호가 그대로 노출**됩니다.

```
나쁜 예 - 평문 저장:
┌──────────┬────────────┐
│ 이메일    │ 비밀번호    │
├──────────┼────────────┤
│ kim@a.com│ password123│  ← 해커가 DB를 탈취하면 바로 보임!
│ lee@b.com│ mySecret!  │
└──────────┴────────────┘

좋은 예 - 해시 저장:
┌──────────┬──────────────────────────────────┐
│ 이메일    │ 비밀번호 해시                      │
├──────────┼──────────────────────────────────┤
│ kim@a.com│ $argon2id$v=19$m=19456,t=2...   │  ← 원본 복원 불가!
│ lee@b.com│ $argon2id$v=19$m=19456,t=2...   │
└──────────┴──────────────────────────────────┘
```

### 해싱이란?

해싱은 **단방향 변환**입니다. 원본 데이터를 고정 길이의 문자열로 바꾸지만, **역변환은 불가능**합니다.

```
해싱:    "password123"  →  "$argon2id$v=19$m=19456..."   (가능)
역변환:  "$argon2id$v=19$m=19456..."  →  ???             (불가능!)
```

### argon2 크레이트 사용

argon2는 현재 가장 권장되는 비밀번호 해싱 알고리즘입니다.

```toml
# Cargo.toml
[dependencies]
argon2 = "0.5"
rand = "0.8"
```

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

/// 비밀번호를 해싱합니다
fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    let salt = SaltString::generate(&mut OsRng); // 랜덤 솔트 생성
    let argon2 = Argon2::default();
    let hash = argon2.hash_password(password.as_bytes(), &salt)?;
    Ok(hash.to_string())
}

/// 비밀번호가 해시와 일치하는지 검증합니다
fn verify_password(hash: &str, password: &str) -> Result<bool, argon2::password_hash::Error> {
    let parsed_hash = PasswordHash::new(hash)?;
    Ok(Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .is_ok())
}

fn main() {
    let password = "my_secret_password";

    // 해싱
    let hashed = hash_password(password).expect("해싱 실패");
    println!("해시: {}", hashed);

    // 검증
    let is_valid = verify_password(&hashed, password).expect("검증 실패");
    println!("비밀번호 일치: {}", is_valid); // true

    let is_valid = verify_password(&hashed, "wrong_password").expect("검증 실패");
    println!("잘못된 비밀번호: {}", is_valid); // false
}
```

```
출력:
해시: $argon2id$v=19$m=19456,t=2,p=1$랜덤솔트$해시값
비밀번호 일치: true
잘못된 비밀번호: false
```

> 같은 비밀번호를 두 번 해싱해도 **다른 해시값**이 나옵니다. 매번 랜덤 솔트가 다르기 때문입니다. 하지만 검증은 정상적으로 동작합니다.

<details>
<summary><b>해시 vs 암호화, 솔트(salt)란? (원리)</b></summary>

### 해시 vs 암호화

**해싱 (Hashing)**: 단방향. 원본을 복원할 수 없습니다.
- 용도: 비밀번호 저장, 데이터 무결성 검증
- 예: argon2, bcrypt, SHA-256

**암호화 (Encryption)**: 양방향. 키가 있으면 원본을 복원할 수 있습니다.
- 용도: 데이터 전송, 파일 보호
- 예: AES, RSA

```
해싱:   원본 → 해시값           (되돌릴 수 없음)
암호화: 원본 → 암호문 → 원본    (키가 있으면 되돌릴 수 있음)
```

비밀번호는 **해싱**을 사용합니다. 서버도 원본 비밀번호를 알 필요가 없기 때문입니다. 사용자가 입력한 비밀번호를 해싱해서 저장된 해시와 비교하면 됩니다.

### 솔트(Salt)란?

솔트는 해싱 전에 비밀번호에 추가하는 **랜덤 문자열**입니다.

```
솔트가 없으면:
"password123" → 항상 같은 해시값
→ 해커가 "무지개 테이블(미리 계산한 해시 목록)"로 역추적 가능!

솔트가 있으면:
"password123" + "랜덤솔트A" → 해시값1
"password123" + "랜덤솔트B" → 해시값2  (같은 비밀번호인데 다른 해시!)
→ 무지개 테이블 공격 무력화
```

argon2는 솔트를 자동으로 해시값에 포함시킵니다. 별도로 솔트를 저장할 필요가 없습니다.

### 왜 argon2인가?

| 알고리즘 | 장점 | 단점 |
|---------|------|------|
| MD5/SHA | 빠름 | 너무 빨라서 무차별 대입에 취약 |
| bcrypt | 느리게 설계됨 | GPU 공격에 상대적으로 약함 |
| argon2 | 메모리 사용량 조절 가능, GPU 공격에 강함 | 상대적으로 최신 |

argon2는 2015년 Password Hashing Competition 우승 알고리즘이며, 현재 가장 권장되는 방식입니다.

</details>

---

## 3. JWT 토큰

### JWT란?

JWT(JSON Web Token)는 **사용자 인증 정보를 담은 토큰**입니다. 서버가 로그인 성공 시 발급하고, 클라이언트가 이후 요청마다 토큰을 보내서 인증합니다.

```
로그인 흐름:

1. 클라이언트: POST /auth/login { email, password }
2. 서버:       비밀번호 확인 → JWT 토큰 발급 → 응답에 토큰 포함
3. 클라이언트: 토큰을 저장

이후 요청:
4. 클라이언트: GET /api/profile  (헤더: Authorization: Bearer <토큰>)
5. 서버:       토큰 검증 → 사용자 정보 확인 → 응답
```

### JWT 구조: Header.Payload.Signature

JWT는 점(`.`)으로 구분된 세 부분으로 구성됩니다.

```
eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEsImV4cCI6MTcwMH0.서명값
|___________________|.|__________________________|.|_____|
      Header                  Payload              Signature

Header:    어떤 알고리즘으로 서명했는지 (예: HS256)
Payload:   실제 데이터 (사용자 ID, 만료 시간 등)
Signature: 위조 방지용 서명 (서버의 비밀 키로 생성)
```

> Payload는 **누구나 디코딩할 수 있습니다**. 비밀번호 같은 민감한 정보는 절대 넣지 마세요! 토큰의 목적은 "이 토큰이 서버가 발급한 진짜인지" 확인하는 것입니다.

### jsonwebtoken 크레이트 사용

```toml
# Cargo.toml
[dependencies]
jsonwebtoken = "9"
serde = { version = "1", features = ["derive"] }
chrono = "0.4"
```

```rust
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};

/// JWT에 담길 데이터 (Claims)
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: i32,      // subject: 사용자 ID
    exp: usize,    // expiration: 만료 시간 (Unix timestamp)
}

const SECRET: &[u8] = b"my-super-secret-key"; // 실제로는 환경변수로 관리!

/// JWT 토큰을 생성합니다
fn create_token(user_id: i32) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(24))
        .expect("유효한 타임스탬프")
        .timestamp() as usize;

    let claims = Claims {
        sub: user_id,
        exp: expiration,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(SECRET),
    )
}

/// JWT 토큰을 검증하고 Claims를 반환합니다
fn verify_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(SECRET),
        &Validation::default(),
    )?;
    Ok(token_data.claims)
}

fn main() {
    // 토큰 생성
    let token = create_token(42).expect("토큰 생성 실패");
    println!("토큰: {}", token);

    // 토큰 검증
    match verify_token(&token) {
        Ok(claims) => println!("사용자 ID: {}", claims.sub),
        Err(e) => println!("토큰 검증 실패: {}", e),
    }

    // 잘못된 토큰 검증
    match verify_token("invalid.token.here") {
        Ok(_) => println!("성공"),
        Err(e) => println!("예상대로 실패: {}", e),
    }
}
```

```
출력:
토큰: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjQyLCJleHAiOjE3MDAwMDAwMDB9.서명값
사용자 ID: 42
예상대로 실패: InvalidToken
```

<details>
<summary><b>JWT의 장단점, 세션 vs 토큰 비교 (원리)</b></summary>

### 세션 방식 vs 토큰 방식

**세션 방식**:
```
1. 로그인 → 서버가 세션 ID 생성 → 서버 메모리/DB에 세션 저장
2. 클라이언트에게 세션 ID 쿠키 전달
3. 매 요청마다 서버가 세션 저장소에서 사용자 정보 조회
```

**토큰(JWT) 방식**:
```
1. 로그인 → 서버가 JWT 생성 → 클라이언트에게 전달
2. 클라이언트가 토큰 저장 (로컬 스토리지 등)
3. 매 요청마다 서버가 토큰의 서명만 검증 (저장소 조회 불필요!)
```

| 구분 | 세션 | JWT |
|------|------|-----|
| 저장 위치 | 서버 | 클라이언트 |
| 서버 부하 | 높음 (매번 조회) | 낮음 (서명 검증만) |
| 확장성 | 어려움 (서버 간 세션 공유 필요) | 쉬움 (서버가 상태를 안 가짐) |
| 무효화 | 쉬움 (세션 삭제) | 어려움 (만료 전까지 유효) |
| 보안 | 서버에서 제어 | 토큰 탈취 시 위험 |

### JWT의 장점
- **서버가 상태를 저장하지 않음** (Stateless): 서버 확장이 쉬움
- **다른 서비스와 인증 공유** 가능: 마이크로서비스에 적합
- **DB 조회 없이 인증** 가능: 성능 우수

### JWT의 단점
- **토큰 무효화가 어려움**: 만료 전까지 강제 로그아웃 불가 (별도 블랙리스트 필요)
- **토큰 크기가 큼**: 세션 ID보다 데이터가 많음
- **Payload 노출**: Base64로 인코딩만 된 것이라 누구나 읽을 수 있음

### 실무 팁
- Access Token은 짧게 (15분~1시간), Refresh Token은 길게 (7일~30일)
- 민감한 데이터는 Payload에 넣지 않기
- HTTPS를 반드시 사용하기

</details>

---

## 4. 회원가입 / 로그인 API

이제 앞에서 배운 비밀번호 해싱과 JWT를 합쳐서 실제 회원가입/로그인 API를 만들어봅시다.

### 프로젝트 설정

```toml
# Cargo.toml
[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
jsonwebtoken = "9"
argon2 = "0.5"
rand = "0.8"
chrono = "0.4"
```

### 데이터 구조 정의

```rust
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

/// 사용자 정보
#[derive(Debug, Clone, Serialize)]
struct User {
    id: i32,
    email: String,
    password_hash: String, // 해시된 비밀번호
    role: Role,
}

/// 사용자 역할
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
enum Role {
    User,
    Admin,
}

/// 회원가입 요청
#[derive(Deserialize)]
struct RegisterRequest {
    email: String,
    password: String,
}

/// 로그인 요청
#[derive(Deserialize)]
struct LoginRequest {
    email: String,
    password: String,
}

/// 토큰 응답
#[derive(Serialize)]
struct TokenResponse {
    token: String,
}

/// 에러 응답
#[derive(Serialize)]
struct ErrorResponse {
    error: String,
}

/// 앱 상태 (실제로는 데이터베이스를 사용합니다)
#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<Vec<User>>>,
    next_id: Arc<Mutex<i32>>,
}
```

### JWT 유틸리티 함수

```rust
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: i32,       // 사용자 ID
    role: String,   // 역할
    exp: usize,     // 만료 시간
}

const JWT_SECRET: &[u8] = b"your-secret-key-change-in-production";

fn create_token(user_id: i32, role: &Role) -> Result<String, jsonwebtoken::errors::Error> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(24))
        .expect("유효한 타임스탬프")
        .timestamp() as usize;

    let claims = Claims {
        sub: user_id,
        role: format!("{:?}", role),
        exp: expiration,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(JWT_SECRET),
    )
}

fn verify_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(JWT_SECRET),
        &Validation::default(),
    )?;
    Ok(token_data.claims)
}
```

### 회원가입 핸들러

```rust
use axum::{extract::State, http::StatusCode, Json};

async fn register(
    State(state): State<AppState>,
    Json(body): Json<RegisterRequest>,
) -> Result<Json<TokenResponse>, (StatusCode, Json<ErrorResponse>)> {
    // 1. 입력 검증 (얼리 리턴)
    if body.email.is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: "이메일을 입력하세요".to_string() }),
        ));
    }
    if body.password.len() < 8 {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: "비밀번호는 8자 이상이어야 합니다".to_string() }),
        ));
    }

    let mut users = state.users.lock().unwrap();

    // 2. 이메일 중복 확인 (얼리 리턴)
    if users.iter().any(|u| u.email == body.email) {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse { error: "이미 등록된 이메일입니다".to_string() }),
        ));
    }

    // 3. 비밀번호 해싱
    let password_hash = hash_password(&body.password).map_err(|_| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "비밀번호 해싱 실패".to_string() }),
        )
    })?;

    // 4. 사용자 생성
    let mut next_id = state.next_id.lock().unwrap();
    let user_id = *next_id;
    *next_id += 1;

    let user = User {
        id: user_id,
        email: body.email,
        password_hash,
        role: Role::User,
    };
    users.push(user);

    // 5. 토큰 발급
    let token = create_token(user_id, &Role::User).map_err(|_| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "토큰 생성 실패".to_string() }),
        )
    })?;

    Ok(Json(TokenResponse { token }))
}
```

### 로그인 핸들러

```rust
async fn login(
    State(state): State<AppState>,
    Json(body): Json<LoginRequest>,
) -> Result<Json<TokenResponse>, (StatusCode, Json<ErrorResponse>)> {
    let users = state.users.lock().unwrap();

    // 1. 사용자 찾기 (얼리 리턴)
    let user = users.iter().find(|u| u.email == body.email);
    let user = match user {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse { error: "이메일 또는 비밀번호가 틀렸습니다".to_string() }),
            ));
        }
    };

    // 2. 비밀번호 검증 (얼리 리턴)
    let is_valid = verify_password(&user.password_hash, &body.password).unwrap_or(false);
    if !is_valid {
        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse { error: "이메일 또는 비밀번호가 틀렸습니다".to_string() }),
        ));
    }

    // 3. 토큰 발급
    let token = create_token(user.id, &user.role).map_err(|_| {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            Json(ErrorResponse { error: "토큰 생성 실패".to_string() }),
        )
    })?;

    Ok(Json(TokenResponse { token }))
}
```

> 로그인 실패 시 "이메일이 틀렸습니다" 또는 "비밀번호가 틀렸습니다"로 구분하지 않습니다. 공격자에게 **어떤 이메일이 등록되어 있는지 알려주지 않기 위해** 같은 메시지를 사용합니다.

### 라우터 조립

```rust
use axum::Router;
use axum::routing::post;

#[tokio::main]
async fn main() {
    let state = AppState {
        users: Arc::new(Mutex::new(Vec::new())),
        next_id: Arc::new(Mutex::new(1)),
    };

    let app = Router::new()
        .route("/auth/register", post(register))
        .route("/auth/login", post(login))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("서버 시작: http://127.0.0.1:3000");
    axum::serve(listener, app).await.unwrap();
}
```

---

## 5. 인증 미들웨어

매 요청마다 토큰을 검증하는 코드를 반복하면 비효율적입니다. **미들웨어**로 만들어서 자동으로 처리합시다.

### Authorization 헤더에서 토큰 추출

클라이언트는 이런 형식으로 토큰을 보냅니다:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOjQyLCJleHA...
```

### 커스텀 추출자(Extractor) 만들기

Axum에서는 **FromRequestParts** 트레이트를 구현해서 커스텀 추출자를 만들 수 있습니다. 이렇게 하면 핸들러 매개변수에 `AuthUser`를 넣기만 하면 자동으로 인증이 처리됩니다.

```rust
use axum::{
    async_trait,
    extract::FromRequestParts,
    http::{header, request::Parts, StatusCode},
    response::{IntoResponse, Response},
    Json,
};

/// 인증된 사용자 정보
#[derive(Debug, Clone)]
struct AuthUser {
    user_id: i32,
    role: String,
}

/// 인증 에러
#[derive(Debug)]
enum AuthError {
    MissingToken,
    InvalidToken,
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AuthError::MissingToken => (StatusCode::UNAUTHORIZED, "토큰이 없습니다"),
            AuthError::InvalidToken => (StatusCode::UNAUTHORIZED, "유효하지 않은 토큰입니다"),
        };
        (status, Json(ErrorResponse { error: message.to_string() })).into_response()
    }
}

#[async_trait]
impl<S> FromRequestParts<S> for AuthUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        // 1. Authorization 헤더 추출 (얼리 리턴)
        let auth_header = parts
            .headers
            .get(header::AUTHORIZATION)
            .and_then(|value| value.to_str().ok());

        let auth_header = match auth_header {
            Some(h) => h,
            None => return Err(AuthError::MissingToken),
        };

        // 2. "Bearer " 접두사 제거 (얼리 리턴)
        if !auth_header.starts_with("Bearer ") {
            return Err(AuthError::InvalidToken);
        }
        let token = &auth_header[7..];

        // 3. 토큰 검증 (얼리 리턴)
        let claims = verify_token(token).map_err(|_| AuthError::InvalidToken)?;

        // 4. 인증된 사용자 정보 반환
        Ok(AuthUser {
            user_id: claims.sub,
            role: claims.role,
        })
    }
}
```

### 인증이 필요한 핸들러에서 사용

```rust
/// 내 프로필 조회 - 인증 필요
async fn get_profile(auth_user: AuthUser) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "user_id": auth_user.user_id,
        "role": auth_user.role,
        "message": "인증된 사용자만 볼 수 있습니다"
    }))
}

/// 라우터에 추가
let app = Router::new()
    .route("/auth/register", post(register))
    .route("/auth/login", post(login))
    .route("/api/profile", axum::routing::get(get_profile))  // AuthUser 추출자가 자동 인증
    .with_state(state);
```

`AuthUser`를 매개변수에 넣으면 Axum이 자동으로 `from_request_parts`를 호출합니다. 토큰이 없거나 유효하지 않으면 **핸들러 코드에 도달하기 전에** 401 에러가 반환됩니다.

```
요청: GET /api/profile (토큰 없음)
→ AuthUser 추출 실패 → 401 "토큰이 없습니다"

요청: GET /api/profile (유효한 토큰)
→ AuthUser 추출 성공 → get_profile 핸들러 실행 → 프로필 응답
```

---

## 6. 권한 기반 접근 제어

인증(누구인지 확인)은 했으니, 이제 인가(권한 확인)를 구현합시다.

### Role enum

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
enum Role {
    User,
    Admin,
}

impl Role {
    fn from_str(s: &str) -> Self {
        match s {
            "Admin" => Role::Admin,
            _ => Role::User,
        }
    }
}
```

### 역할에 따른 API 접근 제한

가장 간단한 방법은 핸들러 안에서 직접 역할을 확인하는 것입니다.

```rust
/// 관리자 전용 - 모든 사용자 목록 조회
async fn list_users(
    auth_user: AuthUser,
    State(state): State<AppState>,
) -> Result<Json<Vec<serde_json::Value>>, (StatusCode, Json<ErrorResponse>)> {
    // 관리자 권한 확인 (얼리 리턴)
    if auth_user.role != "Admin" {
        return Err((
            StatusCode::FORBIDDEN,
            Json(ErrorResponse { error: "관리자 권한이 필요합니다".to_string() }),
        ));
    }

    let users = state.users.lock().unwrap();
    let user_list: Vec<serde_json::Value> = users
        .iter()
        .map(|u| {
            serde_json::json!({
                "id": u.id,
                "email": u.email,
                "role": u.role,
            })
        })
        .collect();

    Ok(Json(user_list))
}
```

### RequireRole 추출자로 깔끔하게

매번 핸들러에서 역할을 확인하면 반복 코드가 생깁니다. 추출자로 만들어봅시다.

```rust
/// 관리자 권한 추출자
struct RequireAdmin(AuthUser);

#[async_trait]
impl<S> FromRequestParts<S> for RequireAdmin
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        // 1. 먼저 인증 확인
        let auth_user = AuthUser::from_request_parts(parts, state).await?;

        // 2. 관리자 권한 확인 (얼리 리턴)
        if auth_user.role != "Admin" {
            return Err(AuthError::Forbidden);
        }

        Ok(RequireAdmin(auth_user))
    }
}
```

`AuthError`에 `Forbidden` 변형을 추가합니다:

```rust
#[derive(Debug)]
enum AuthError {
    MissingToken,
    InvalidToken,
    Forbidden,
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AuthError::MissingToken => (StatusCode::UNAUTHORIZED, "토큰이 없습니다"),
            AuthError::InvalidToken => (StatusCode::UNAUTHORIZED, "유효하지 않은 토큰입니다"),
            AuthError::Forbidden => (StatusCode::FORBIDDEN, "권한이 없습니다"),
        };
        (status, Json(ErrorResponse { error: message.to_string() })).into_response()
    }
}
```

이제 관리자 전용 핸들러가 깔끔해집니다:

```rust
/// 관리자 전용 핸들러 - RequireAdmin만 넣으면 끝!
async fn admin_dashboard(RequireAdmin(auth_user): RequireAdmin) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "관리자 대시보드",
        "admin_id": auth_user.user_id
    }))
}

// 라우터
let app = Router::new()
    .route("/auth/register", post(register))
    .route("/auth/login", post(login))
    .route("/api/profile", axum::routing::get(get_profile))          // 로그인 사용자
    .route("/admin/dashboard", axum::routing::get(admin_dashboard))  // 관리자만
    .with_state(state);
```

```
요청 흐름:

GET /admin/dashboard (일반 사용자 토큰)
→ AuthUser 추출 성공 → 역할 확인: "User" → 403 "권한이 없습니다"

GET /admin/dashboard (관리자 토큰)
→ AuthUser 추출 성공 → 역할 확인: "Admin" → 관리자 대시보드 응답
```

---

## 7. 전체 흐름 요약

지금까지 구현한 인증/인가 시스템의 전체 흐름입니다.

```
┌─────────────────────────────────────────────────────────┐
│                    인증/인가 전체 흐름                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. 회원가입 (POST /auth/register)                       │
│     요청: { email, password }                           │
│     처리: 입력 검증 → 비밀번호 해싱(argon2) → DB 저장       │
│     응답: { token: "..." }                              │
│                                                         │
│  2. 로그인 (POST /auth/login)                           │
│     요청: { email, password }                           │
│     처리: 사용자 조회 → 비밀번호 검증 → JWT 발급            │
│     응답: { token: "..." }                              │
│                                                         │
│  3. 인증된 요청 (GET /api/profile)                       │
│     헤더: Authorization: Bearer <토큰>                   │
│     처리: 토큰 추출 → 서명 검증 → 만료 확인 → AuthUser 생성 │
│     응답: { user_id, role, ... }                        │
│                                                         │
│  4. 권한 확인 (GET /admin/dashboard)                     │
│     처리: 인증 → 역할 확인 → Admin이면 허용               │
│     실패: 403 Forbidden                                 │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 8. 실습

### 실습 1: 비밀번호 해싱/검증 함수 만들기

비밀번호를 해싱하고 검증하는 프로그램을 만드세요.

```rust
// Cargo.toml:
// [dependencies]
// argon2 = "0.5"
// rand = "0.8"

use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

// 여기에 코드를 작성하세요!
// 1. hash_password(password: &str) -> Result<String, String> 함수를 만드세요
//    - argon2로 비밀번호를 해싱하여 반환
//    - 에러 시 에러 메시지 반환
//
// 2. verify_password(hash: &str, password: &str) -> bool 함수를 만드세요
//    - 해시와 비밀번호가 일치하면 true
//
// 3. main에서:
//    - "rust_is_awesome"을 해싱
//    - 같은 비밀번호로 검증 (true)
//    - 다른 비밀번호로 검증 (false)
//    - 같은 비밀번호를 두 번 해싱해서 해시값이 다른지 확인

// 예상 출력:
// 해시 1: $argon2id$v=19$m=19456,t=2,p=1$...
// 해시 2: $argon2id$v=19$m=19456,t=2,p=1$...
// 두 해시가 같은가? false (솔트가 다르니까!)
// 올바른 비밀번호: true
// 잘못된 비밀번호: false
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};

fn hash_password(password: &str) -> Result<String, String> {
    let salt = SaltString::generate(&mut OsRng);
    let argon2 = Argon2::default();
    let hash = argon2
        .hash_password(password.as_bytes(), &salt)
        .map_err(|e| format!("해싱 실패: {}", e))?;
    Ok(hash.to_string())
}

fn verify_password(hash: &str, password: &str) -> bool {
    let parsed_hash = match PasswordHash::new(hash) {
        Ok(h) => h,
        Err(_) => return false,
    };
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed_hash)
        .is_ok()
}

fn main() {
    let password = "rust_is_awesome";

    let hash1 = hash_password(password).expect("해싱 실패");
    let hash2 = hash_password(password).expect("해싱 실패");

    println!("해시 1: {}", hash1);
    println!("해시 2: {}", hash2);
    println!("두 해시가 같은가? {}", hash1 == hash2);

    println!("올바른 비밀번호: {}", verify_password(&hash1, password));
    println!("잘못된 비밀번호: {}", verify_password(&hash1, "wrong"));
}
```

</details>

### 실습 2: JWT 토큰 발급/검증 함수 만들기

JWT 토큰을 발급하고 검증하는 프로그램을 만드세요.

```rust
// Cargo.toml:
// [dependencies]
// jsonwebtoken = "9"
// serde = { version = "1", features = ["derive"] }
// chrono = "0.4"

use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};

// 여기에 코드를 작성하세요!
// 1. Claims 구조체를 정의하세요
//    - sub: i32 (사용자 ID)
//    - email: String (이메일)
//    - exp: usize (만료 시간)
//
// 2. create_token(user_id: i32, email: &str) -> Result<String, String>
//    - 만료 시간: 현재 시간 + 1시간
//    - 비밀 키: b"practice-secret-key"
//
// 3. verify_token(token: &str) -> Result<Claims, String>
//    - 토큰을 검증하고 Claims를 반환
//
// 4. main에서:
//    - user_id=1, email="test@example.com"으로 토큰 생성
//    - 생성된 토큰 검증 후 Claims 출력
//    - 잘못된 토큰 검증 시 에러 출력

// 예상 출력:
// 토큰: eyJ0eXAiOi...
// 검증 성공 - 사용자 ID: 1, 이메일: test@example.com
// 잘못된 토큰: 토큰 검증 실패: ...
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: i32,
    email: String,
    exp: usize,
}

const SECRET: &[u8] = b"practice-secret-key";

fn create_token(user_id: i32, email: &str) -> Result<String, String> {
    let expiration = Utc::now()
        .checked_add_signed(Duration::hours(1))
        .expect("유효한 타임스탬프")
        .timestamp() as usize;

    let claims = Claims {
        sub: user_id,
        email: email.to_string(),
        exp: expiration,
    };

    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(SECRET),
    )
    .map_err(|e| format!("토큰 생성 실패: {}", e))
}

fn verify_token(token: &str) -> Result<Claims, String> {
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(SECRET),
        &Validation::default(),
    )
    .map_err(|e| format!("토큰 검증 실패: {}", e))?;

    Ok(token_data.claims)
}

fn main() {
    // 토큰 생성
    let token = create_token(1, "test@example.com").expect("토큰 생성 실패");
    println!("토큰: {}", token);

    // 토큰 검증
    match verify_token(&token) {
        Ok(claims) => {
            println!("검증 성공 - 사용자 ID: {}, 이메일: {}", claims.sub, claims.email);
        }
        Err(e) => println!("검증 실패: {}", e),
    }

    // 잘못된 토큰
    match verify_token("invalid.token.value") {
        Ok(_) => println!("성공"),
        Err(e) => println!("잘못된 토큰: {}", e),
    }
}
```

</details>

### 실습 3: 로그인 API + 인증 미들웨어 구현

회원가입, 로그인, 인증된 요청을 처리하는 간단한 웹서버를 만드세요.

```rust
// Cargo.toml:
// [dependencies]
// axum = "0.7"
// tokio = { version = "1", features = ["full"] }
// serde = { version = "1", features = ["derive"] }
// serde_json = "1"
// jsonwebtoken = "9"
// argon2 = "0.5"
// rand = "0.8"
// chrono = "0.4"

// 여기에 코드를 작성하세요!
// 1. 앱 상태: 사용자 목록을 메모리에 저장 (Vec<User>를 Arc<Mutex<>>로 감싸기)
//
// 2. POST /auth/register 핸들러:
//    - 이메일, 비밀번호를 받아서 사용자 생성
//    - 비밀번호는 argon2로 해싱
//    - JWT 토큰 반환
//
// 3. POST /auth/login 핸들러:
//    - 이메일, 비밀번호 검증
//    - 성공 시 JWT 토큰 반환
//
// 4. GET /api/me 핸들러 (인증 필요):
//    - Authorization 헤더에서 토큰 추출
//    - 토큰 검증 후 사용자 정보 반환
//
// 5. 서버를 127.0.0.1:3000에서 실행

// 테스트 방법 (curl 또는 Postman):
// 1. 회원가입:
//    curl -X POST http://127.0.0.1:3000/auth/register \
//      -H "Content-Type: application/json" \
//      -d '{"email":"test@example.com","password":"12345678"}'
//
// 2. 로그인:
//    curl -X POST http://127.0.0.1:3000/auth/login \
//      -H "Content-Type: application/json" \
//      -d '{"email":"test@example.com","password":"12345678"}'
//
// 3. 인증된 요청:
//    curl http://127.0.0.1:3000/api/me \
//      -H "Authorization: Bearer <받은_토큰>"
```

<details>
<summary><b>정답 보기</b></summary>

```rust
use axum::{
    async_trait,
    extract::{FromRequestParts, State},
    http::{header, request::Parts, StatusCode},
    response::{IntoResponse, Response},
    routing::{get, post},
    Json, Router,
};
use argon2::{
    password_hash::{rand_core::OsRng, PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2,
};
use chrono::{Duration, Utc};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

// === 데이터 구조 ===

#[derive(Debug, Clone)]
struct User {
    id: i32,
    email: String,
    password_hash: String,
}

#[derive(Clone)]
struct AppState {
    users: Arc<Mutex<Vec<User>>>,
    next_id: Arc<Mutex<i32>>,
}

#[derive(Deserialize)]
struct RegisterRequest {
    email: String,
    password: String,
}

#[derive(Deserialize)]
struct LoginRequest {
    email: String,
    password: String,
}

#[derive(Serialize)]
struct TokenResponse {
    token: String,
}

#[derive(Serialize)]
struct ErrorResponse {
    error: String,
}

// === JWT ===

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: i32,
    exp: usize,
}

const SECRET: &[u8] = b"my-secret-key";

fn create_token(user_id: i32) -> Result<String, jsonwebtoken::errors::Error> {
    let exp = Utc::now()
        .checked_add_signed(Duration::hours(24))
        .expect("유효한 타임스탬프")
        .timestamp() as usize;

    encode(
        &Header::default(),
        &Claims { sub: user_id, exp },
        &EncodingKey::from_secret(SECRET),
    )
}

fn decode_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(SECRET),
        &Validation::default(),
    )?;
    Ok(data.claims)
}

// === 비밀번호 ===

fn hash_pw(password: &str) -> Result<String, String> {
    let salt = SaltString::generate(&mut OsRng);
    Argon2::default()
        .hash_password(password.as_bytes(), &salt)
        .map(|h| h.to_string())
        .map_err(|e| e.to_string())
}

fn verify_pw(hash: &str, password: &str) -> bool {
    let parsed = match PasswordHash::new(hash) {
        Ok(h) => h,
        Err(_) => return false,
    };
    Argon2::default()
        .verify_password(password.as_bytes(), &parsed)
        .is_ok()
}

// === 인증 추출자 ===

#[derive(Debug, Clone)]
struct AuthUser {
    user_id: i32,
}

enum AuthError {
    Missing,
    Invalid,
}

impl IntoResponse for AuthError {
    fn into_response(self) -> Response {
        let (status, msg) = match self {
            AuthError::Missing => (StatusCode::UNAUTHORIZED, "토큰이 없습니다"),
            AuthError::Invalid => (StatusCode::UNAUTHORIZED, "유효하지 않은 토큰입니다"),
        };
        (status, Json(ErrorResponse { error: msg.to_string() })).into_response()
    }
}

#[async_trait]
impl<S: Send + Sync> FromRequestParts<S> for AuthUser {
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {
        let header = parts
            .headers
            .get(header::AUTHORIZATION)
            .and_then(|v| v.to_str().ok());

        let header = match header {
            Some(h) => h,
            None => return Err(AuthError::Missing),
        };

        if !header.starts_with("Bearer ") {
            return Err(AuthError::Invalid);
        }

        let claims = decode_token(&header[7..]).map_err(|_| AuthError::Invalid)?;
        Ok(AuthUser { user_id: claims.sub })
    }
}

// === 핸들러 ===

async fn register(
    State(state): State<AppState>,
    Json(body): Json<RegisterRequest>,
) -> Result<Json<TokenResponse>, (StatusCode, Json<ErrorResponse>)> {
    if body.email.is_empty() || body.password.len() < 8 {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse { error: "이메일과 8자 이상 비밀번호가 필요합니다".into() }),
        ));
    }

    let mut users = state.users.lock().unwrap();
    if users.iter().any(|u| u.email == body.email) {
        return Err((
            StatusCode::CONFLICT,
            Json(ErrorResponse { error: "이미 등록된 이메일입니다".into() }),
        ));
    }

    let password_hash = hash_pw(&body.password).map_err(|e| {
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse { error: e }))
    })?;

    let mut next_id = state.next_id.lock().unwrap();
    let id = *next_id;
    *next_id += 1;

    users.push(User { id, email: body.email, password_hash });

    let token = create_token(id).map_err(|e| {
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse { error: e.to_string() }))
    })?;

    Ok(Json(TokenResponse { token }))
}

async fn login(
    State(state): State<AppState>,
    Json(body): Json<LoginRequest>,
) -> Result<Json<TokenResponse>, (StatusCode, Json<ErrorResponse>)> {
    let users = state.users.lock().unwrap();

    let user = match users.iter().find(|u| u.email == body.email) {
        Some(u) => u,
        None => {
            return Err((
                StatusCode::UNAUTHORIZED,
                Json(ErrorResponse { error: "이메일 또는 비밀번호가 틀렸습니다".into() }),
            ));
        }
    };

    if !verify_pw(&user.password_hash, &body.password) {
        return Err((
            StatusCode::UNAUTHORIZED,
            Json(ErrorResponse { error: "이메일 또는 비밀번호가 틀렸습니다".into() }),
        ));
    }

    let token = create_token(user.id).map_err(|e| {
        (StatusCode::INTERNAL_SERVER_ERROR, Json(ErrorResponse { error: e.to_string() }))
    })?;

    Ok(Json(TokenResponse { token }))
}

async fn get_me(auth: AuthUser) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "user_id": auth.user_id,
        "message": "인증 성공!"
    }))
}

#[tokio::main]
async fn main() {
    let state = AppState {
        users: Arc::new(Mutex::new(Vec::new())),
        next_id: Arc::new(Mutex::new(1)),
    };

    let app = Router::new()
        .route("/auth/register", post(register))
        .route("/auth/login", post(login))
        .route("/api/me", get(get_me))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("서버 시작: http://127.0.0.1:3000");
    axum::serve(listener, app).await.unwrap();
}
```

서버를 실행한 뒤, 다른 터미널에서 테스트하세요:

```bash
# 회원가입
curl -X POST http://127.0.0.1:3000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"12345678"}'

# 로그인
curl -X POST http://127.0.0.1:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"12345678"}'

# 인증된 요청 (위에서 받은 토큰 사용)
curl http://127.0.0.1:3000/api/me \
  -H "Authorization: Bearer <토큰>"
```

</details>

---

## 9. 확인 문제

### 문제 1

인증(Authentication)과 인가(Authorization)의 차이를 한 문장씩 설명하세요.

### 문제 2

비밀번호를 데이터베이스에 **평문(그대로)** 저장하면 안 되는 이유는?

### 문제 3

다음 코드에서 잘못된 부분을 찾으세요:

```rust
#[derive(Serialize, Deserialize)]
struct Claims {
    sub: i32,
    password: String,  // 사용자 비밀번호
    exp: usize,
}
```

### 문제 4

HTTP 상태 코드 **401**과 **403**의 차이는?
- (a) 401은 서버 에러, 403은 클라이언트 에러
- (b) 401은 인증 실패, 403은 권한 부족
- (c) 401은 요청 형식 오류, 403은 서버 거부
- (d) 401과 403은 같은 의미

### 문제 5

다음 인증 흐름에서 빈칸을 채우세요:

```
1. 사용자가 이메일과 비밀번호로 로그인 요청
2. 서버가 DB에서 사용자를 찾고 비밀번호를 ______로 검증
3. 검증 성공 시 ______ 토큰을 발급
4. 이후 요청마다 ______ 헤더에 토큰을 포함
5. 서버가 토큰의 ______을 검증하여 인증 처리
```

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
- **인증**: 사용자가 **누구인지** 확인하는 과정입니다. (예: 로그인)
- **인가**: 인증된 사용자가 **특정 자원에 접근할 권한이 있는지** 확인하는 과정입니다. (예: 관리자 페이지 접근)

### 문제 2 정답
데이터베이스가 해킹(유출)당하면 **모든 사용자의 비밀번호가 그대로 노출**됩니다. 해싱하면 원본 비밀번호를 복원할 수 없으므로, 유출되더라도 비밀번호가 안전합니다.

### 문제 3 정답
JWT의 Claims(Payload)에 **비밀번호를 넣으면 안 됩니다**. JWT의 Payload는 Base64 인코딩만 되어 있어서 **누구나 디코딩하여 내용을 읽을 수 있습니다**. 비밀번호, 개인정보 등 민감한 데이터는 절대 JWT에 포함하지 마세요.

```rust
// 올바른 예
#[derive(Serialize, Deserialize)]
struct Claims {
    sub: i32,     // 사용자 ID만
    role: String, // 역할 정보
    exp: usize,
}
```

### 문제 4 정답: **(b) 401은 인증 실패, 403은 권한 부족**

- **401 Unauthorized**: "너 누구야? 인증이 안 됐어." (토큰이 없거나 유효하지 않음)
- **403 Forbidden**: "너 누군지는 알겠는데, 이건 못 해." (인증은 됐지만 권한이 없음)

### 문제 5 정답

```
1. 사용자가 이메일과 비밀번호로 로그인 요청
2. 서버가 DB에서 사용자를 찾고 비밀번호를 해시(argon2)로 검증
3. 검증 성공 시 JWT 토큰을 발급
4. 이후 요청마다 Authorization 헤더에 토큰을 포함
5. 서버가 토큰의 서명(Signature)을 검증하여 인증 처리
```

</details>

---

## 10. 22장 정리

| 배운 것 | 핵심 |
|---------|------|
| 인증 vs 인가 | 인증은 "누구인지", 인가는 "할 수 있는지" |
| 비밀번호 해싱 | argon2로 단방향 해싱, 평문 저장 금지 |
| 솔트(Salt) | 랜덤 값을 추가해서 같은 비밀번호도 다른 해시 생성 |
| JWT 토큰 | Header.Payload.Signature 구조, 서버가 상태를 저장하지 않음 |
| 토큰 발급 | `jsonwebtoken::encode`로 Claims를 토큰으로 변환 |
| 토큰 검증 | `jsonwebtoken::decode`로 서명과 만료 시간 확인 |
| 인증 미들웨어 | `FromRequestParts` 트레이트로 커스텀 추출자 구현 |
| 권한 제어 | Role enum으로 역할 구분, 추출자로 권한 확인 자동화 |
| 401 vs 403 | 401은 인증 실패, 403은 권한 부족 |
| 보안 원칙 | 에러 메시지 통일, Payload에 민감 정보 금지, HTTPS 필수 |

---

## 다음 장 예고

> **23장. API 설계와 구현**에서는 RESTful API를 본격적으로 설계하고 구현합니다.
> CRUD(생성, 조회, 수정, 삭제) API를 만들고, 요청 유효성 검사, 페이지네이션, 에러 응답 표준화까지 실전 API 서버를 완성합니다!
