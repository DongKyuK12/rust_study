# 08장. 모듈과 패키지

> **목표**: 코드를 모듈로 나누어 정리하고, 외부 크레이트를 사용할 수 있다.

---

## 1. 모듈 시스템 (mod)

프로젝트가 커지면 모든 코드를 `main.rs` 하나에 넣을 수 없습니다. **모듈**로 코드를 나눠서 정리합니다.

### 모듈 만들기

`mod` 키워드로 모듈을 만듭니다:

```rust
mod greet {
    pub fn hello() {
        println!("안녕하세요!");
    }

    pub fn goodbye() {
        println!("안녕히 가세요!");
    }
}

fn main() {
    greet::hello();     // 안녕하세요!
    greet::goodbye();   // 안녕히 가세요!
}
```

`모듈이름::함수이름` 형태로 호출합니다. `::` 는 "안에 있는"이라는 뜻이에요.

### 모듈 안에 구조체 정의

```rust
mod user {
    pub struct User {
        pub name: String,
        pub age: u32,
    }

    impl User {
        pub fn new(name: &str, age: u32) -> User {
            User {
                name: String::from(name),
                age,
            }
        }

        pub fn introduce(&self) {
            println!("{}({}세)입니다.", self.name, self.age);
        }
    }
}

fn main() {
    let u = user::User::new("홍길동", 20);
    u.introduce(); // 홍길동(20세)입니다.
}
```

### 중첩 모듈

모듈 안에 모듈을 넣을 수 있습니다:

```rust
mod animal {
    pub mod dog {
        pub fn bark() {
            println!("멍멍!");
        }
    }

    pub mod cat {
        pub fn meow() {
            println!("야옹!");
        }
    }
}

fn main() {
    animal::dog::bark(); // 멍멍!
    animal::cat::meow(); // 야옹!
}
```

---

## 2. 가시성 (pub)

Rust에서 모듈 안의 항목은 **기본이 비공개(private)** 입니다.

### 기본은 비공개

```rust
mod secret {
    fn hidden() {
        println!("비밀 함수!");
    }

    pub fn visible() {
        println!("공개 함수!");
        hidden(); // 같은 모듈 안에서는 비공개 함수도 호출 가능
    }
}

fn main() {
    // secret::hidden();  // ❌ 에러! 비공개 함수
    secret::visible();    // ✅ 공개 함수
}
```

### pub으로 공개

외부에서 쓸 수 있게 하려면 `pub`을 붙입니다:

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    // pub 없음 = 비공개
    fn internal_log(msg: &str) {
        println!("[내부] {}", msg);
    }
}
```

### 구조체의 필드도 따로 pub 필요

구조체에 `pub`을 붙여도 **필드는 여전히 비공개**입니다:

```rust
mod account {
    pub struct Account {
        pub username: String,  // ✅ 공개
        password: String,      // ❌ 비공개 (pub 없음)
    }

    impl Account {
        pub fn new(username: &str, password: &str) -> Account {
            Account {
                username: String::from(username),
                password: String::from(password),
            }
        }
    }
}

fn main() {
    let acc = account::Account::new("admin", "1234");
    println!("사용자: {}", acc.username);  // ✅ 공개 필드
    // println!("비번: {}", acc.password); // ❌ 비공개 필드
}
```

<details>
<summary><b>🔍 왜 기본이 비공개인가? (원리)</b></summary>

### 캡슐화와 API 설계 원칙

기본이 비공개인 이유는 **캡슐화(encapsulation)** 때문입니다.

```
모듈 외부 (사용자)          모듈 내부 (구현)
┌─────────────┐          ┌─────────────────────┐
│             │    pub   │  pub fn login()      │ ← 공개 API
│  login() ───┼─────────→│    check_password()  │ ← 내부 구현
│             │          │    encrypt()         │ ← 내부 구현
│             │          │    validate()        │ ← 내부 구현
└─────────────┘          └─────────────────────┘
```

**왜 이렇게 할까요?**

1. **실수 방지**: 외부에서 내부 함수를 직접 호출하면 의도치 않은 버그가 생길 수 있습니다
2. **자유로운 수정**: 내부 구현은 마음대로 바꿔도 외부에 영향이 없습니다
3. **명확한 인터페이스**: `pub`이 붙은 것만 보면 "이 모듈을 어떻게 쓰는지" 바로 알 수 있습니다

비유하면, 식당에서 손님이 알아야 할 건 **메뉴판(pub)**뿐이고, 주방 레시피(private)는 알 필요가 없는 것과 같습니다. 레시피를 바꿔도 메뉴 이름이 같으면 손님은 모릅니다.

**설계 원칙**: 꼭 필요한 것만 `pub`으로 열고, 나머지는 닫아두세요.

</details>

---

## 3. use 키워드

매번 `모듈::함수` 전체 경로를 쓰면 길어집니다. `use`로 경로를 줄일 수 있습니다.

### use로 경로 단축

```rust
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    pub fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
}

use math::add;
use math::multiply;

fn main() {
    let sum = add(3, 5);          // math::add 대신 add
    let product = multiply(3, 5); // math::multiply 대신 multiply

    println!("합: {}, 곱: {}", sum, product);
}
```

### as 별칭

이름이 충돌하거나 너무 길 때 `as`로 별칭을 붙입니다:

```rust
use std::fmt::Result as FmtResult;
use std::io::Result as IoResult;

// 이제 FmtResult, IoResult로 구분해서 쓸 수 있음
```

### 중첩 use

여러 항목을 한 줄에서 가져올 수 있습니다:

```rust
// 이렇게 따로 쓰는 대신:
use std::io;
use std::fmt;

// 한 줄로:
use std::{io, fmt};

// 같은 모듈에서 여러 개:
use std::collections::{HashMap, HashSet, BTreeMap};
```

### 재내보내기: pub use

모듈 내부의 항목을 **바깥에서도 바로 쓸 수 있게** 다시 내보낼 수 있습니다:

```rust
mod models {
    pub struct User {
        pub name: String,
    }
}

// models::User를 바로 User로 쓸 수 있게 재내보내기
pub use models::User;

fn main() {
    // models::User 대신 User로 바로 사용
    let u = User {
        name: String::from("홍길동"),
    };
    println!("{}", u.name);
}
```

`pub use`는 라이브러리를 만들 때 특히 유용합니다. 내부 구조가 복잡해도 사용자에게는 깔끔한 경로를 제공할 수 있거든요.

---

## 4. 파일로 모듈 분리하기

지금까지는 한 파일 안에서 `mod { }` 블록을 썼습니다. 실제 프로젝트에서는 **파일 단위**로 모듈을 나눕니다.

### 단일 파일 모듈

`src/` 폴더에 파일을 만들면 그게 모듈이 됩니다:

**src/math.rs**
```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}
```

**src/main.rs**
```rust
mod math; // "math.rs 파일을 모듈로 가져와라"

fn main() {
    let result = math::add(3, 5);
    println!("3 + 5 = {}", result);
}
```

`mod math;` 한 줄이면 `src/math.rs` 파일 전체가 `math` 모듈이 됩니다.

### 디렉토리 모듈

하위 모듈이 여러 개면 **폴더**로 만듭니다:

**src/utils/mod.rs** (디렉토리 모듈의 진입점)
```rust
pub mod math;
pub mod string;
```

**src/utils/math.rs**
```rust
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

**src/utils/string.rs**
```rust
pub fn to_uppercase(s: &str) -> String {
    s.to_uppercase()
}
```

**src/main.rs**
```rust
mod utils;

fn main() {
    let sum = utils::math::add(3, 5);
    let upper = utils::string::to_uppercase("hello");

    println!("{}, {}", sum, upper); // 8, HELLO
}
```

### 실제 프로젝트 구조 예시

```
src/
├── main.rs          // mod models; mod utils;
├── models.rs        // 구조체, 데이터 모델
├── utils/
│   ├── mod.rs       // pub mod math; pub mod string;
│   ├── math.rs      // 수학 유틸리티 함수
│   └── string.rs    // 문자열 유틸리티 함수
```

**src/main.rs**
```rust
mod models;
mod utils;

use models::User;
use utils::math;

fn main() {
    let user = User::new("홍길동", 20);
    user.introduce();

    let result = math::add(10, 20);
    println!("10 + 20 = {}", result);
}
```

**src/models.rs**
```rust
pub struct User {
    pub name: String,
    pub age: u32,
}

impl User {
    pub fn new(name: &str, age: u32) -> User {
        User {
            name: String::from(name),
            age,
        }
    }

    pub fn introduce(&self) {
        println!("{}({}세)입니다.", self.name, self.age);
    }
}
```

<details>
<summary><b>🔍 mod.rs 방식 vs 파일이름.rs 방식 (원리)</b></summary>

### 2018 에디션 이후의 변화

Rust 2018 에디션부터 디렉토리 모듈을 만드는 방식이 **두 가지**가 되었습니다.

**방식 1: mod.rs 방식 (전통적)**
```
src/
├── main.rs
├── utils/
│   ├── mod.rs       // utils 모듈의 진입점
│   ├── math.rs
│   └── string.rs
```

**방식 2: 파일이름.rs 방식 (2018 에디션 이후)**
```
src/
├── main.rs
├── utils.rs         // utils 모듈의 진입점 (mod.rs 대신)
├── utils/
│   ├── math.rs
│   └── string.rs
```

두 방식 모두 `utils.rs` (또는 `utils/mod.rs`) 안의 내용은 동일합니다:
```rust
pub mod math;
pub mod string;
```

### 어떤 걸 쓸까?

| | mod.rs 방식 | 파일이름.rs 방식 |
|---|---|---|
| 구조 | `utils/mod.rs` | `utils.rs` + `utils/` |
| 장점 | 모든 관련 파일이 폴더 안에 있음 | 파일 탐색기에서 `mod.rs`가 여러 개 안 생김 |
| 단점 | 탭에 `mod.rs`가 여러 개 열림 | 파일과 폴더가 같은 이름으로 나란히 존재 |

**이 학습지에서는 `mod.rs` 방식을 사용합니다.** 초보자에게 더 직관적이기 때문입니다. 하지만 두 방식을 섞어 쓸 수는 없으니 프로젝트마다 하나로 통일하세요.

</details>

---

## 5. 외부 크레이트 사용하기

Rust에서는 외부 라이브러리를 **크레이트(crate)** 라고 부릅니다.

### Cargo.toml의 [dependencies]

외부 크레이트를 쓰려면 `Cargo.toml`에 추가합니다:

```toml
[package]
name = "my_project"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8"       # 랜덤 숫자 생성
```

### cargo add 명령어

`Cargo.toml`을 직접 수정하는 대신 명령어로도 추가할 수 있습니다:

```bash
cargo add rand
```

자동으로 최신 버전이 `Cargo.toml`에 추가됩니다.

### crates.io

**crates.io** (https://crates.io)는 Rust 크레이트들이 모여있는 공식 저장소입니다.

다른 언어로 비교하면:
| 언어 | 저장소 | Rust |
|------|--------|------|
| Python | PyPI | crates.io |
| JavaScript | npm | crates.io |
| Java | Maven Central | crates.io |

### 실용 예제: rand 크레이트로 랜덤 숫자 생성

먼저 크레이트를 추가합니다:
```bash
cargo add rand
```

```rust
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    // 1~100 사이 랜덤 정수
    let number: i32 = rng.gen_range(1..=100);
    println!("랜덤 숫자: {}", number);

    // 랜덤 불리언
    let coin: bool = rng.gen();
    if coin {
        println!("앞면!");
    } else {
        println!("뒷면!");
    }
}
```

### 앞으로 쓸 크레이트 미리보기

웹서버를 만들면서 자주 쓰게 될 크레이트들입니다:

| 크레이트 | 용도 | 배울 장 |
|----------|------|---------|
| `serde` | JSON 직렬화/역직렬화 | 16장~ |
| `tokio` | 비동기 런타임 | 14장~ |
| `axum` | 웹 프레임워크 | 17장~ |
| `sqlx` | 데이터베이스 연결 | 20장~ |
| `tower` | 미들웨어 | 18장~ |

지금은 이름만 기억해두세요. 각 장에서 하나씩 배웁니다.

---

## 6. 실습

### 실습 1: 계산기 모듈 만들기

한 파일 안에서 `calculator` 모듈을 만들고, 사칙연산 함수를 정의합니다.

```rust
mod calculator {
    pub fn add(a: f64, b: f64) -> f64 {
        a + b
    }

    pub fn subtract(a: f64, b: f64) -> f64 {
        a - b
    }

    pub fn multiply(a: f64, b: f64) -> f64 {
        a * b
    }

    pub fn divide(a: f64, b: f64) -> Result<f64, String> {
        if b == 0.0 {
            return Err(String::from("0으로 나눌 수 없습니다!"));
        }
        Ok(a / b)
    }
}

fn main() {
    let a = 10.0;
    let b = 3.0;

    println!("{} + {} = {}", a, b, calculator::add(a, b));
    println!("{} - {} = {}", a, b, calculator::subtract(a, b));
    println!("{} * {} = {}", a, b, calculator::multiply(a, b));

    match calculator::divide(a, b) {
        Ok(result) => println!("{} / {} = {:.2}", a, b, result),
        Err(msg) => println!("에러: {}", msg),
    }

    // 0으로 나누기 테스트
    match calculator::divide(a, 0.0) {
        Ok(result) => println!("결과: {}", result),
        Err(msg) => println!("에러: {}", msg),
    }
}
```

**실행 결과:**
```
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3.33
에러: 0으로 나눌 수 없습니다!
```

**도전**: `power(base, exp)` 거듭제곱 함수도 추가해보세요! (힌트: `f64::powi()`)

---

### 실습 2: 파일 분리 실습

프로젝트를 만들고 모듈을 파일로 분리합니다.

**Step 1: 프로젝트 생성**
```bash
cargo new calculator_app
cd calculator_app
```

**Step 2: src/calculator.rs 파일 생성**

```rust
pub fn add(a: f64, b: f64) -> f64 {
    a + b
}

pub fn subtract(a: f64, b: f64) -> f64 {
    a - b
}

pub fn multiply(a: f64, b: f64) -> f64 {
    a * b
}

pub fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        return Err(String::from("0으로 나눌 수 없습니다!"));
    }
    Ok(a / b)
}
```

**Step 3: src/main.rs 수정**

```rust
mod calculator;

use calculator::{add, subtract, multiply, divide};

fn main() {
    println!("=== 계산기 ===");
    println!("5 + 3 = {}", add(5.0, 3.0));
    println!("5 - 3 = {}", subtract(5.0, 3.0));
    println!("5 * 3 = {}", multiply(5.0, 3.0));

    match divide(5.0, 3.0) {
        Ok(result) => println!("5 / 3 = {:.2}", result),
        Err(msg) => println!("에러: {}", msg),
    }
}
```

**프로젝트 구조:**
```
calculator_app/
├── Cargo.toml
└── src/
    ├── main.rs         // mod calculator; 으로 연결
    └── calculator.rs   // 사칙연산 함수들
```

**실행:**
```bash
cargo run
```

**실행 결과:**
```
=== 계산기 ===
5 + 3 = 8
5 - 3 = 2
5 * 3 = 15
5 / 3 = 1.67
```

---

### 실습 3: rand 크레이트로 숫자 맞추기 게임

외부 크레이트를 사용해서 간단한 게임을 만듭니다.

**Step 1: 프로젝트 생성 및 크레이트 추가**
```bash
cargo new guessing_game
cd guessing_game
cargo add rand
```

**Step 2: src/main.rs 작성**

```rust
use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!("=== 숫자 맞추기 게임 ===");
    println!("1~100 사이의 숫자를 맞춰보세요!");

    let secret = rand::thread_rng().gen_range(1..=100);
    let mut attempts = 0;

    loop {
        println!("\n숫자를 입력하세요:");

        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .expect("입력을 읽을 수 없습니다.");

        let guess: i32 = match input.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("숫자를 입력해주세요!");
                continue;
            }
        };

        attempts += 1;

        match guess.cmp(&secret) {
            Ordering::Less => println!("더 큰 숫자입니다! ↑"),
            Ordering::Greater => println!("더 작은 숫자입니다! ↓"),
            Ordering::Equal => {
                println!("정답! {}번 만에 맞추셨습니다!", attempts);
                break;
            }
        }
    }
}
```

**실행:**
```bash
cargo run
```

**실행 예시:**
```
=== 숫자 맞추기 게임 ===
1~100 사이의 숫자를 맞춰보세요!

숫자를 입력하세요:
50
더 큰 숫자입니다! ↑

숫자를 입력하세요:
75
더 작은 숫자입니다! ↓

숫자를 입력하세요:
63
정답! 3번 만에 맞추셨습니다!
```

이 실습에서 사용한 새로운 요소:
- `rand` 외부 크레이트 (`cargo add rand`)
- `std::io`로 사용자 입력 받기
- `std::cmp::Ordering`으로 숫자 비교
- `parse()`로 문자열을 숫자로 변환

---

## 7. 확인 문제

### 문제 1
아래 코드가 에러나는 이유는?
```rust
mod tools {
    fn hammer() {
        println!("망치!");
    }
}

fn main() {
    tools::hammer();
}
```

### 문제 2
`pub struct`의 필드를 외부에서 접근하려면 어떻게 해야 하나요?

### 문제 3
아래 빈칸을 채우세요:
```rust
mod math {
    pub fn square(x: i32) -> i32 {
        x * x
    }
}

___ math::square;

fn main() {
    let result = square(5);
    println!("{}", result); // 25
}
```

### 문제 4
`src/helpers.rs` 파일을 모듈로 가져오려면 `main.rs`에 뭐라고 쓰나요?

### 문제 5
외부 크레이트를 프로젝트에 추가하는 방법 2가지를 설명하세요.

---

## 확인 문제 정답

<details>
<summary>정답 보기 (먼저 풀어본 후 클릭하세요!)</summary>

### 문제 1 정답
`hammer()` 함수에 `pub`이 없어서 비공개 상태입니다. 모듈 외부에서 호출할 수 없습니다.
수정: `pub fn hammer()`

### 문제 2 정답
구조체 자체에 `pub`을 붙이는 것만으로는 부족합니다. **각 필드에도 `pub`을 따로 붙여야** 합니다:
```rust
pub struct User {
    pub name: String,  // 필드에도 pub
    pub age: u32,      // 필드에도 pub
}
```

### 문제 3 정답
**`use`**
```rust
use math::square;
```

### 문제 4 정답
```rust
mod helpers;
```
이 한 줄이면 `src/helpers.rs` 파일 전체가 `helpers` 모듈로 들어옵니다.

### 문제 5 정답
1. **Cargo.toml 직접 수정**: `[dependencies]` 아래에 `크레이트이름 = "버전"` 추가
   ```toml
   [dependencies]
   rand = "0.8"
   ```
2. **cargo add 명령어**: 터미널에서 `cargo add 크레이트이름` 실행
   ```bash
   cargo add rand
   ```

</details>

---

## 8. 8장 정리

| 배운 것 | 핵심 |
|---------|------|
| 모듈 만들기 | `mod 이름 { }` 또는 별도 파일 |
| 가시성 | 기본 비공개, `pub`으로 공개 |
| 구조체 필드 | 구조체가 `pub`이어도 필드에 따로 `pub` 필요 |
| use | `use 모듈::항목;` 으로 경로 단축 |
| 별칭 | `use 모듈::항목 as 별칭;` |
| 중첩 use | `use std::{io, fmt};` |
| 재내보내기 | `pub use 모듈::항목;` |
| 파일 모듈 | `src/이름.rs` + `mod 이름;` |
| 디렉토리 모듈 | `src/이름/mod.rs` |
| 외부 크레이트 | `Cargo.toml`에 추가 또는 `cargo add` |
| crates.io | Rust 공식 크레이트 저장소 |

---

## 다음 장 예고

> **09장. 제네릭과 트레이트**에서는 코드를 더 유연하게 만드는 방법을 배웁니다.
> "어떤 타입이든 받을 수 있는 함수"를 만드는 제네릭, 그리고 "이 타입은 이런 기능을 할 수 있다"를 정의하는 트레이트를 알아봅니다!
